# HG changeset patch
# Parent ba36217fe29006158de51bb2ef3b830d273c2c95
# User Dave Yeo <daveryeo@telus.net>
Make a version of mzfntcfgft suitable for building 10esr

diff --git a/README b/README
--- a/README
+++ b/README
@@ -5,26 +5,27 @@
 To make use of this package for compilation of a Mozilla build that makes use
 of the cairo library, you need a GCC, and various other libraries and
 environment variables set. Please follow the guide at
    https://developer.mozilla.org/En/Developer_Guide/Build_Instructions/OS//2_Build_Prerequisites
    https://developer.mozilla.org/En/Developer_Guide/Build_Instructions/OS//2_Build_Prerequisites/Building_on_OS//2_using_Mercurial
 how to do this.
 
 Move the whole directory containing this package where you want it installed
-and then run
-   make -s
-   make clean
-This compiles all files, collects the object files into mzfntcfg.lib and mozft.lib
-and adapts the installation to your directory tree. Then it removes the unnecessary
-object files.
-(If for whatever reason you want to recompile everything, do
-   make -s nuke all
-   make clean
-This comes in handy on GCC upgrades.)
+then cd to the fontconfig directory and do make. Fontconfig\objs will contain
+the libraries. At this point copy fontconfig_s.a for static linking or fontconfig.lib
+to mzfntcfg.a or mzfntcfg.lib in the lib directory.
+Then cd to the freetype directory and do make which should correctly
+detect OS/2, then do make again to do the actual build (after the initial
+detection make only needs to be run once). Once again go to the freetype\objs
+directory and copy either freetype_s.a for static linking or freetype.lib to lib\mozft.a or mozft.lib
+depending on the original library name.
+For using in other products double check the lib\pkgconfig pc files for
+correct prefix and set PKG_CONFIG_PATH to point to the location of the
+pc files. eg SET PKG_CONFIG_PATH=g:/mzfntcfgft/lib/pkgconfig;%PKG_CONFIG_PATH%
 
 Now be sure to also adapt the MZFNTCFGFT variable in your setmozenv.cmd, so
 that this package can be used by the Mozilla build process. In case your
 setmozenv.cmd does _not_ yet contain these variables add the
 following lines:
   'set MZFTCFGFT=%ROOT%\mzfntcfgft'
   'set MZFTCFGFT2='backtoforward(value('MZFTCFGFT',,'OS2ENVIRONMENT'));
 
@@ -50,16 +51,17 @@
 See mzfntcfg.COPYING for copyright information. That file contains the required
 copyright notes from both base packages.
 (If you want to ship a program linked against this library, you should not
 forget to package mzfntcfg.COPYING, too, unless you built the program from
 current Mozilla trunk, which already has the necessary info in about:license.)
 
 
 - History
+20121227  - Various fixes to use the latest for building Mozilla apps
 20121221  - Update to Freetype 2.4.11
 20120522  - Updated Fontconfig to build nicely static and dynamic in one go
 20120522  - Seperate the Fontconfig part
 20120521  - Updated Freetype to build nicely static and dynamic in one go
 20120310  - Update to Freetype 2.4.9
 20120306  - Separate the src directories into fontconfig and freetype and temporarily remove Peters fixes in anticapation of Silvans fixes from Lucide
 20120306  - Add tag Gecko_10_Release for the revision built against Firefox 10.x etc
 20111116  - Update to Freetype 2.4.8
diff --git a/include/fontconfig/fcfreetype.h b/include/fontconfig/fcfreetype.h
new file mode 100644
--- /dev/null
+++ b/include/fontconfig/fcfreetype.h
@@ -0,0 +1,55 @@
+/*
+ * $RCSId: xc/lib/fontconfig/fontconfig/fcfreetype.h,v 1.2 2002/02/15 06:01:27 keithp Exp $
+ *
+ * Copyright © 2001 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _FCFREETYPE_H_
+#define _FCFREETYPE_H_
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+_FCFUNCPROTOBEGIN
+
+FT_UInt
+FcFreeTypeCharIndex (FT_Face face, FcChar32 ucs4);
+
+FcCharSet *
+FcFreeTypeCharSetAndSpacing (FT_Face face, FcBlanks *blanks, int *spacing);
+
+FcCharSet *
+FcFreeTypeCharSet (FT_Face face, FcBlanks *blanks);
+
+FcResult
+FcPatternGetFTFace (const FcPattern *p, const char *object, int n, FT_Face *f);
+
+FcBool
+FcPatternAddFTFace (FcPattern *p, const char *object, const FT_Face f);
+
+FcPattern *
+FcFreeTypeQueryFace (const FT_Face  face,
+                     const FcChar8  *file,
+                     int            id,
+                     FcBlanks       *blanks);
+
+_FCFUNCPROTOEND
+
+#endif
diff --git a/include/fontconfig/fcprivate.h b/include/fontconfig/fcprivate.h
new file mode 100644
--- /dev/null
+++ b/include/fontconfig/fcprivate.h
@@ -0,0 +1,123 @@
+/*
+ * $RCSId: xc/lib/fontconfig/fontconfig/fcprivate.h,v 1.5 2002/08/19 19:32:04 keithp Exp $
+ *
+ * Copyright © 2001 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _FCPRIVATE_H_
+#define _FCPRIVATE_H_
+
+/*
+ * I tried this with functions that took va_list* arguments
+ * but portability concerns made me change these functions
+ * into macros (sigh).
+ */
+
+#define FcPatternVapBuild(result, orig, va)			    \
+{								    \
+    FcPattern	*__p__ = (orig);				    \
+    const char	*__o__;						    \
+    FcValue	__v__;						    \
+								    \
+    if (!__p__)							    \
+    {								    \
+	__p__ = FcPatternCreate ();				    \
+	if (!__p__)		    				    \
+	    goto _FcPatternVapBuild_bail0;			    \
+    }				    				    \
+    for (;;)			    				    \
+    {				    				    \
+	__o__ = va_arg (va, const char *);			    \
+	if (!__o__)		    				    \
+	    break;		    				    \
+	__v__.type = va_arg (va, FcType);			    \
+	switch (__v__.type) {	    				    \
+	case FcTypeVoid:					    \
+	    goto _FcPatternVapBuild_bail1;       		    \
+	case FcTypeInteger:	    				    \
+	    __v__.u.i = va_arg (va, int);			    \
+	    break;						    \
+	case FcTypeDouble:					    \
+	    __v__.u.d = va_arg (va, double);			    \
+	    break;						    \
+	case FcTypeString:					    \
+	    __v__.u.s = va_arg (va, FcChar8 *);			    \
+	    break;						    \
+	case FcTypeBool:					    \
+	    __v__.u.b = va_arg (va, FcBool);			    \
+	    break;						    \
+	case FcTypeMatrix:					    \
+	    __v__.u.m = va_arg (va, FcMatrix *);		    \
+	    break;						    \
+	case FcTypeCharSet:					    \
+	    __v__.u.c = va_arg (va, FcCharSet *);		    \
+	    break;						    \
+	case FcTypeFTFace:					    \
+	    __v__.u.f = va_arg (va, FT_Face);			    \
+	    break;						    \
+	case FcTypeLangSet:					    \
+	    __v__.u.l = va_arg (va, FcLangSet *);		    \
+	    break;						    \
+	}							    \
+	if (!FcPatternAdd (__p__, __o__, __v__, FcTrue))	    \
+	    goto _FcPatternVapBuild_bail1;			    \
+    }								    \
+    result = __p__;						    \
+    goto _FcPatternVapBuild_return;				    \
+								    \
+_FcPatternVapBuild_bail1:					    \
+    if (!orig)							    \
+	FcPatternDestroy (__p__);				    \
+_FcPatternVapBuild_bail0:					    \
+    result = (void*)0;						    \
+								    \
+_FcPatternVapBuild_return:					    \
+    ;								    \
+}
+
+
+#define FcObjectSetVapBuild(__ret__, __first__, __va__) 		\
+{									\
+    FcObjectSet    *__os__;						\
+    const char	    *__ob__;						\
+									\
+    __ret__ = 0;						    	\
+    __os__ = FcObjectSetCreate ();					\
+    if (!__os__)							\
+	goto _FcObjectSetVapBuild_bail0;				\
+    __ob__ = __first__;							\
+    while (__ob__)							\
+    {									\
+	if (!FcObjectSetAdd (__os__, __ob__))				\
+	    goto _FcObjectSetVapBuild_bail1;				\
+	__ob__ = va_arg (__va__, const char *);				\
+    }									\
+    __ret__ = __os__;							\
+									\
+_FcObjectSetVapBuild_bail1:						\
+    if (!__ret__ && __os__)					    	\
+	FcObjectSetDestroy (__os__);					\
+_FcObjectSetVapBuild_bail0:						\
+    ;									\
+}
+
+#endif /* _FCPRIVATE_H_ */
+
diff --git a/include/fontconfig/fontconfig.h b/include/fontconfig/fontconfig.h
new file mode 100644
--- /dev/null
+++ b/include/fontconfig/fontconfig.h
@@ -0,0 +1,861 @@
+/*
+ * $RCSId: xc/lib/fontconfig/fontconfig/fontconfig.h,v 1.30 2002/09/26 00:17:27 keithp Exp $
+ *
+ * Copyright © 2001 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _FONTCONFIG_H_
+#define _FONTCONFIG_H_
+
+#include <stdarg.h>
+
+typedef unsigned char	FcChar8;
+typedef unsigned short	FcChar16;
+typedef unsigned int	FcChar32;
+typedef int		FcBool;
+
+/*
+ * Current Fontconfig version number.  This same number
+ * must appear in the fontconfig configure.in file. Yes,
+ * it'a a pain to synchronize version numbers like this.
+ */
+
+#define FC_MAJOR	2
+#define FC_MINOR	8
+#define FC_REVISION	0
+
+#define FC_VERSION	((FC_MAJOR * 10000) + (FC_MINOR * 100) + (FC_REVISION))
+
+/*
+ * Current font cache file format version
+ * This is appended to the cache files so that multiple
+ * versions of the library will peacefully coexist
+ *
+ * Change this value whenever the disk format for the cache file
+ * changes in any non-compatible way.  Try to avoid such changes as
+ * it means multiple copies of the font information.
+ */
+
+#define FC_CACHE_VERSION    "3"
+
+#define FcTrue		1
+#define FcFalse		0
+
+#define FC_FAMILY	    "family"		/* String */
+#define FC_STYLE	    "style"		/* String */
+#define FC_SLANT	    "slant"		/* Int */
+#define FC_WEIGHT	    "weight"		/* Int */
+#define FC_SIZE		    "size"		/* Double */
+#define FC_ASPECT	    "aspect"		/* Double */
+#define FC_PIXEL_SIZE	    "pixelsize"		/* Double */
+#define FC_SPACING	    "spacing"		/* Int */
+#define FC_FOUNDRY	    "foundry"		/* String */
+#define FC_ANTIALIAS	    "antialias"		/* Bool (depends) */
+#define FC_HINTING	    "hinting"		/* Bool (true) */
+#define FC_HINT_STYLE	    "hintstyle"		/* Int */
+#define FC_VERTICAL_LAYOUT  "verticallayout"	/* Bool (false) */
+#define FC_AUTOHINT	    "autohint"		/* Bool (false) */
+#define FC_GLOBAL_ADVANCE   "globaladvance"	/* Bool (true) */
+#define FC_WIDTH	    "width"		/* Int */
+#define FC_FILE		    "file"		/* String */
+#define FC_INDEX	    "index"		/* Int */
+#define FC_FT_FACE	    "ftface"		/* FT_Face */
+#define FC_RASTERIZER	    "rasterizer"	/* String */
+#define FC_OUTLINE	    "outline"		/* Bool */
+#define FC_SCALABLE	    "scalable"		/* Bool */
+#define FC_SCALE	    "scale"		/* double */
+#define FC_DPI		    "dpi"		/* double */
+#define FC_RGBA		    "rgba"		/* Int */
+#define FC_MINSPACE	    "minspace"		/* Bool use minimum line spacing */
+#define FC_SOURCE	    "source"		/* String (deprecated) */
+#define FC_CHARSET	    "charset"		/* CharSet */
+#define FC_LANG		    "lang"		/* String RFC 3066 langs */
+#define FC_FONTVERSION	    "fontversion"	/* Int from 'head' table */
+#define FC_FULLNAME	    "fullname"		/* String */
+#define FC_FAMILYLANG	    "familylang"	/* String RFC 3066 langs */
+#define FC_STYLELANG	    "stylelang"		/* String RFC 3066 langs */
+#define FC_FULLNAMELANG	    "fullnamelang"	/* String RFC 3066 langs */
+#define FC_CAPABILITY       "capability"	/* String */
+#define FC_FONTFORMAT	    "fontformat"	/* String */
+#define FC_EMBOLDEN	    "embolden"		/* Bool - true if emboldening needed*/
+#define FC_EMBEDDED_BITMAP  "embeddedbitmap"	/* Bool - true to enable embedded bitmaps */
+#define FC_DECORATIVE	    "decorative"	/* Bool - true if style is a decorative variant */
+#define FC_LCD_FILTER	    "lcdfilter"		/* Int */
+
+#define FC_CACHE_SUFFIX		    ".cache-"FC_CACHE_VERSION
+#define FC_DIR_CACHE_FILE	    "fonts.cache-"FC_CACHE_VERSION
+#define FC_USER_CACHE_FILE	    ".fonts.cache-"FC_CACHE_VERSION
+
+/* Adjust outline rasterizer */
+#define FC_CHAR_WIDTH	    "charwidth"	/* Int */
+#define FC_CHAR_HEIGHT	    "charheight"/* Int */
+#define FC_MATRIX	    "matrix"    /* FcMatrix */
+
+#define FC_WEIGHT_THIN		    0
+#define FC_WEIGHT_EXTRALIGHT	    40
+#define FC_WEIGHT_ULTRALIGHT	    FC_WEIGHT_EXTRALIGHT
+#define FC_WEIGHT_LIGHT		    50
+#define FC_WEIGHT_BOOK		    75
+#define FC_WEIGHT_REGULAR	    80
+#define FC_WEIGHT_NORMAL	    FC_WEIGHT_REGULAR
+#define FC_WEIGHT_MEDIUM	    100
+#define FC_WEIGHT_DEMIBOLD	    180
+#define FC_WEIGHT_SEMIBOLD	    FC_WEIGHT_DEMIBOLD
+#define FC_WEIGHT_BOLD		    200
+#define FC_WEIGHT_EXTRABOLD	    205
+#define FC_WEIGHT_ULTRABOLD	    FC_WEIGHT_EXTRABOLD
+#define FC_WEIGHT_BLACK		    210
+#define FC_WEIGHT_HEAVY		    FC_WEIGHT_BLACK
+#define FC_WEIGHT_EXTRABLACK	    215
+#define FC_WEIGHT_ULTRABLACK	    FC_WEIGHT_EXTRABLACK
+
+#define FC_SLANT_ROMAN		    0
+#define FC_SLANT_ITALIC		    100
+#define FC_SLANT_OBLIQUE	    110
+
+#define FC_WIDTH_ULTRACONDENSED	    50
+#define FC_WIDTH_EXTRACONDENSED	    63
+#define FC_WIDTH_CONDENSED	    75
+#define FC_WIDTH_SEMICONDENSED	    87
+#define FC_WIDTH_NORMAL		    100
+#define FC_WIDTH_SEMIEXPANDED	    113
+#define FC_WIDTH_EXPANDED	    125
+#define FC_WIDTH_EXTRAEXPANDED	    150
+#define FC_WIDTH_ULTRAEXPANDED	    200
+
+#define FC_PROPORTIONAL		    0
+#define FC_DUAL			    90
+#define FC_MONO			    100
+#define FC_CHARCELL		    110
+
+/* sub-pixel order */
+#define FC_RGBA_UNKNOWN	    0
+#define FC_RGBA_RGB	    1
+#define FC_RGBA_BGR	    2
+#define FC_RGBA_VRGB	    3
+#define FC_RGBA_VBGR	    4
+#define FC_RGBA_NONE	    5
+
+/* hinting style */
+#define FC_HINT_NONE        0
+#define FC_HINT_SLIGHT      1
+#define FC_HINT_MEDIUM      2
+#define FC_HINT_FULL        3
+
+/* LCD filter */
+#define FC_LCD_NONE	    0
+#define FC_LCD_DEFAULT	    1
+#define FC_LCD_LIGHT	    2
+#define FC_LCD_LEGACY	    3
+ 
+typedef enum _FcType {
+    FcTypeVoid, 
+    FcTypeInteger, 
+    FcTypeDouble, 
+    FcTypeString, 
+    FcTypeBool,
+    FcTypeMatrix,
+    FcTypeCharSet,
+    FcTypeFTFace,
+    FcTypeLangSet
+} FcType;
+
+typedef struct _FcMatrix {
+    double xx, xy, yx, yy;
+} FcMatrix;
+
+#define FcMatrixInit(m)	((m)->xx = (m)->yy = 1, \
+			 (m)->xy = (m)->yx = 0)
+
+/*
+ * A data structure to represent the available glyphs in a font.
+ * This is represented as a sparse boolean btree.
+ */
+
+typedef struct _FcCharSet FcCharSet;
+
+typedef struct _FcObjectType {
+    const char	*object;
+    FcType	type;
+} FcObjectType;
+
+typedef struct _FcConstant {
+    const FcChar8  *name;
+    const char	*object;
+    int		value;
+} FcConstant;
+
+typedef enum _FcResult {
+    FcResultMatch, FcResultNoMatch, FcResultTypeMismatch, FcResultNoId,
+    FcResultOutOfMemory
+} FcResult;
+
+typedef struct _FcPattern   FcPattern;
+
+typedef struct _FcLangSet   FcLangSet;
+
+typedef struct _FcValue {
+    FcType	type;
+    union {
+	const FcChar8	*s;
+	int		i;
+	FcBool		b;
+	double		d;
+	const FcMatrix	*m;
+	const FcCharSet	*c;
+	void		*f;
+	const FcPattern	*p;
+	const FcLangSet	*l;
+    } u;
+} FcValue;
+
+typedef struct _FcFontSet {
+    int		nfont;
+    int		sfont;
+    FcPattern	**fonts;
+} FcFontSet;
+
+typedef struct _FcObjectSet {
+    int		nobject;
+    int		sobject;
+    const char	**objects;
+} FcObjectSet;
+    
+typedef enum _FcMatchKind {
+    FcMatchPattern, FcMatchFont
+} FcMatchKind;
+
+typedef enum _FcLangResult {
+    FcLangEqual = 0,
+    FcLangDifferentCountry = 1,
+    FcLangDifferentTerritory = 1,
+    FcLangDifferentLang = 2
+} FcLangResult;
+
+typedef enum _FcSetName {
+    FcSetSystem = 0,
+    FcSetApplication = 1
+} FcSetName;
+
+typedef struct _FcAtomic FcAtomic;
+
+#if defined(__cplusplus) || defined(c_plusplus) /* for C++ V2.0 */
+#define _FCFUNCPROTOBEGIN extern "C" {	/* do not leave open across includes */
+#define _FCFUNCPROTOEND }
+#else
+#define _FCFUNCPROTOBEGIN
+#define _FCFUNCPROTOEND
+#endif
+
+typedef enum { FcEndianBig, FcEndianLittle } FcEndian;
+
+typedef struct _FcConfig    FcConfig;
+
+typedef struct _FcGlobalCache	FcFileCache;
+
+typedef struct _FcBlanks    FcBlanks;
+
+typedef struct _FcStrList   FcStrList;
+
+typedef struct _FcStrSet    FcStrSet;
+
+_FCFUNCPROTOBEGIN
+
+/* fcblanks.c */
+FcBlanks *
+FcBlanksCreate (void);
+
+void
+FcBlanksDestroy (FcBlanks *b);
+
+FcBool
+FcBlanksAdd (FcBlanks *b, FcChar32 ucs4);
+
+FcBool
+FcBlanksIsMember (FcBlanks *b, FcChar32 ucs4);
+
+/* fccache.c */
+
+FcBool
+FcDirCacheValid (const FcChar8 *cache_file);
+
+/* fccfg.c */
+FcChar8 *
+FcConfigHome (void);
+
+FcBool
+FcConfigEnableHome (FcBool enable);
+
+FcChar8 *
+FcConfigFilename (const FcChar8 *url);
+    
+FcConfig *
+FcConfigCreate (void);
+
+void
+FcConfigDestroy (FcConfig *config);
+
+FcBool
+FcConfigSetCurrent (FcConfig *config);
+
+FcConfig *
+FcConfigGetCurrent (void);
+
+FcBool
+FcConfigUptoDate (FcConfig *config);
+    
+FcBool
+FcConfigBuildFonts (FcConfig *config);
+
+FcStrList *
+FcConfigGetFontDirs (FcConfig   *config);
+
+FcStrList *
+FcConfigGetConfigDirs (FcConfig   *config);
+
+FcStrList *
+FcConfigGetConfigFiles (FcConfig    *config);
+
+FcChar8 *
+FcConfigGetCache (FcConfig  *config);
+
+FcBlanks *
+FcConfigGetBlanks (FcConfig *config);
+
+int
+FcConfigGetRescanInverval (FcConfig *config);
+
+FcBool
+FcConfigSetRescanInverval (FcConfig *config, int rescanInterval);
+
+FcFontSet *
+FcConfigGetFonts (FcConfig	*config,
+		  FcSetName	set);
+
+FcBool
+FcConfigAppFontAddFile (FcConfig    *config,
+			const FcChar8  *file);
+
+FcBool
+FcConfigAppFontAddDir (FcConfig	    *config,
+		       const FcChar8   *dir);
+
+void
+FcConfigAppFontClear (FcConfig	    *config);
+
+FcBool
+FcConfigSubstituteWithPat (FcConfig	*config,
+			   FcPattern	*p,
+			   FcPattern	*p_pat,
+			   FcMatchKind	kind);
+
+FcBool
+FcConfigSubstitute (FcConfig	*config,
+		    FcPattern	*p,
+		    FcMatchKind	kind);
+
+/* fccharset.c */
+FcCharSet *
+FcCharSetCreate (void);
+
+void
+FcCharSetDestroy (FcCharSet *fcs);
+
+FcBool
+FcCharSetAddChar (FcCharSet *fcs, FcChar32 ucs4);
+
+FcCharSet *
+FcCharSetCopy (FcCharSet *src);
+
+FcBool
+FcCharSetEqual (const FcCharSet *a, const FcCharSet *b);
+
+FcCharSet *
+FcCharSetIntersect (const FcCharSet *a, const FcCharSet *b);
+
+FcCharSet *
+FcCharSetUnion (const FcCharSet *a, const FcCharSet *b);
+
+FcCharSet *
+FcCharSetSubtract (const FcCharSet *a, const FcCharSet *b);
+
+FcBool
+FcCharSetHasChar (const FcCharSet *fcs, FcChar32 ucs4);
+
+FcChar32
+FcCharSetCount (const FcCharSet *a);
+
+FcChar32
+FcCharSetIntersectCount (const FcCharSet *a, const FcCharSet *b);
+
+FcChar32
+FcCharSetSubtractCount (const FcCharSet *a, const FcCharSet *b);
+
+FcBool
+FcCharSetIsSubset (const FcCharSet *a, const FcCharSet *b);
+
+#define FC_CHARSET_MAP_SIZE (256/32)
+#define FC_CHARSET_DONE	((FcChar32) -1)
+
+FcChar32
+FcCharSetFirstPage (const FcCharSet *a, 
+		    FcChar32	    map[FC_CHARSET_MAP_SIZE],
+		    FcChar32	    *next);
+
+FcChar32
+FcCharSetNextPage (const FcCharSet  *a, 
+		   FcChar32	    map[FC_CHARSET_MAP_SIZE],
+		   FcChar32	    *next);
+
+
+/* fcdbg.c */
+void
+FcValuePrint (const FcValue v);
+
+void
+FcPatternPrint (const FcPattern *p);
+
+void
+FcFontSetPrint (const FcFontSet *s);
+
+/* fcdefault.c */
+void
+FcDefaultSubstitute (FcPattern *pattern);
+
+/* fcdir.c */
+FcBool
+FcFileScan (FcFontSet	    *set,
+	    FcStrSet	    *dirs,
+	    FcFileCache	    *cache,
+	    FcBlanks	    *blanks,
+	    const FcChar8   *file,
+	    FcBool	    force);
+
+FcBool
+FcDirScan (FcFontSet	    *set,
+	   FcStrSet	    *dirs,
+	   FcFileCache	    *cache,
+	   FcBlanks	    *blanks,
+	   const FcChar8    *dir,
+	   FcBool	    force);
+
+FcBool
+FcDirSave (FcFontSet *set, FcStrSet *dirs, const FcChar8 *dir);
+
+/* fcfreetype.c */
+FcPattern *
+FcFreeTypeQuery (const FcChar8 *file, int id, FcBlanks *blanks, int *count);
+
+/* fcfs.c */
+
+FcFontSet *
+FcFontSetCreate (void);
+
+void
+FcFontSetDestroy (FcFontSet *s);
+
+FcBool
+FcFontSetAdd (FcFontSet *s, FcPattern *font);
+
+/* fcinit.c */
+FcConfig *
+FcInitLoadConfig (void);
+
+FcConfig *
+FcInitLoadConfigAndFonts (void);
+
+FcBool
+FcInit (void);
+
+void
+FcFini (void);
+
+int
+FcGetVersion (void);
+
+FcBool
+FcInitReinitialize (void);
+
+FcBool
+FcInitBringUptoDate (void);
+
+/* fclang.c */
+FcLangSet *
+FcLangSetCreate (void);
+
+void
+FcLangSetDestroy (FcLangSet *ls);
+
+FcLangSet *
+FcLangSetCopy (const FcLangSet *ls);
+
+FcBool
+FcLangSetAdd (FcLangSet *ls, const FcChar8 *lang);
+
+FcLangResult
+FcLangSetHasLang (const FcLangSet *ls, const FcChar8 *lang);
+
+FcLangResult
+FcLangSetCompare (const FcLangSet *lsa, const FcLangSet *lsb);
+
+FcBool
+FcLangSetContains (const FcLangSet *lsa, const FcLangSet *lsb);
+
+FcBool
+FcLangSetEqual (const FcLangSet *lsa, const FcLangSet *lsb);
+
+FcChar32
+FcLangSetHash (const FcLangSet *ls);
+
+/* fclist.c */
+FcObjectSet *
+FcObjectSetCreate (void);
+
+FcBool
+FcObjectSetAdd (FcObjectSet *os, const char *object);
+
+void
+FcObjectSetDestroy (FcObjectSet *os);
+
+FcObjectSet *
+FcObjectSetVaBuild (const char *first, va_list va);
+
+FcObjectSet *
+FcObjectSetBuild (const char *first, ...);
+
+FcFontSet *
+FcFontSetList (FcConfig	    *config,
+	       FcFontSet    **sets,
+	       int	    nsets,
+	       FcPattern    *p,
+	       FcObjectSet  *os);
+
+FcFontSet *
+FcFontList (FcConfig	*config,
+	    FcPattern	*p,
+	    FcObjectSet *os);
+
+/* fcatomic.c */
+
+FcAtomic *
+FcAtomicCreate (const FcChar8   *file);
+
+FcBool
+FcAtomicLock (FcAtomic *atomic);
+
+FcChar8 *
+FcAtomicNewFile (FcAtomic *atomic);
+
+FcChar8 *
+FcAtomicOrigFile (FcAtomic *atomic);
+
+FcBool
+FcAtomicReplaceOrig (FcAtomic *atomic);
+
+void
+FcAtomicDeleteNew (FcAtomic *atomic);
+
+void
+FcAtomicUnlock (FcAtomic *atomic);
+
+void
+FcAtomicDestroy (FcAtomic *atomic);
+
+/* fcmatch.c */
+FcPattern *
+FcFontSetMatch (FcConfig    *config,
+		FcFontSet   **sets,
+		int	    nsets,
+		FcPattern   *p,
+		FcResult    *result);
+
+FcPattern *
+FcFontMatch (FcConfig	*config,
+	     FcPattern	*p, 
+	     FcResult	*result);
+
+FcPattern *
+FcFontRenderPrepare (FcConfig	    *config,
+		     FcPattern	    *pat,
+		     FcPattern	    *font);
+
+FcFontSet *
+FcFontSetSort (FcConfig	    *config,
+	       FcFontSet    **sets,
+	       int	    nsets,
+	       FcPattern    *p,
+	       FcBool	    trim,
+	       FcCharSet    **csp,
+	       FcResult	    *result);
+
+FcFontSet *
+FcFontSort (FcConfig	 *config,
+	    FcPattern    *p,
+	    FcBool	 trim,
+	    FcCharSet    **csp,
+	    FcResult	 *result);
+
+void
+FcFontSetSortDestroy (FcFontSet *fs);
+
+/* fcmatrix.c */
+FcMatrix *
+FcMatrixCopy (const FcMatrix *mat);
+
+FcBool
+FcMatrixEqual (const FcMatrix *mat1, const FcMatrix *mat2);
+
+void
+FcMatrixMultiply (FcMatrix *result, const FcMatrix *a, const FcMatrix *b);
+
+void
+FcMatrixRotate (FcMatrix *m, double c, double s);
+
+void
+FcMatrixScale (FcMatrix *m, double sx, double sy);
+
+void
+FcMatrixShear (FcMatrix *m, double sh, double sv);
+
+/* fcname.c */
+
+FcBool
+FcNameRegisterObjectTypes (const FcObjectType *types, int ntype);
+
+FcBool
+FcNameUnregisterObjectTypes (const FcObjectType *types, int ntype);
+    
+const FcObjectType *
+FcNameGetObjectType (const char *object);
+
+FcBool
+FcNameRegisterConstants (const FcConstant *consts, int nconsts);
+
+FcBool
+FcNameUnregisterConstants (const FcConstant *consts, int nconsts);
+    
+const FcConstant *
+FcNameGetConstant (FcChar8 *string);
+
+FcBool
+FcNameConstant (FcChar8 *string, int *result);
+
+FcPattern *
+FcNameParse (const FcChar8 *name);
+
+FcChar8 *
+FcNameUnparse (FcPattern *pat);
+
+/* fcpat.c */
+FcPattern *
+FcPatternCreate (void);
+
+FcPattern *
+FcPatternDuplicate (const FcPattern *p);
+
+void
+FcPatternReference (FcPattern *p);
+
+void
+FcValueDestroy (FcValue v);
+
+FcBool
+FcValueEqual (FcValue va, FcValue vb);
+
+FcValue
+FcValueSave (FcValue v);
+
+void
+FcPatternDestroy (FcPattern *p);
+
+FcBool
+FcPatternEqual (const FcPattern *pa, const FcPattern *pb);
+
+FcBool
+FcPatternEqualSubset (const FcPattern *pa, const FcPattern *pb, const FcObjectSet *os);
+
+FcChar32
+FcPatternHash (const FcPattern *p);
+
+FcBool
+FcPatternAdd (FcPattern *p, const char *object, FcValue value, FcBool append);
+    
+FcBool
+FcPatternAddWeak (FcPattern *p, const char *object, FcValue value, FcBool append);
+    
+FcResult
+FcPatternGet (const FcPattern *p, const char *object, int id, FcValue *v);
+    
+FcBool
+FcPatternDel (FcPattern *p, const char *object);
+
+FcBool
+FcPatternRemove (FcPattern *p, const char *object, int id);
+
+FcBool
+FcPatternAddInteger (FcPattern *p, const char *object, int i);
+
+FcBool
+FcPatternAddDouble (FcPattern *p, const char *object, double d);
+
+FcBool
+FcPatternAddString (FcPattern *p, const char *object, const FcChar8 *s);
+
+FcBool
+FcPatternAddMatrix (FcPattern *p, const char *object, const FcMatrix *s);
+
+FcBool
+FcPatternAddCharSet (FcPattern *p, const char *object, const FcCharSet *c);
+
+FcBool
+FcPatternAddBool (FcPattern *p, const char *object, FcBool b);
+
+FcBool
+FcPatternAddLangSet (FcPattern *p, const char *object, const FcLangSet *ls);
+
+FcResult
+FcPatternGetInteger (const FcPattern *p, const char *object, int n, int *i);
+
+FcResult
+FcPatternGetDouble (const FcPattern *p, const char *object, int n, double *d);
+
+FcResult
+FcPatternGetString (const FcPattern *p, const char *object, int n, FcChar8 ** s);
+
+FcResult
+FcPatternGetMatrix (const FcPattern *p, const char *object, int n, FcMatrix **s);
+
+FcResult
+FcPatternGetCharSet (const FcPattern *p, const char *object, int n, FcCharSet **c);
+
+FcResult
+FcPatternGetBool (const FcPattern *p, const char *object, int n, FcBool *b);
+
+FcResult
+FcPatternGetLangSet (const FcPattern *p, const char *object, int n, FcLangSet **ls);
+
+FcPattern *
+FcPatternVaBuild (FcPattern *orig, va_list va);
+    
+FcPattern *
+FcPatternBuild (FcPattern *orig, ...);
+
+/* fcstr.c */
+
+FcChar8 *
+FcStrCopy (const FcChar8 *s);
+
+FcChar8 *
+FcStrCopyFilename (const FcChar8 *s);
+    
+/* These are ASCII only, suitable only for pattern element names */
+#define FcIsUpper(c)	((0101 <= (c) && (c) <= 0132))
+#define FcIsLower(c)	((0141 <= (c) && (c) <= 0172))
+#define FcToLower(c)	(FcIsUpper(c) ? (c) - 0101 + 0141 : (c))
+
+FcChar8 *
+FcStrDowncase (const FcChar8 *s);
+
+int
+FcStrCmpIgnoreCase (const FcChar8 *s1, const FcChar8 *s2);
+
+int
+FcStrCmp (const FcChar8 *s1, const FcChar8 *s2);
+
+const FcChar8 *
+FcStrStrIgnoreCase (const FcChar8 *s1, const FcChar8 *s2);
+
+const FcChar8 *
+FcStrStr (const FcChar8 *s1, const FcChar8 *s2);
+
+int
+FcUtf8ToUcs4 (const FcChar8 *src_orig,
+	      FcChar32	    *dst,
+	      int	    len);
+
+FcBool
+FcUtf8Len (const FcChar8    *string,
+	   int		    len,
+	   int		    *nchar,
+	   int		    *wchar);
+
+#define FC_UTF8_MAX_LEN	6
+
+int
+FcUcs4ToUtf8 (FcChar32	ucs4,
+	      FcChar8	dest[FC_UTF8_MAX_LEN]);
+
+int
+FcUtf16ToUcs4 (const FcChar8	*src_orig,
+	       FcEndian		endian,
+	       FcChar32		*dst,
+	       int		len);	    /* in bytes */
+
+FcBool
+FcUtf16Len (const FcChar8   *string,
+	    FcEndian	    endian,
+	    int		    len,	    /* in bytes */
+	    int		    *nchar,
+	    int		    *wchar);
+
+FcChar8 *
+FcStrDirname (const FcChar8 *file);
+
+FcChar8 *
+FcStrBasename (const FcChar8 *file);
+
+FcStrSet *
+FcStrSetCreate (void);
+
+FcBool
+FcStrSetMember (FcStrSet *set, const FcChar8 *s);
+
+FcBool
+FcStrSetEqual (FcStrSet *sa, FcStrSet *sb);
+
+FcBool
+FcStrSetAdd (FcStrSet *set, const FcChar8 *s);
+
+FcBool
+FcStrSetAddFilename (FcStrSet *set, const FcChar8 *s);
+
+FcBool
+FcStrSetDel (FcStrSet *set, const FcChar8 *s);
+
+void
+FcStrSetDestroy (FcStrSet *set);
+
+FcStrList *
+FcStrListCreate (FcStrSet *set);
+
+FcChar8 *
+FcStrListNext (FcStrList *list);
+
+void
+FcStrListDone (FcStrList *list);
+
+/* fcxml.c */
+FcBool
+FcConfigParseAndLoad (FcConfig *config, const FcChar8 *file, FcBool complain);
+
+_FCFUNCPROTOEND
+
+#endif /* _FONTCONFIG_H_ */
diff --git a/include/freetype/config/ftconfig.h b/include/freetype/config/ftconfig.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/config/ftconfig.h
@@ -0,0 +1,564 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftconfig.h                                                             */
+/*                                                                         */
+/*    ANSI-specific configuration file (specification only).               */
+/*                                                                         */
+/*  Copyright 1996-2004, 2006-2008, 2010-2011 by                           */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This header file contains a number of macro definitions that are used */
+  /* by the rest of the engine.  Most of the macros here are automatically */
+  /* determined at compile time, and you should not need to change it to   */
+  /* port FreeType, except to compile the library with a non-ANSI          */
+  /* compiler.                                                             */
+  /*                                                                       */
+  /* Note however that if some specific modifications are needed, we       */
+  /* advise you to place a modified copy in your build directory.          */
+  /*                                                                       */
+  /* The build directory is usually `freetype/builds/<system>', and        */
+  /* contains system-specific files that are always included first when    */
+  /* building the library.                                                 */
+  /*                                                                       */
+  /* This ANSI version should stay in `include/freetype/config'.           */
+  /*                                                                       */
+  /*************************************************************************/
+
+#ifndef __FTCONFIG_H__
+#define __FTCONFIG_H__
+
+#include <ft2build.h>
+#include FT_CONFIG_OPTIONS_H
+#include FT_CONFIG_STANDARD_LIBRARY_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*               PLATFORM-SPECIFIC CONFIGURATION MACROS                  */
+  /*                                                                       */
+  /* These macros can be toggled to suit a specific system.  The current   */
+  /* ones are defaults used to compile FreeType in an ANSI C environment   */
+  /* (16bit compilers are also supported).  Copy this file to your own     */
+  /* `freetype/builds/<system>' directory, and edit it to port the engine. */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* There are systems (like the Texas Instruments 'C54x) where a `char' */
+  /* has 16 bits.  ANSI C says that sizeof(char) is always 1.  Since an  */
+  /* `int' has 16 bits also for this system, sizeof(int) gives 1 which   */
+  /* is probably unexpected.                                             */
+  /*                                                                     */
+  /* `CHAR_BIT' (defined in limits.h) gives the number of bits in a      */
+  /* `char' type.                                                        */
+
+#ifndef FT_CHAR_BIT
+#define FT_CHAR_BIT  CHAR_BIT
+#endif
+
+
+  /* The size of an `int' type.  */
+#if                                 FT_UINT_MAX == 0xFFFFUL
+#define FT_SIZEOF_INT  (16 / FT_CHAR_BIT)
+#elif                               FT_UINT_MAX == 0xFFFFFFFFUL
+#define FT_SIZEOF_INT  (32 / FT_CHAR_BIT)
+#elif FT_UINT_MAX > 0xFFFFFFFFUL && FT_UINT_MAX == 0xFFFFFFFFFFFFFFFFUL
+#define FT_SIZEOF_INT  (64 / FT_CHAR_BIT)
+#else
+#error "Unsupported size of `int' type!"
+#endif
+
+  /* The size of a `long' type.  A five-byte `long' (as used e.g. on the */
+  /* DM642) is recognized but avoided.                                   */
+#if                                  FT_ULONG_MAX == 0xFFFFFFFFUL
+#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
+#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFUL
+#define FT_SIZEOF_LONG  (32 / FT_CHAR_BIT)
+#elif FT_ULONG_MAX > 0xFFFFFFFFUL && FT_ULONG_MAX == 0xFFFFFFFFFFFFFFFFUL
+#define FT_SIZEOF_LONG  (64 / FT_CHAR_BIT)
+#else
+#error "Unsupported size of `long' type!"
+#endif
+
+
+  /* FT_UNUSED is a macro used to indicate that a given parameter is not  */
+  /* used -- this is only used to get rid of unpleasant compiler warnings */
+#ifndef FT_UNUSED
+#define FT_UNUSED( arg )  ( (arg) = (arg) )
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                     AUTOMATIC CONFIGURATION MACROS                    */
+  /*                                                                       */
+  /* These macros are computed from the ones defined above.  Don't touch   */
+  /* their definition, unless you know precisely what you are doing.  No   */
+  /* porter should need to mess with them.                                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Mac support                                                           */
+  /*                                                                       */
+  /*   This is the only necessary change, so it is defined here instead    */
+  /*   providing a new configuration file.                                 */
+  /*                                                                       */
+#if defined( __APPLE__ ) || ( defined( __MWERKS__ ) && defined( macintosh ) )
+  /* no Carbon frameworks for 64bit 10.4.x */
+  /* AvailabilityMacros.h is available since Mac OS X 10.2,        */
+  /* so guess the system version by maximum errno before inclusion */
+#include <errno.h>
+#ifdef ECANCELED /* defined since 10.2 */
+#include "AvailabilityMacros.h"
+#endif
+#if defined( __LP64__ ) && \
+    ( MAC_OS_X_VERSION_MIN_REQUIRED <= MAC_OS_X_VERSION_10_4 )
+#undef FT_MACINTOSH
+#endif
+
+#elif defined( __SC__ ) || defined( __MRC__ )
+  /* Classic MacOS compilers */
+#include "ConditionalMacros.h"
+#if TARGET_OS_MAC
+#define FT_MACINTOSH 1
+#endif
+
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    basic_types                                                        */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Int16                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for a 16bit signed integer type.                         */
+  /*                                                                       */
+  typedef signed short  FT_Int16;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_UInt16                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for a 16bit unsigned integer type.                       */
+  /*                                                                       */
+  typedef unsigned short  FT_UInt16;
+
+  /* */
+
+
+  /* this #if 0 ... #endif clause is for documentation purposes */
+#if 0
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Int32                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for a 32bit signed integer type.  The size depends on    */
+  /*    the configuration.                                                 */
+  /*                                                                       */
+  typedef signed XXX  FT_Int32;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_UInt32                                                          */
+  /*                                                                       */
+  /*    A typedef for a 32bit unsigned integer type.  The size depends on  */
+  /*    the configuration.                                                 */
+  /*                                                                       */
+  typedef unsigned XXX  FT_UInt32;
+
+  /* */
+
+#endif
+
+#if FT_SIZEOF_INT == (32 / FT_CHAR_BIT)
+
+  typedef signed int      FT_Int32;
+  typedef unsigned int    FT_UInt32;
+
+#elif FT_SIZEOF_LONG == (32 / FT_CHAR_BIT)
+
+  typedef signed long     FT_Int32;
+  typedef unsigned long   FT_UInt32;
+
+#else
+#error "no 32bit type found -- please check your configuration files"
+#endif
+
+
+  /* look up an integer type that is at least 32 bits */
+#if FT_SIZEOF_INT >= (32 / FT_CHAR_BIT)
+
+  typedef int            FT_Fast;
+  typedef unsigned int   FT_UFast;
+
+#elif FT_SIZEOF_LONG >= (32 / FT_CHAR_BIT)
+
+  typedef long           FT_Fast;
+  typedef unsigned long  FT_UFast;
+
+#endif
+
+
+  /* determine whether we have a 64-bit int type for platforms without */
+  /* Autoconf                                                          */
+#if FT_SIZEOF_LONG == (64 / FT_CHAR_BIT)
+
+  /* FT_LONG64 must be defined if a 64-bit type is available */
+#define FT_LONG64
+#define FT_INT64  long
+
+#elif defined( _MSC_VER ) && _MSC_VER >= 900  /* Visual C++ (and Intel C++) */
+
+  /* this compiler provides the __int64 type */
+#define FT_LONG64
+#define FT_INT64  __int64
+
+#elif defined( __BORLANDC__ )  /* Borland C++ */
+
+  /* XXXX: We should probably check the value of __BORLANDC__ in order */
+  /*       to test the compiler version.                               */
+
+  /* this compiler provides the __int64 type */
+#define FT_LONG64
+#define FT_INT64  __int64
+
+#elif defined( __WATCOMC__ )   /* Watcom C++ */
+
+  /* Watcom doesn't provide 64-bit data types */
+
+#elif defined( __MWERKS__ )    /* Metrowerks CodeWarrior */
+
+#define FT_LONG64
+#define FT_INT64  long long int
+
+#elif defined( __GNUC__ )
+
+  /* GCC provides the `long long' type */
+#define FT_LONG64
+#define FT_INT64  long long int
+
+#endif /* FT_SIZEOF_LONG == (64 / FT_CHAR_BIT) */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* A 64-bit data type will create compilation problems if you compile    */
+  /* in strict ANSI mode.  To avoid them, we disable its use if __STDC__   */
+  /* is defined.  You can however ignore this rule by defining the         */
+  /* FT_CONFIG_OPTION_FORCE_INT64 configuration macro.                     */
+  /*                                                                       */
+#if defined( FT_LONG64 ) && !defined( FT_CONFIG_OPTION_FORCE_INT64 )
+
+#ifdef __STDC__
+
+  /* undefine the 64-bit macros in strict ANSI compilation mode */
+#undef FT_LONG64
+#undef FT_INT64
+
+#endif /* __STDC__ */
+
+#endif /* FT_LONG64 && !FT_CONFIG_OPTION_FORCE_INT64 */
+
+
+#define FT_BEGIN_STMNT  do {
+#define FT_END_STMNT    } while ( 0 )
+#define FT_DUMMY_STMNT  FT_BEGIN_STMNT FT_END_STMNT
+
+
+#ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
+  /* Provide assembler fragments for performance-critical functions. */
+  /* These must be defined `static __inline__' with GCC.             */
+
+#if defined( __CC_ARM ) || defined( __ARMCC__ )  /* RVCT */
+#define FT_MULFIX_ASSEMBLER  FT_MulFix_arm
+
+  /* documentation is in freetype.h */
+
+  static __inline FT_Int32
+  FT_MulFix_arm( FT_Int32  a,
+                 FT_Int32  b )
+  {
+    register FT_Int32  t, t2;
+
+
+    __asm
+    {
+      smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */
+      mov   a,  t,  asr #31         /* a   = (hi >> 31) */
+      add   a,  a,  #0x8000         /* a  += 0x8000 */
+      adds  t2, t2, a               /* t2 += a */
+      adc   t,  t,  #0              /* t  += carry */
+      mov   a,  t2, lsr #16         /* a   = t2 >> 16 */
+      orr   a,  a,  t,  lsl #16     /* a  |= t << 16 */
+    }
+    return a;
+  }
+
+#endif /* __CC_ARM || __ARMCC__ */
+
+
+#ifdef __GNUC__
+
+#if defined( __arm__ ) && !defined( __thumb__ )    && \
+    !( defined( __CC_ARM ) || defined( __ARMCC__ ) )
+#define FT_MULFIX_ASSEMBLER  FT_MulFix_arm
+
+  /* documentation is in freetype.h */
+
+  static __inline__ FT_Int32
+  FT_MulFix_arm( FT_Int32  a,
+                 FT_Int32  b )
+  {
+    register FT_Int32  t, t2;
+
+
+    __asm__ __volatile__ (
+      "smull  %1, %2, %4, %3\n\t"       /* (lo=%1,hi=%2) = a*b */
+      "mov    %0, %2, asr #31\n\t"      /* %0  = (hi >> 31) */
+      "add    %0, %0, #0x8000\n\t"      /* %0 += 0x8000 */
+      "adds   %1, %1, %0\n\t"           /* %1 += %0 */
+      "adc    %2, %2, #0\n\t"           /* %2 += carry */
+      "mov    %0, %1, lsr #16\n\t"      /* %0  = %1 >> 16 */
+      "orr    %0, %0, %2, lsl #16\n\t"  /* %0 |= %2 << 16 */
+      : "=r"(a), "=&r"(t2), "=&r"(t)
+      : "r"(a), "r"(b)
+      : "cc" );
+    return a;
+  }
+
+#endif /* __arm__ && !__thumb__ && !( __CC_ARM || __ARMCC__ ) */
+
+#if defined( __i386__ )
+#define FT_MULFIX_ASSEMBLER  FT_MulFix_i386
+
+  /* documentation is in freetype.h */
+
+  static __inline__ FT_Int32
+  FT_MulFix_i386( FT_Int32  a,
+                  FT_Int32  b )
+  {
+    register FT_Int32  result;
+
+
+    __asm__ __volatile__ (
+      "imul  %%edx\n"
+      "movl  %%edx, %%ecx\n"
+      "sarl  $31, %%ecx\n"
+      "addl  $0x8000, %%ecx\n"
+      "addl  %%ecx, %%eax\n"
+      "adcl  $0, %%edx\n"
+      "shrl  $16, %%eax\n"
+      "shll  $16, %%edx\n"
+      "addl  %%edx, %%eax\n"
+      : "=a"(result), "=d"(b)
+      : "a"(a), "d"(b)
+      : "%ecx", "cc" );
+    return result;
+  }
+
+#endif /* i386 */
+
+#endif /* __GNUC__ */
+
+
+#ifdef _MSC_VER /* Visual C++ */
+
+#ifdef _M_IX86
+
+#define FT_MULFIX_ASSEMBLER  FT_MulFix_i386
+
+  /* documentation is in freetype.h */
+
+  static __inline FT_Int32
+  FT_MulFix_i386( FT_Int32  a,
+                  FT_Int32  b )
+  {
+    register FT_Int32  result;
+
+    __asm
+    {
+      mov eax, a
+      mov edx, b
+      imul edx
+      mov ecx, edx
+      sar ecx, 31
+      add ecx, 8000h
+      add eax, ecx
+      adc edx, 0
+      shr eax, 16
+      shl edx, 16
+      add eax, edx
+      mov result, eax
+    }
+    return result;
+  }
+
+#endif /* _M_IX86 */
+
+#endif /* _MSC_VER */
+
+#endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
+
+
+#ifdef FT_CONFIG_OPTION_INLINE_MULFIX
+#ifdef FT_MULFIX_ASSEMBLER
+#define FT_MULFIX_INLINED  FT_MULFIX_ASSEMBLER
+#endif
+#endif
+
+
+#ifdef FT_MAKE_OPTION_SINGLE_OBJECT
+
+#define FT_LOCAL( x )      static  x
+#define FT_LOCAL_DEF( x )  static  x
+
+#else
+
+#ifdef __cplusplus
+#define FT_LOCAL( x )      extern "C"  x
+#define FT_LOCAL_DEF( x )  extern "C"  x
+#else
+#define FT_LOCAL( x )      extern  x
+#define FT_LOCAL_DEF( x )  x
+#endif
+
+#endif /* FT_MAKE_OPTION_SINGLE_OBJECT */
+
+
+#ifndef FT_BASE
+
+#ifdef __cplusplus
+#define FT_BASE( x )  extern "C"  x
+#else
+#define FT_BASE( x )  extern  x
+#endif
+
+#endif /* !FT_BASE */
+
+
+#ifndef FT_BASE_DEF
+
+#ifdef __cplusplus
+#define FT_BASE_DEF( x )  x
+#else
+#define FT_BASE_DEF( x )  x
+#endif
+
+#endif /* !FT_BASE_DEF */
+
+
+#ifndef FT_EXPORT
+
+#ifdef __cplusplus
+#define FT_EXPORT( x )  extern "C"  x
+#else
+#define FT_EXPORT( x )  extern  x
+#endif
+
+#endif /* !FT_EXPORT */
+
+
+#ifndef FT_EXPORT_DEF
+
+#ifdef __cplusplus
+#define FT_EXPORT_DEF( x )  extern "C"  x
+#else
+#define FT_EXPORT_DEF( x )  extern  x
+#endif
+
+#endif /* !FT_EXPORT_DEF */
+
+
+#ifndef FT_EXPORT_VAR
+
+#ifdef __cplusplus
+#define FT_EXPORT_VAR( x )  extern "C"  x
+#else
+#define FT_EXPORT_VAR( x )  extern  x
+#endif
+
+#endif /* !FT_EXPORT_VAR */
+
+  /* The following macros are needed to compile the library with a   */
+  /* C++ compiler and with 16bit compilers.                          */
+  /*                                                                 */
+
+  /* This is special.  Within C++, you must specify `extern "C"' for */
+  /* functions which are used via function pointers, and you also    */
+  /* must do that for structures which contain function pointers to  */
+  /* assure C linkage -- it's not possible to have (local) anonymous */
+  /* functions which are accessed by (global) function pointers.     */
+  /*                                                                 */
+  /*                                                                 */
+  /* FT_CALLBACK_DEF is used to _define_ a callback function.        */
+  /*                                                                 */
+  /* FT_CALLBACK_TABLE is used to _declare_ a constant variable that */
+  /* contains pointers to callback functions.                        */
+  /*                                                                 */
+  /* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   */
+  /* that contains pointers to callback functions.                   */
+  /*                                                                 */
+  /*                                                                 */
+  /* Some 16bit compilers have to redefine these macros to insert    */
+  /* the infamous `_cdecl' or `__fastcall' declarations.             */
+  /*                                                                 */
+#ifndef FT_CALLBACK_DEF
+#ifdef __cplusplus
+#define FT_CALLBACK_DEF( x )  extern "C"  x
+#else
+#define FT_CALLBACK_DEF( x )  static  x
+#endif
+#endif /* FT_CALLBACK_DEF */
+
+#ifndef FT_CALLBACK_TABLE
+#ifdef __cplusplus
+#define FT_CALLBACK_TABLE      extern "C"
+#define FT_CALLBACK_TABLE_DEF  extern "C"
+#else
+#define FT_CALLBACK_TABLE      extern
+#define FT_CALLBACK_TABLE_DEF  /* nothing */
+#endif
+#endif /* FT_CALLBACK_TABLE */
+
+
+FT_END_HEADER
+
+
+#endif /* __FTCONFIG_H__ */
+
+
+/* END */
diff --git a/include/freetype/config/ftheader.h b/include/freetype/config/ftheader.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/config/ftheader.h
@@ -0,0 +1,806 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftheader.h                                                             */
+/*                                                                         */
+/*    Build macros of the FreeType 2 library.                              */
+/*                                                                         */
+/*  Copyright 1996-2008, 2010, 2012 by                                     */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+#ifndef __FT_HEADER_H__
+#define __FT_HEADER_H__
+
+
+  /*@***********************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_BEGIN_HEADER                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This macro is used in association with @FT_END_HEADER in header    */
+  /*    files to ensure that the declarations within are properly          */
+  /*    encapsulated in an `extern "C" { .. }' block when included from a  */
+  /*    C++ compiler.                                                      */
+  /*                                                                       */
+#ifdef __cplusplus
+#define FT_BEGIN_HEADER  extern "C" {
+#else
+#define FT_BEGIN_HEADER  /* nothing */
+#endif
+
+
+  /*@***********************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_END_HEADER                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This macro is used in association with @FT_BEGIN_HEADER in header  */
+  /*    files to ensure that the declarations within are properly          */
+  /*    encapsulated in an `extern "C" { .. }' block when included from a  */
+  /*    C++ compiler.                                                      */
+  /*                                                                       */
+#ifdef __cplusplus
+#define FT_END_HEADER  }
+#else
+#define FT_END_HEADER  /* nothing */
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Aliases for the FreeType 2 public and configuration files.            */
+  /*                                                                       */
+  /*************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    header_file_macros                                                 */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Header File Macros                                                 */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Macro definitions used to #include specific header files.          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The following macros are defined to the name of specific           */
+  /*    FreeType~2 header files.  They can be used directly in #include    */
+  /*    statements as in:                                                  */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      #include FT_FREETYPE_H                                           */
+  /*      #include FT_MULTIPLE_MASTERS_H                                   */
+  /*      #include FT_GLYPH_H                                              */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    There are several reasons why we are now using macros to name      */
+  /*    public header files.  The first one is that such macros are not    */
+  /*    limited to the infamous 8.3~naming rule required by DOS (and       */
+  /*    `FT_MULTIPLE_MASTERS_H' is a lot more meaningful than `ftmm.h').   */
+  /*                                                                       */
+  /*    The second reason is that it allows for more flexibility in the    */
+  /*    way FreeType~2 is installed on a given system.                     */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* configuration files */
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CONFIG_CONFIG_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing
+   *   FreeType~2 configuration data.
+   *
+   */
+#ifndef FT_CONFIG_CONFIG_H
+#define FT_CONFIG_CONFIG_H  <freetype/config/ftconfig.h>
+#endif
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CONFIG_STANDARD_LIBRARY_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing
+   *   FreeType~2 interface to the standard C library functions.
+   *
+   */
+#ifndef FT_CONFIG_STANDARD_LIBRARY_H
+#define FT_CONFIG_STANDARD_LIBRARY_H  <freetype/config/ftstdlib.h>
+#endif
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CONFIG_OPTIONS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing
+   *   FreeType~2 project-specific configuration options.
+   *
+   */
+#ifndef FT_CONFIG_OPTIONS_H
+#define FT_CONFIG_OPTIONS_H  <freetype/config/ftoption.h>
+#endif
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CONFIG_MODULES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   list of FreeType~2 modules that are statically linked to new library
+   *   instances in @FT_Init_FreeType.
+   *
+   */
+#ifndef FT_CONFIG_MODULES_H
+#define FT_CONFIG_MODULES_H  <freetype/config/ftmodule.h>
+#endif
+
+  /* */
+
+  /* public headers */
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_FREETYPE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   base FreeType~2 API.
+   *
+   */
+#define FT_FREETYPE_H  <freetype/freetype.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_ERRORS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   list of FreeType~2 error codes (and messages).
+   *
+   *   It is included by @FT_FREETYPE_H.
+   *
+   */
+#define FT_ERRORS_H  <freetype/fterrors.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_MODULE_ERRORS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   list of FreeType~2 module error offsets (and messages).
+   *
+   */
+#define FT_MODULE_ERRORS_H  <freetype/ftmoderr.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_SYSTEM_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 interface to low-level operations (i.e., memory management
+   *   and stream i/o).
+   *
+   *   It is included by @FT_FREETYPE_H.
+   *
+   */
+#define FT_SYSTEM_H  <freetype/ftsystem.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_IMAGE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing type
+   *   definitions related to glyph images (i.e., bitmaps, outlines,
+   *   scan-converter parameters).
+   *
+   *   It is included by @FT_FREETYPE_H.
+   *
+   */
+#define FT_IMAGE_H  <freetype/ftimage.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_TYPES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   basic data types defined by FreeType~2.
+   *
+   *   It is included by @FT_FREETYPE_H.
+   *
+   */
+#define FT_TYPES_H  <freetype/fttypes.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_LIST_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   list management API of FreeType~2.
+   *
+   *   (Most applications will never need to include this file.)
+   *
+   */
+#define FT_LIST_H  <freetype/ftlist.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_OUTLINE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   scalable outline management API of FreeType~2.
+   *
+   */
+#define FT_OUTLINE_H  <freetype/ftoutln.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_SIZES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   API which manages multiple @FT_Size objects per face.
+   *
+   */
+#define FT_SIZES_H  <freetype/ftsizes.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_MODULE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   module management API of FreeType~2.
+   *
+   */
+#define FT_MODULE_H  <freetype/ftmodapi.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_RENDER_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   renderer module management API of FreeType~2.
+   *
+   */
+#define FT_RENDER_H  <freetype/ftrender.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_AUTOHINTER_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing
+   *   structures and macros related to the auto-hinting module.
+   *
+   */
+#define FT_AUTOHINTER_H  <freetype/ftautoh.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_TYPE1_TABLES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   types and API specific to the Type~1 format.
+   *
+   */
+#define FT_TYPE1_TABLES_H  <freetype/t1tables.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_TRUETYPE_IDS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   enumeration values which identify name strings, languages, encodings,
+   *   etc.  This file really contains a _large_ set of constant macro
+   *   definitions, taken from the TrueType and OpenType specifications.
+   *
+   */
+#define FT_TRUETYPE_IDS_H  <freetype/ttnameid.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_TRUETYPE_TABLES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   types and API specific to the TrueType (as well as OpenType) format.
+   *
+   */
+#define FT_TRUETYPE_TABLES_H  <freetype/tttables.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_TRUETYPE_TAGS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of TrueType four-byte `tags' which identify blocks in
+   *   SFNT-based font formats (i.e., TrueType and OpenType).
+   *
+   */
+#define FT_TRUETYPE_TAGS_H  <freetype/tttags.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_BDF_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of an API which accesses BDF-specific strings from a
+   *   face.
+   *
+   */
+#define FT_BDF_H  <freetype/ftbdf.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CID_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of an API which access CID font information from a
+   *   face.
+   *
+   */
+#define FT_CID_H  <freetype/ftcid.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_GZIP_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of an API which supports gzip-compressed files.
+   *
+   */
+#define FT_GZIP_H  <freetype/ftgzip.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_LZW_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of an API which supports LZW-compressed files.
+   *
+   */
+#define FT_LZW_H  <freetype/ftlzw.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_BZIP2_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of an API which supports bzip2-compressed files.
+   *
+   */
+#define FT_BZIP2_H  <freetype/ftbzip2.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_WINFONTS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   definitions of an API which supports Windows FNT files.
+   *
+   */
+#define FT_WINFONTS_H   <freetype/ftwinfnt.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_GLYPH_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   API of the optional glyph management component.
+   *
+   */
+#define FT_GLYPH_H  <freetype/ftglyph.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_BITMAP_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   API of the optional bitmap conversion component.
+   *
+   */
+#define FT_BITMAP_H  <freetype/ftbitmap.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_BBOX_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   API of the optional exact bounding box computation routines.
+   *
+   */
+#define FT_BBOX_H  <freetype/ftbbox.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CACHE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   API of the optional FreeType~2 cache sub-system.
+   *
+   */
+#define FT_CACHE_H  <freetype/ftcache.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CACHE_IMAGE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   `glyph image' API of the FreeType~2 cache sub-system.
+   *
+   *   It is used to define a cache for @FT_Glyph elements.  You can also
+   *   use the API defined in @FT_CACHE_SMALL_BITMAPS_H if you only need to
+   *   store small glyph bitmaps, as it will use less memory.
+   *
+   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
+   *   glyph image-related cache declarations.
+   *
+   */
+#define FT_CACHE_IMAGE_H  FT_CACHE_H
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CACHE_SMALL_BITMAPS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   `small bitmaps' API of the FreeType~2 cache sub-system.
+   *
+   *   It is used to define a cache for small glyph bitmaps in a relatively
+   *   memory-efficient way.  You can also use the API defined in
+   *   @FT_CACHE_IMAGE_H if you want to cache arbitrary glyph images,
+   *   including scalable outlines.
+   *
+   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
+   *   small bitmaps-related cache declarations.
+   *
+   */
+#define FT_CACHE_SMALL_BITMAPS_H  FT_CACHE_H
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_CACHE_CHARMAP_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   `charmap' API of the FreeType~2 cache sub-system.
+   *
+   *   This macro is deprecated.  Simply include @FT_CACHE_H to have all
+   *   charmap-based cache declarations.
+   *
+   */
+#define FT_CACHE_CHARMAP_H  FT_CACHE_H
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_MAC_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   Macintosh-specific FreeType~2 API.  The latter is used to access
+   *   fonts embedded in resource forks.
+   *
+   *   This header file must be explicitly included by client applications
+   *   compiled on the Mac (note that the base API still works though).
+   *
+   */
+#define FT_MAC_H  <freetype/ftmac.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_MULTIPLE_MASTERS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   optional multiple-masters management API of FreeType~2.
+   *
+   */
+#define FT_MULTIPLE_MASTERS_H  <freetype/ftmm.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_SFNT_NAMES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   optional FreeType~2 API which accesses embedded `name' strings in
+   *   SFNT-based font formats (i.e., TrueType and OpenType).
+   *
+   */
+#define FT_SFNT_NAMES_H  <freetype/ftsnames.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_OPENTYPE_VALIDATE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   optional FreeType~2 API which validates OpenType tables (BASE, GDEF,
+   *   GPOS, GSUB, JSTF).
+   *
+   */
+#define FT_OPENTYPE_VALIDATE_H  <freetype/ftotval.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_GX_VALIDATE_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   optional FreeType~2 API which validates TrueTypeGX/AAT tables (feat,
+   *   mort, morx, bsln, just, kern, opbd, trak, prop).
+   *
+   */
+#define FT_GX_VALIDATE_H  <freetype/ftgxval.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_PFR_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which accesses PFR-specific data.
+   *
+   */
+#define FT_PFR_H  <freetype/ftpfr.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_STROKER_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which provides functions to stroke outline paths.
+   */
+#define FT_STROKER_H  <freetype/ftstroke.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_SYNTHESIS_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which performs artificial obliquing and emboldening.
+   */
+#define FT_SYNTHESIS_H  <freetype/ftsynth.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_XFREE86_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which provides functions specific to the XFree86 and
+   *   X.Org X11 servers.
+   */
+#define FT_XFREE86_H  <freetype/ftxf86.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_TRIGONOMETRY_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which performs trigonometric computations (e.g.,
+   *   cosines and arc tangents).
+   */
+#define FT_TRIGONOMETRY_H  <freetype/fttrigon.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_LCD_FILTER_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which performs color filtering for subpixel rendering.
+   */
+#define FT_LCD_FILTER_H  <freetype/ftlcdfil.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_UNPATENTED_HINTING_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which performs color filtering for subpixel rendering.
+   */
+#define FT_UNPATENTED_HINTING_H  <freetype/ttunpat.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_INCREMENTAL_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which performs color filtering for subpixel rendering.
+   */
+#define FT_INCREMENTAL_H  <freetype/ftincrem.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_GASP_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which returns entries from the TrueType GASP table.
+   */
+#define FT_GASP_H  <freetype/ftgasp.h>
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_ADVANCES_H
+   *
+   * @description:
+   *   A macro used in #include statements to name the file containing the
+   *   FreeType~2 API which returns individual and ranged glyph advances.
+   */
+#define FT_ADVANCES_H  <freetype/ftadvanc.h>
+
+
+  /* */
+
+#define FT_ERROR_DEFINITIONS_H  <freetype/fterrdef.h>
+
+
+  /* The internals of the cache sub-system are no longer exposed.  We */
+  /* default to FT_CACHE_H at the moment just in case, but we know of */
+  /* no rogue client that uses them.                                  */
+  /*                                                                  */
+#define FT_CACHE_MANAGER_H           <freetype/ftcache.h>
+#define FT_CACHE_INTERNAL_MRU_H      <freetype/ftcache.h>
+#define FT_CACHE_INTERNAL_MANAGER_H  <freetype/ftcache.h>
+#define FT_CACHE_INTERNAL_CACHE_H    <freetype/ftcache.h>
+#define FT_CACHE_INTERNAL_GLYPH_H    <freetype/ftcache.h>
+#define FT_CACHE_INTERNAL_IMAGE_H    <freetype/ftcache.h>
+#define FT_CACHE_INTERNAL_SBITS_H    <freetype/ftcache.h>
+
+
+#define FT_INCREMENTAL_H          <freetype/ftincrem.h>
+
+#define FT_TRUETYPE_UNPATENTED_H  <freetype/ttunpat.h>
+
+
+  /*
+   * Include internal headers definitions from <freetype/internal/...>
+   * only when building the library.
+   */
+#ifdef FT2_BUILD_LIBRARY
+#define  FT_INTERNAL_INTERNAL_H  <freetype/internal/internal.h>
+#include FT_INTERNAL_INTERNAL_H
+#endif /* FT2_BUILD_LIBRARY */
+
+
+#endif /* __FT2_BUILD_H__ */
+
+
+/* END */
diff --git a/include/freetype/config/ftmodule.h b/include/freetype/config/ftmodule.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/config/ftmodule.h
@@ -0,0 +1,32 @@
+/*
+ *  This file registers the FreeType modules compiled into the library.
+ *
+ *  If you use GNU make, this file IS NOT USED!  Instead, it is created in
+ *  the objects directory (normally `<topdir>/objs/') based on information
+ *  from `<topdir>/modules.cfg'.
+ *
+ *  Please read `docs/INSTALL.ANY' and `docs/CUSTOMIZE' how to compile
+ *  FreeType without GNU make.
+ *
+ */
+
+FT_USE_MODULE( FT_Module_Class, autofit_module_class )
+FT_USE_MODULE( FT_Driver_ClassRec, tt_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, t1_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, cff_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, t1cid_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, pfr_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, t42_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, winfnt_driver_class )
+FT_USE_MODULE( FT_Driver_ClassRec, pcf_driver_class )
+FT_USE_MODULE( FT_Module_Class, psaux_module_class )
+FT_USE_MODULE( FT_Module_Class, psnames_module_class )
+FT_USE_MODULE( FT_Module_Class, pshinter_module_class )
+FT_USE_MODULE( FT_Renderer_Class, ft_raster1_renderer_class )
+FT_USE_MODULE( FT_Module_Class, sfnt_module_class )
+FT_USE_MODULE( FT_Renderer_Class, ft_smooth_renderer_class )
+FT_USE_MODULE( FT_Renderer_Class, ft_smooth_lcd_renderer_class )
+FT_USE_MODULE( FT_Renderer_Class, ft_smooth_lcdv_renderer_class )
+FT_USE_MODULE( FT_Driver_ClassRec, bdf_driver_class )
+
+/* EOF */
diff --git a/include/freetype/config/ftoption.h b/include/freetype/config/ftoption.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/config/ftoption.h
@@ -0,0 +1,827 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftoption.h                                                             */
+/*                                                                         */
+/*    User-selectable configuration macros (specification only).           */
+/*                                                                         */
+/*  Copyright 1996-2012 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTOPTION_H__
+#define __FTOPTION_H__
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                 USER-SELECTABLE CONFIGURATION MACROS                  */
+  /*                                                                       */
+  /* This file contains the default configuration macro definitions for    */
+  /* a standard build of the FreeType library.  There are three ways to    */
+  /* use this file to build project-specific versions of the library:      */
+  /*                                                                       */
+  /*  - You can modify this file by hand, but this is not recommended in   */
+  /*    cases where you would like to build several versions of the        */
+  /*    library from a single source directory.                            */
+  /*                                                                       */
+  /*  - You can put a copy of this file in your build directory, more      */
+  /*    precisely in `$BUILD/freetype/config/ftoption.h', where `$BUILD'   */
+  /*    is the name of a directory that is included _before_ the FreeType  */
+  /*    include path during compilation.                                   */
+  /*                                                                       */
+  /*    The default FreeType Makefiles and Jamfiles use the build          */
+  /*    directory `builds/<system>' by default, but you can easily change  */
+  /*    that for your own projects.                                        */
+  /*                                                                       */
+  /*  - Copy the file <ft2build.h> to `$BUILD/ft2build.h' and modify it    */
+  /*    slightly to pre-define the macro FT_CONFIG_OPTIONS_H used to       */
+  /*    locate this file during the build.  For example,                   */
+  /*                                                                       */
+  /*      #define FT_CONFIG_OPTIONS_H  <myftoptions.h>                     */
+  /*      #include <freetype/config/ftheader.h>                            */
+  /*                                                                       */
+  /*    will use `$BUILD/myftoptions.h' instead of this file for macro     */
+  /*    definitions.                                                       */
+  /*                                                                       */
+  /*    Note also that you can similarly pre-define the macro              */
+  /*    FT_CONFIG_MODULES_H used to locate the file listing of the modules */
+  /*    that are statically linked to the library at compile time.  By     */
+  /*    default, this file is <freetype/config/ftmodule.h>.                */
+  /*                                                                       */
+  /*  We highly recommend using the third method whenever possible.        */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /**** G E N E R A L   F R E E T Y P E   2   C O N F I G U R A T I O N ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Uncomment the line below if you want to activate sub-pixel rendering  */
+  /* (a.k.a. LCD rendering, or ClearType) in this build of the library.    */
+  /*                                                                       */
+  /* Note that this feature is covered by several Microsoft patents        */
+  /* and should not be activated in any default build of the library.      */
+  /*                                                                       */
+  /* This macro has no impact on the FreeType API, only on its             */
+  /* _implementation_.  For example, using FT_RENDER_MODE_LCD when calling */
+  /* FT_Render_Glyph still generates a bitmap that is 3 times wider than   */
+  /* the original size in case this macro isn't defined; however, each     */
+  /* triplet of subpixels has R=G=B.                                       */
+  /*                                                                       */
+  /* This is done to allow FreeType clients to run unmodified, forcing     */
+  /* them to display normal gray-level anti-aliased glyphs.                */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Many compilers provide a non-ANSI 64-bit data type that can be used   */
+  /* by FreeType to speed up some computations.  However, this will create */
+  /* some problems when compiling the library in strict ANSI mode.         */
+  /*                                                                       */
+  /* For this reason, the use of 64-bit integers is normally disabled when */
+  /* the __STDC__ macro is defined.  You can however disable this by       */
+  /* defining the macro FT_CONFIG_OPTION_FORCE_INT64 here.                 */
+  /*                                                                       */
+  /* For most compilers, this will only create compilation warnings when   */
+  /* building the library.                                                 */
+  /*                                                                       */
+  /* ObNote: The compiler-specific 64-bit integers are detected in the     */
+  /*         file `ftconfig.h' either statically or through the            */
+  /*         `configure' script on supported platforms.                    */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_FORCE_INT64
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, do not try to use an assembler version of   */
+  /* performance-critical functions (e.g. FT_MulFix).  You should only do  */
+  /* that to verify that the assembler function works properly, or to      */
+  /* execute benchmark tests of the various implementations.               */
+/* #define FT_CONFIG_OPTION_NO_ASSEMBLER */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, try to use an inlined assembler version of  */
+  /* the `FT_MulFix' function, which is a `hotspot' when loading and       */
+  /* hinting glyphs, and which should be executed as fast as possible.     */
+  /*                                                                       */
+  /* Note that if your compiler or CPU is not supported, this will default */
+  /* to the standard and portable implementation found in `ftcalc.c'.      */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INLINE_MULFIX
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LZW-compressed file support.                                          */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `compress' program.  This is mostly used to parse many of the PCF   */
+  /*   files that come with various X11 distributions.  The implementation */
+  /*   uses NetBSD's `zopen' to partially uncompress the file on the fly   */
+  /*   (see src/lzw/ftgzip.c).                                             */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_LZW
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Gzip-compressed file support.                                         */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `gzip' program.  This is mostly used to parse many of the PCF files */
+  /*   that come with XFree86.  The implementation uses `zlib' to          */
+  /*   partially uncompress the file on the fly (see src/gzip/ftgzip.c).   */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.  See also   */
+  /*   the macro FT_CONFIG_OPTION_SYSTEM_ZLIB below.                       */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_ZLIB
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ZLib library selection                                                */
+  /*                                                                       */
+  /*   This macro is only used when FT_CONFIG_OPTION_USE_ZLIB is defined.  */
+  /*   It allows FreeType's `ftgzip' component to link to the system's     */
+  /*   installation of the ZLib library.  This is useful on systems like   */
+  /*   Unix or VMS where it generally is already available.                */
+  /*                                                                       */
+  /*   If you let it undefined, the component will use its own copy        */
+  /*   of the zlib sources instead.  These have been modified to be        */
+  /*   included directly within the component and *not* export external    */
+  /*   function names.  This allows you to link any program with FreeType  */
+  /*   _and_ ZLib without linking conflicts.                               */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_SYSTEM_ZLIB */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Bzip2-compressed file support.                                        */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `bzip2' program.  This is mostly used to parse many of the PCF      */
+  /*   files that come with XFree86.  The implementation uses `libbz2' to  */
+  /*   partially uncompress the file on the fly (see src/bzip2/ftbzip2.c). */
+  /*   Contrary to gzip, bzip2 currently is not included and need to use   */
+  /*   the system available bzip2 implementation.                          */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_BZIP2 */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define to disable the use of file stream functions and types, FILE,   */
+  /* fopen() etc.  Enables the use of smaller system libraries on embedded */
+  /* systems that have multiple system libraries, some with or without     */
+  /* file stream support, in the cases where file stream support is not    */
+  /* necessary such as memory loading of font files.                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DLL export compilation                                                */
+  /*                                                                       */
+  /*   When compiling FreeType as a DLL, some systems/compilers need a     */
+  /*   special keyword in front OR after the return type of function       */
+  /*   declarations.                                                       */
+  /*                                                                       */
+  /*   Two macros are used within the FreeType source code to define       */
+  /*   exported library functions: FT_EXPORT and FT_EXPORT_DEF.            */
+  /*                                                                       */
+  /*     FT_EXPORT( return_type )                                          */
+  /*                                                                       */
+  /*       is used in a function declaration, as in                        */
+  /*                                                                       */
+  /*         FT_EXPORT( FT_Error )                                         */
+  /*         FT_Init_FreeType( FT_Library*  alibrary );                    */
+  /*                                                                       */
+  /*                                                                       */
+  /*     FT_EXPORT_DEF( return_type )                                      */
+  /*                                                                       */
+  /*       is used in a function definition, as in                         */
+  /*                                                                       */
+  /*         FT_EXPORT_DEF( FT_Error )                                     */
+  /*         FT_Init_FreeType( FT_Library*  alibrary )                     */
+  /*         {                                                             */
+  /*           ... some code ...                                           */
+  /*           return FT_Err_Ok;                                           */
+  /*         }                                                             */
+  /*                                                                       */
+  /*   You can provide your own implementation of FT_EXPORT and            */
+  /*   FT_EXPORT_DEF here if you want.  If you leave them undefined, they  */
+  /*   will be later automatically defined as `extern return_type' to      */
+  /*   allow normal compilation.                                           */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_EXPORT(x)      extern x */
+/* #define FT_EXPORT_DEF(x)  x */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Glyph Postscript Names handling                                       */
+  /*                                                                       */
+  /*   By default, FreeType 2 is compiled with the `psnames' module.  This */
+  /*   module is in charge of converting a glyph name string into a        */
+  /*   Unicode value, or return a Macintosh standard glyph name for the    */
+  /*   use with the TrueType `post' table.                                 */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want `psnames' compiled in your   */
+  /*   build of FreeType.  This has the following effects:                 */
+  /*                                                                       */
+  /*   - The TrueType driver will provide its own set of glyph names,      */
+  /*     if you build it to support postscript names in the TrueType       */
+  /*     `post' table.                                                     */
+  /*                                                                       */
+  /*   - The Type 1 driver will not be able to synthesize a Unicode        */
+  /*     charmap out of the glyphs found in the fonts.                     */
+  /*                                                                       */
+  /*   You would normally undefine this configuration macro when building  */
+  /*   a version of FreeType that doesn't contain a Type 1 or CFF driver.  */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Postscript Names to Unicode Values support                            */
+  /*                                                                       */
+  /*   By default, FreeType 2 is built with the `PSNames' module compiled  */
+  /*   in.  Among other things, the module is used to convert a glyph name */
+  /*   into a Unicode value.  This is especially useful in order to        */
+  /*   synthesize on the fly a Unicode charmap from the CFF/Type 1 driver  */
+  /*   through a big table named the `Adobe Glyph List' (AGL).             */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want the Adobe Glyph List         */
+  /*   compiled in your `PSNames' module.  The Type 1 driver will not be   */
+  /*   able to synthesize a Unicode charmap out of the glyphs found in the */
+  /*   fonts.                                                              */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Support for Mac fonts                                                 */
+  /*                                                                       */
+  /*   Define this macro if you want support for outline fonts in Mac      */
+  /*   format (mac dfont, mac resource, macbinary containing a mac         */
+  /*   resource) on non-Mac platforms.                                     */
+  /*                                                                       */
+  /*   Note that the `FOND' resource isn't checked.                        */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_MAC_FONTS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Guessing methods to access embedded resource forks                    */
+  /*                                                                       */
+  /*   Enable extra Mac fonts support on non-Mac platforms (e.g.           */
+  /*   GNU/Linux).                                                         */
+  /*                                                                       */
+  /*   Resource forks which include fonts data are stored sometimes in     */
+  /*   locations which users or developers don't expected.  In some cases, */
+  /*   resource forks start with some offset from the head of a file.  In  */
+  /*   other cases, the actual resource fork is stored in file different   */
+  /*   from what the user specifies.  If this option is activated,         */
+  /*   FreeType tries to guess whether such offsets or different file      */
+  /*   names must be used.                                                 */
+  /*                                                                       */
+  /*   Note that normal, direct access of resource forks is controlled via */
+  /*   the FT_CONFIG_OPTION_MAC_FONTS option.                              */
+  /*                                                                       */
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+#define FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Allow the use of FT_Incremental_Interface to load typefaces that      */
+  /* contain no glyph data, but supply it via a callback function.         */
+  /* This is required by clients supporting document formats which         */
+  /* supply font data incrementally as the document is parsed, such        */
+  /* as the Ghostscript interpreter for the PostScript language.           */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INCREMENTAL
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The size in bytes of the render pool used by the scan-line converter  */
+  /* to do all of its work.                                                */
+  /*                                                                       */
+  /* This must be greater than 4KByte if you use FreeType to rasterize     */
+  /* glyphs; otherwise, you may set it to zero to avoid unnecessary        */
+  /* allocation of the render pool.                                        */
+  /*                                                                       */
+#define FT_RENDER_POOL_SIZE  16384L
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FT_MAX_MODULES                                                        */
+  /*                                                                       */
+  /*   The maximum number of modules that can be registered in a single    */
+  /*   FreeType library object.  32 is the default.                        */
+  /*                                                                       */
+#define FT_MAX_MODULES  32
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Debug level                                                           */
+  /*                                                                       */
+  /*   FreeType can be compiled in debug or trace mode.  In debug mode,    */
+  /*   errors are reported through the `ftdebug' component.  In trace      */
+  /*   mode, additional messages are sent to the standard output during    */
+  /*   execution.                                                          */
+  /*                                                                       */
+  /*   Define FT_DEBUG_LEVEL_ERROR to build the library in debug mode.     */
+  /*   Define FT_DEBUG_LEVEL_TRACE to build it in trace mode.              */
+  /*                                                                       */
+  /*   Don't define any of these macros to compile in `release' mode!      */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_DEBUG_LEVEL_ERROR */
+/* #define FT_DEBUG_LEVEL_TRACE */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Autofitter debugging                                                  */
+  /*                                                                       */
+  /*   If FT_DEBUG_AUTOFIT is defined, FreeType provides some means to     */
+  /*   control the autofitter behaviour for debugging purposes with global */
+  /*   boolean variables (consequently, you should *never* enable this     */
+  /*   while compiling in `release' mode):                                 */
+  /*                                                                       */
+  /*     _af_debug_disable_horz_hints                                      */
+  /*     _af_debug_disable_vert_hints                                      */
+  /*     _af_debug_disable_blue_hints                                      */
+  /*                                                                       */
+  /*   Additionally, the following functions provide dumps of various      */
+  /*   internal autofit structures to stdout (using `printf'):             */
+  /*                                                                       */
+  /*     af_glyph_hints_dump_points                                        */
+  /*     af_glyph_hints_dump_segments                                      */
+  /*     af_glyph_hints_dump_edges                                         */
+  /*                                                                       */
+  /*   As an argument, they use another global variable:                   */
+  /*                                                                       */
+  /*     _af_debug_hints                                                   */
+  /*                                                                       */
+  /*   Please have a look at the `ftgrid' demo program to see how those    */
+  /*   variables and macros should be used.                                */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_DEBUG_AUTOFIT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Memory Debugging                                                      */
+  /*                                                                       */
+  /*   FreeType now comes with an integrated memory debugger that is       */
+  /*   capable of detecting simple errors like memory leaks or double      */
+  /*   deletes.  To compile it within your build of the library, you       */
+  /*   should define FT_DEBUG_MEMORY here.                                 */
+  /*                                                                       */
+  /*   Note that the memory debugger is only activated at runtime when     */
+  /*   when the _environment_ variable `FT2_DEBUG_MEMORY' is defined also! */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_DEBUG_MEMORY */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Module errors                                                         */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), the higher byte  */
+  /*   of an error code gives the module in which the error has occurred,  */
+  /*   while the lower byte is the real error code.                        */
+  /*                                                                       */
+  /*   Setting this macro makes sense for debugging purposes only, since   */
+  /*   it would break source compatibility of certain programs that use    */
+  /*   FreeType 2.                                                         */
+  /*                                                                       */
+  /*   More details can be found in the files ftmoderr.h and fterrors.h.   */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_USE_MODULE_ERRORS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Position Independent Code                                             */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), FreeType2 will   */
+  /*   avoid creating constants that require address fixups.  Instead the  */
+  /*   constants will be moved into a struct and additional intialization  */
+  /*   code will be used.                                                  */
+  /*                                                                       */
+  /*   Setting this macro is needed for systems that prohibit address      */
+  /*   fixups, such as BREW.                                               */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_PIC */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****        S F N T   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_EMBEDDED_BITMAPS if you want to support       */
+  /* embedded bitmaps in all formats using the SFNT module (namely         */
+  /* TrueType & OpenType).                                                 */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_EMBEDDED_BITMAPS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_POSTSCRIPT_NAMES if you want to be able to    */
+  /* load and enumerate the glyph Postscript names in a TrueType or        */
+  /* OpenType file.                                                        */
+  /*                                                                       */
+  /* Note that when you do not compile the `PSNames' module by undefining  */
+  /* the above FT_CONFIG_OPTION_POSTSCRIPT_NAMES, the `sfnt' module will   */
+  /* contain additional code used to read the PS Names table from a font.  */
+  /*                                                                       */
+  /* (By default, the module uses `PSNames' to extract glyph names.)       */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SFNT_NAMES if your applications need to       */
+  /* access the internal name table in a SFNT-based format like TrueType   */
+  /* or OpenType.  The name table contains various strings used to         */
+  /* describe the font, like family name, copyright, version, etc.  It     */
+  /* does not contain any glyph name though.                               */
+  /*                                                                       */
+  /* Accessing SFNT names is done through the functions declared in        */
+  /* `freetype/ftsnames.h'.                                                */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_SFNT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* TrueType CMap support                                                 */
+  /*                                                                       */
+  /*   Here you can fine-tune which TrueType CMap table format shall be    */
+  /*   supported.                                                          */
+#define TT_CONFIG_CMAP_FORMAT_0
+#define TT_CONFIG_CMAP_FORMAT_2
+#define TT_CONFIG_CMAP_FORMAT_4
+#define TT_CONFIG_CMAP_FORMAT_6
+#define TT_CONFIG_CMAP_FORMAT_8
+#define TT_CONFIG_CMAP_FORMAT_10
+#define TT_CONFIG_CMAP_FORMAT_12
+#define TT_CONFIG_CMAP_FORMAT_13
+#define TT_CONFIG_CMAP_FORMAT_14
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    T R U E T Y P E   D R I V E R    C O N F I G U R A T I O N   ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BYTECODE_INTERPRETER if you want to compile   */
+  /* a bytecode interpreter in the TrueType driver.                        */
+  /*                                                                       */
+  /* By undefining this, you will only compile the code necessary to load  */
+  /* TrueType glyphs without hinting.                                      */
+  /*                                                                       */
+  /*   Do not #undef this macro here, since the build system might         */
+  /*   define it for certain configurations only.                          */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
+  /* EXPERIMENTAL subpixel hinting support into the TrueType driver.  This */
+  /* replaces the native TrueType hinting mechanism when anything but      */
+  /* FT_RENDER_MODE_MONO is requested.                                     */
+  /*                                                                       */
+  /* Enabling this causes the TrueType driver to ignore instructions under */
+  /* certain conditions.  This is done in accordance with the guide here,  */
+  /* with some minor differences:                                          */
+  /*                                                                       */
+  /*  http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
+  /*                                                                       */
+  /* By undefining this, you only compile the code necessary to hint       */
+  /* TrueType glyphs with native TT hinting.                               */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be    */
+  /*   defined.                                                            */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If you define TT_CONFIG_OPTION_UNPATENTED_HINTING, a special version  */
+  /* of the TrueType bytecode interpreter is used that doesn't implement   */
+  /* any of the patented opcodes and algorithms.  The patents related to   */
+  /* TrueType hinting have expired worldwide since May 2010; this option   */
+  /* is now deprecated.                                                    */
+  /*                                                                       */
+  /* Note that the TT_CONFIG_OPTION_UNPATENTED_HINTING macro is *ignored*  */
+  /* if you define TT_CONFIG_OPTION_BYTECODE_INTERPRETER; in other words,  */
+  /* either define TT_CONFIG_OPTION_BYTECODE_INTERPRETER or                */
+  /* TT_CONFIG_OPTION_UNPATENTED_HINTING but not both at the same time.    */
+  /*                                                                       */
+  /* This macro is only useful for a small number of font files (mostly    */
+  /* for Asian scripts) that require bytecode interpretation to properly   */
+  /* load glyphs.  For all other fonts, this produces unpleasant results,  */
+  /* thus the unpatented interpreter is never used to load glyphs from     */
+  /* TrueType fonts unless one of the following two options is used.       */
+  /*                                                                       */
+  /*   - The unpatented interpreter is explicitly activated by the user    */
+  /*     through the FT_PARAM_TAG_UNPATENTED_HINTING parameter tag         */
+  /*     when opening the FT_Face.                                         */
+  /*                                                                       */
+  /*   - FreeType detects that the FT_Face corresponds to one of the       */
+  /*     `trick' fonts (e.g., `Mingliu') it knows about.  The font engine  */
+  /*     contains a hard-coded list of font names and other matching       */
+  /*     parameters (see function `tt_face_init' in file                   */
+  /*     `src/truetype/ttobjs.c').                                         */
+  /*                                                                       */
+  /* Here a sample code snippet for using FT_PARAM_TAG_UNPATENTED_HINTING. */
+  /*                                                                       */
+  /*   {                                                                   */
+  /*     FT_Parameter  parameter;                                          */
+  /*     FT_Open_Args  open_args;                                          */
+  /*                                                                       */
+  /*                                                                       */
+  /*     parameter.tag = FT_PARAM_TAG_UNPATENTED_HINTING;                  */
+  /*                                                                       */
+  /*     open_args.flags      = FT_OPEN_PATHNAME | FT_OPEN_PARAMS;         */
+  /*     open_args.pathname   = my_font_pathname;                          */
+  /*     open_args.num_params = 1;                                         */
+  /*     open_args.params     = &parameter;                                */
+  /*                                                                       */
+  /*     error = FT_Open_Face( library, &open_args, index, &face );        */
+  /*     ...                                                               */
+  /*   }                                                                   */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_UNPATENTED_HINTING */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_INTERPRETER_SWITCH to compile the TrueType    */
+  /* bytecode interpreter with a huge switch statement, rather than a call */
+  /* table.  This results in smaller and faster code for a number of       */
+  /* architectures.                                                        */
+  /*                                                                       */
+  /* Note however that on some compiler/processor combinations, undefining */
+  /* this macro will generate faster, though larger, code.                 */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_INTERPRETER_SWITCH
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the        */
+  /* TrueType glyph loader to use Apple's definition of how to handle      */
+  /* component offsets in composite glyphs.                                */
+  /*                                                                       */
+  /* Apple and MS disagree on the default behavior of component offsets    */
+  /* in composites.  Apple says that they should be scaled by the scaling  */
+  /* factors in the transformation matrix (roughly, it's more complex)     */
+  /* while MS says they should not.  OpenType defines two bits in the      */
+  /* composite flags array which can be used to disambiguate, but old      */
+  /* fonts will not have them.                                             */
+  /*                                                                       */
+  /*   http://www.microsoft.com/typography/otspec/glyf.htm                 */
+  /*   http://fonts.apple.com/TTRefMan/RM06/Chap6glyf.html                 */
+  /*                                                                       */
+#undef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include         */
+  /* support for Apple's distortable font technology (fvar, gvar, cvar,    */
+  /* and avar tables).  This has many similarities to Type 1 Multiple      */
+  /* Masters support.                                                      */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_GX_VAR_SUPPORT
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BDF if you want to include support for        */
+  /* an embedded `BDF ' table within SFNT-based bitmap formats.            */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BDF
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****      T Y P E 1   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and       */
+  /* arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is        */
+  /* required.                                                             */
+  /*                                                                       */
+#define T1_MAX_DICT_DEPTH  5
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
+  /* calls during glyph loading.                                           */
+  /*                                                                       */
+#define T1_MAX_SUBRS_CALLS  16
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
+  /* minimum of 16 is required.                                            */
+  /*                                                                       */
+  /* The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256. */
+  /*                                                                       */
+#define T1_MAX_CHARSTRINGS_OPERANDS  256
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of `t1afm', which is in charge of reading Type 1 AFM      */
+  /* files into an existing face.  Note that if set, the T1 driver will be */
+  /* unable to produce kerning distances.                                  */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_AFM
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of the Multiple Masters font support in the Type 1        */
+  /* driver.                                                               */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_MM_SUPPORT
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    A U T O F I T   M O D U L E    C O N F I G U R A T I O N     ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with CJK (Chinese, Japanese, Korean) script    */
+  /* support.                                                              */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_CJK
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with Indic script support.                     */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_INDIC
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with warp hinting.  The idea of the warping    */
+  /* code is to slightly scale and shift a glyph within a single dimension */
+  /* so that as much of its segments are aligned (more or less) on the     */
+  /* grid.  To find out the optimal scaling and shifting value, various    */
+  /* parameter combinations are tried and scored.                          */
+  /*                                                                       */
+  /* This experimental option is only active if the render mode is         */
+  /* FT_RENDER_MODE_LIGHT.                                                 */
+  /*                                                                       */
+/* #define AF_CONFIG_OPTION_USE_WARPER */
+
+  /* */
+
+
+  /*
+   * Define this variable if you want to keep the layout of internal
+   * structures that was used prior to FreeType 2.2.  This also compiles in
+   * a few obsolete functions to avoid linking problems on typical Unix
+   * distributions.
+   *
+   * For embedded systems or building a new distribution from scratch, it
+   * is recommended to disable the macro since it reduces the library's code
+   * size and activates a few memory-saving optimizations as well.
+   */
+#define FT_CONFIG_OPTION_OLD_INTERNALS
+
+
+  /*
+   *  To detect legacy cache-lookup call from a rogue client (<= 2.1.7),
+   *  we restrict the number of charmaps in a font.  The current API of
+   *  FTC_CMapCache_Lookup() takes cmap_index & charcode, but old API
+   *  takes charcode only.  To determine the passed value is for cmap_index
+   *  or charcode, the possible cmap_index is restricted not to exceed
+   *  the minimum possible charcode by a rogue client.  It is also very
+   *  unlikely that a rogue client is interested in Unicode values 0 to 15.
+   *
+   *  NOTE: The original threshold was 4 deduced from popular number of
+   *        cmap subtables in UCS-4 TrueType fonts, but now it is not
+   *        irregular for OpenType fonts to have more than 4 subtables,
+   *        because variation selector subtables are available for Apple
+   *        and Microsoft platforms.
+   */
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+#define FT_MAX_CHARMAP_CACHEABLE 15
+#endif
+
+
+  /*
+   * This macro is defined if either unpatented or native TrueType
+   * hinting is requested by the definitions above.
+   */
+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+#define  TT_USE_BYTECODE_INTERPRETER
+#undef   TT_CONFIG_OPTION_UNPATENTED_HINTING
+#elif defined TT_CONFIG_OPTION_UNPATENTED_HINTING
+#define  TT_USE_BYTECODE_INTERPRETER
+#endif
+
+FT_END_HEADER
+
+
+#endif /* __FTOPTION_H__ */
+
+
+/* END */
diff --git a/include/freetype/config/ftstdlib.h b/include/freetype/config/ftstdlib.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/config/ftstdlib.h
@@ -0,0 +1,174 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftstdlib.h                                                             */
+/*                                                                         */
+/*    ANSI-specific library and header configuration file (specification   */
+/*    only).                                                               */
+/*                                                                         */
+/*  Copyright 2002-2007, 2009, 2011-2012 by                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This file is used to group all #includes to the ANSI C library that   */
+  /* FreeType normally requires.  It also defines macros to rename the     */
+  /* standard functions within the FreeType source code.                   */
+  /*                                                                       */
+  /* Load a file which defines __FTSTDLIB_H__ before this one to override  */
+  /* it.                                                                   */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTSTDLIB_H__
+#define __FTSTDLIB_H__
+
+
+#include <stddef.h>
+
+#define ft_ptrdiff_t  ptrdiff_t
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                           integer limits                           */
+  /*                                                                    */
+  /* UINT_MAX and ULONG_MAX are used to automatically compute the size  */
+  /* of `int' and `long' in bytes at compile-time.  So far, this works  */
+  /* for all platforms the library has been tested on.                  */
+  /*                                                                    */
+  /* Note that on the extremely rare platforms that do not provide      */
+  /* integer types that are _exactly_ 16 and 32 bits wide (e.g. some    */
+  /* old Crays where `int' is 36 bits), we do not make any guarantee    */
+  /* about the correct behaviour of FT2 with all fonts.                 */
+  /*                                                                    */
+  /* In these case, `ftconfig.h' will refuse to compile anyway with a   */
+  /* message like `couldn't find 32-bit type' or something similar.     */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#include <limits.h>
+
+#define FT_CHAR_BIT    CHAR_BIT
+#define FT_USHORT_MAX  USHRT_MAX
+#define FT_INT_MAX     INT_MAX
+#define FT_INT_MIN     INT_MIN
+#define FT_UINT_MAX    UINT_MAX
+#define FT_ULONG_MAX   ULONG_MAX
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                 character and string processing                    */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#include <string.h>
+
+#define ft_memchr   memchr
+#define ft_memcmp   memcmp
+#define ft_memcpy   memcpy
+#define ft_memmove  memmove
+#define ft_memset   memset
+#define ft_strcat   strcat
+#define ft_strcmp   strcmp
+#define ft_strcpy   strcpy
+#define ft_strlen   strlen
+#define ft_strncmp  strncmp
+#define ft_strncpy  strncpy
+#define ft_strrchr  strrchr
+#define ft_strstr   strstr
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                           file handling                            */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#include <stdio.h>
+
+#define FT_FILE     FILE
+#define ft_fclose   fclose
+#define ft_fopen    fopen
+#define ft_fread    fread
+#define ft_fseek    fseek
+#define ft_ftell    ftell
+#define ft_sprintf  sprintf
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                             sorting                                */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#include <stdlib.h>
+
+#define ft_qsort  qsort
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                        memory allocation                           */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#define ft_scalloc   calloc
+#define ft_sfree     free
+#define ft_smalloc   malloc
+#define ft_srealloc  realloc
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                          miscellaneous                             */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#define ft_atol   atol
+#define ft_labs   labs
+
+
+  /**********************************************************************/
+  /*                                                                    */
+  /*                         execution control                          */
+  /*                                                                    */
+  /**********************************************************************/
+
+
+#include <setjmp.h>
+
+#define ft_jmp_buf     jmp_buf  /* note: this cannot be a typedef since */
+                                /*       jmp_buf is defined as a macro  */
+                                /*       on certain platforms           */
+
+#define ft_longjmp     longjmp
+#define ft_setjmp( b ) setjmp( *(ft_jmp_buf*) &(b) ) /* same thing here */
+
+
+  /* the following is only used for debugging purposes, i.e., if */
+  /* FT_DEBUG_LEVEL_ERROR or FT_DEBUG_LEVEL_TRACE are defined    */
+
+#include <stdarg.h>
+
+
+#endif /* __FTSTDLIB_H__ */
+
+
+/* END */
diff --git a/include/freetype/freetype.h b/include/freetype/freetype.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/freetype.h
@@ -0,0 +1,3990 @@
+/***************************************************************************/
+/*                                                                         */
+/*  freetype.h                                                             */
+/*                                                                         */
+/*    FreeType high-level API and common types (specification only).       */
+/*                                                                         */
+/*  Copyright 1996-2012 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FREETYPE_H__
+#define __FREETYPE_H__
+
+
+#ifndef FT_FREETYPE_H
+#error "`ft2build.h' hasn't been included yet!"
+#error "Please always use macros to include FreeType header files."
+#error "Example:"
+#error "  #include <ft2build.h>"
+#error "  #include FT_FREETYPE_H"
+#endif
+
+
+#include <ft2build.h>
+#include FT_CONFIG_CONFIG_H
+#include FT_ERRORS_H
+#include FT_TYPES_H
+
+
+FT_BEGIN_HEADER
+
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    user_allocation                                                    */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    User allocation                                                    */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    How client applications should allocate FreeType data structures.  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    FreeType assumes that structures allocated by the user and passed  */
+  /*    as arguments are zeroed out except for the actual data.  In other  */
+  /*    words, it is recommended to use `calloc' (or variants of it)       */
+  /*    instead of `malloc' for allocation.                                */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*                                                                       */
+  /*                        B A S I C   T Y P E S                          */
+  /*                                                                       */
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    base_interface                                                     */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Base Interface                                                     */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    The FreeType~2 base font interface.                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section describes the public high-level API of FreeType~2.    */
+  /*                                                                       */
+  /* <Order>                                                               */
+  /*    FT_Library                                                         */
+  /*    FT_Face                                                            */
+  /*    FT_Size                                                            */
+  /*    FT_GlyphSlot                                                       */
+  /*    FT_CharMap                                                         */
+  /*    FT_Encoding                                                        */
+  /*                                                                       */
+  /*    FT_FaceRec                                                         */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_SCALABLE                                              */
+  /*    FT_FACE_FLAG_FIXED_SIZES                                           */
+  /*    FT_FACE_FLAG_FIXED_WIDTH                                           */
+  /*    FT_FACE_FLAG_HORIZONTAL                                            */
+  /*    FT_FACE_FLAG_VERTICAL                                              */
+  /*    FT_FACE_FLAG_SFNT                                                  */
+  /*    FT_FACE_FLAG_KERNING                                               */
+  /*    FT_FACE_FLAG_MULTIPLE_MASTERS                                      */
+  /*    FT_FACE_FLAG_GLYPH_NAMES                                           */
+  /*    FT_FACE_FLAG_EXTERNAL_STREAM                                       */
+  /*    FT_FACE_FLAG_FAST_GLYPHS                                           */
+  /*    FT_FACE_FLAG_HINTER                                                */
+  /*                                                                       */
+  /*    FT_STYLE_FLAG_BOLD                                                 */
+  /*    FT_STYLE_FLAG_ITALIC                                               */
+  /*                                                                       */
+  /*    FT_SizeRec                                                         */
+  /*    FT_Size_Metrics                                                    */
+  /*                                                                       */
+  /*    FT_GlyphSlotRec                                                    */
+  /*    FT_Glyph_Metrics                                                   */
+  /*    FT_SubGlyph                                                        */
+  /*                                                                       */
+  /*    FT_Bitmap_Size                                                     */
+  /*                                                                       */
+  /*    FT_Init_FreeType                                                   */
+  /*    FT_Done_FreeType                                                   */
+  /*                                                                       */
+  /*    FT_New_Face                                                        */
+  /*    FT_Done_Face                                                       */
+  /*    FT_New_Memory_Face                                                 */
+  /*    FT_Open_Face                                                       */
+  /*    FT_Open_Args                                                       */
+  /*    FT_Parameter                                                       */
+  /*    FT_Attach_File                                                     */
+  /*    FT_Attach_Stream                                                   */
+  /*                                                                       */
+  /*    FT_Set_Char_Size                                                   */
+  /*    FT_Set_Pixel_Sizes                                                 */
+  /*    FT_Request_Size                                                    */
+  /*    FT_Select_Size                                                     */
+  /*    FT_Size_Request_Type                                               */
+  /*    FT_Size_Request                                                    */
+  /*    FT_Set_Transform                                                   */
+  /*    FT_Load_Glyph                                                      */
+  /*    FT_Get_Char_Index                                                  */
+  /*    FT_Get_Name_Index                                                  */
+  /*    FT_Load_Char                                                       */
+  /*                                                                       */
+  /*    FT_OPEN_MEMORY                                                     */
+  /*    FT_OPEN_STREAM                                                     */
+  /*    FT_OPEN_PATHNAME                                                   */
+  /*    FT_OPEN_DRIVER                                                     */
+  /*    FT_OPEN_PARAMS                                                     */
+  /*                                                                       */
+  /*    FT_LOAD_DEFAULT                                                    */
+  /*    FT_LOAD_RENDER                                                     */
+  /*    FT_LOAD_MONOCHROME                                                 */
+  /*    FT_LOAD_LINEAR_DESIGN                                              */
+  /*    FT_LOAD_NO_SCALE                                                   */
+  /*    FT_LOAD_NO_HINTING                                                 */
+  /*    FT_LOAD_NO_BITMAP                                                  */
+  /*    FT_LOAD_CROP_BITMAP                                                */
+  /*                                                                       */
+  /*    FT_LOAD_VERTICAL_LAYOUT                                            */
+  /*    FT_LOAD_IGNORE_TRANSFORM                                           */
+  /*    FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH                                */
+  /*    FT_LOAD_FORCE_AUTOHINT                                             */
+  /*    FT_LOAD_NO_RECURSE                                                 */
+  /*    FT_LOAD_PEDANTIC                                                   */
+  /*                                                                       */
+  /*    FT_LOAD_TARGET_NORMAL                                              */
+  /*    FT_LOAD_TARGET_LIGHT                                               */
+  /*    FT_LOAD_TARGET_MONO                                                */
+  /*    FT_LOAD_TARGET_LCD                                                 */
+  /*    FT_LOAD_TARGET_LCD_V                                               */
+  /*                                                                       */
+  /*    FT_Render_Glyph                                                    */
+  /*    FT_Render_Mode                                                     */
+  /*    FT_Get_Kerning                                                     */
+  /*    FT_Kerning_Mode                                                    */
+  /*    FT_Get_Track_Kerning                                               */
+  /*    FT_Get_Glyph_Name                                                  */
+  /*    FT_Get_Postscript_Name                                             */
+  /*                                                                       */
+  /*    FT_CharMapRec                                                      */
+  /*    FT_Select_Charmap                                                  */
+  /*    FT_Set_Charmap                                                     */
+  /*    FT_Get_Charmap_Index                                               */
+  /*                                                                       */
+  /*    FT_FSTYPE_INSTALLABLE_EMBEDDING                                    */
+  /*    FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING                             */
+  /*    FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING                              */
+  /*    FT_FSTYPE_EDITABLE_EMBEDDING                                       */
+  /*    FT_FSTYPE_NO_SUBSETTING                                            */
+  /*    FT_FSTYPE_BITMAP_EMBEDDING_ONLY                                    */
+  /*                                                                       */
+  /*    FT_Get_FSType_Flags                                                */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Glyph_Metrics                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model the metrics of a single glyph.  The      */
+  /*    values are expressed in 26.6 fractional pixel format; if the flag  */
+  /*    @FT_LOAD_NO_SCALE has been used while loading the glyph, values    */
+  /*    are expressed in font units instead.                               */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    width ::                                                           */
+  /*      The glyph's width.                                               */
+  /*                                                                       */
+  /*    height ::                                                          */
+  /*      The glyph's height.                                              */
+  /*                                                                       */
+  /*    horiBearingX ::                                                    */
+  /*      Left side bearing for horizontal layout.                         */
+  /*                                                                       */
+  /*    horiBearingY ::                                                    */
+  /*      Top side bearing for horizontal layout.                          */
+  /*                                                                       */
+  /*    horiAdvance ::                                                     */
+  /*      Advance width for horizontal layout.                             */
+  /*                                                                       */
+  /*    vertBearingX ::                                                    */
+  /*      Left side bearing for vertical layout.                           */
+  /*                                                                       */
+  /*    vertBearingY ::                                                    */
+  /*      Top side bearing for vertical layout.  Larger positive values    */
+  /*      mean further below the vertical glyph origin.                    */
+  /*                                                                       */
+  /*    vertAdvance ::                                                     */
+  /*      Advance height for vertical layout.  Positive values mean the    */
+  /*      glyph has a positive advance downward.                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If not disabled with @FT_LOAD_NO_HINTING, the values represent     */
+  /*    dimensions of the hinted glyph (in case hinting is applicable).    */
+  /*                                                                       */
+  /*    Stroking a glyph with an outside border does not increase          */
+  /*    `horiAdvance' or `vertAdvance'; you have to manually adjust these  */
+  /*    values to account for the added width and height.                  */
+  /*                                                                       */
+  typedef struct  FT_Glyph_Metrics_
+  {
+    FT_Pos  width;
+    FT_Pos  height;
+
+    FT_Pos  horiBearingX;
+    FT_Pos  horiBearingY;
+    FT_Pos  horiAdvance;
+
+    FT_Pos  vertBearingX;
+    FT_Pos  vertBearingY;
+    FT_Pos  vertAdvance;
+
+  } FT_Glyph_Metrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Bitmap_Size                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure models the metrics of a bitmap strike (i.e., a set  */
+  /*    of glyphs for a given point size and resolution) in a bitmap font. */
+  /*    It is used for the `available_sizes' field of @FT_Face.            */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    height :: The vertical distance, in pixels, between two            */
+  /*              consecutive baselines.  It is always positive.           */
+  /*                                                                       */
+  /*    width  :: The average width, in pixels, of all glyphs in the       */
+  /*              strike.                                                  */
+  /*                                                                       */
+  /*    size   :: The nominal size of the strike in 26.6 fractional        */
+  /*              points.  This field is not very useful.                  */
+  /*                                                                       */
+  /*    x_ppem :: The horizontal ppem (nominal width) in 26.6 fractional   */
+  /*              pixels.                                                  */
+  /*                                                                       */
+  /*    y_ppem :: The vertical ppem (nominal height) in 26.6 fractional    */
+  /*              pixels.                                                  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Windows FNT:                                                       */
+  /*      The nominal size given in a FNT font is not reliable.  Thus when */
+  /*      the driver finds it incorrect, it sets `size' to some calculated */
+  /*      values and sets `x_ppem' and `y_ppem' to the pixel width and     */
+  /*      height given in the font, respectively.                          */
+  /*                                                                       */
+  /*    TrueType embedded bitmaps:                                         */
+  /*      `size', `width', and `height' values are not contained in the    */
+  /*      bitmap strike itself.  They are computed from the global font    */
+  /*      parameters.                                                      */
+  /*                                                                       */
+  typedef struct  FT_Bitmap_Size_
+  {
+    FT_Short  height;
+    FT_Short  width;
+
+    FT_Pos    size;
+
+    FT_Pos    x_ppem;
+    FT_Pos    y_ppem;
+
+  } FT_Bitmap_Size;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*                                                                       */
+  /*                     O B J E C T   C L A S S E S                       */
+  /*                                                                       */
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Library                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a FreeType library instance.  Each `library' is        */
+  /*    completely independent from the others; it is the `root' of a set  */
+  /*    of objects like fonts, faces, sizes, etc.                          */
+  /*                                                                       */
+  /*    It also embeds a memory manager (see @FT_Memory), as well as a     */
+  /*    scan-line converter object (see @FT_Raster).                       */
+  /*                                                                       */
+  /*    For multi-threading applications each thread should have its own   */
+  /*    FT_Library object.                                                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Library objects are normally created by @FT_Init_FreeType, and     */
+  /*    destroyed with @FT_Done_FreeType.                                  */
+  /*                                                                       */
+  typedef struct FT_LibraryRec_  *FT_Library;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Module                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a given FreeType module object.  Each module can be a  */
+  /*    font driver, a renderer, or anything else that provides services   */
+  /*    to the formers.                                                    */
+  /*                                                                       */
+  typedef struct FT_ModuleRec_*  FT_Module;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Driver                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a given FreeType font driver object.  Each font driver */
+  /*    is a special module capable of creating faces from font files.     */
+  /*                                                                       */
+  typedef struct FT_DriverRec_*  FT_Driver;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Renderer                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a given FreeType renderer.  A renderer is a special    */
+  /*    module in charge of converting a glyph image to a bitmap, when     */
+  /*    necessary.  Each renderer supports a given glyph image format, and */
+  /*    one or more target surface depths.                                 */
+  /*                                                                       */
+  typedef struct FT_RendererRec_*  FT_Renderer;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Face                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a given typographic face object.  A face object models */
+  /*    a given typeface, in a given style.                                */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Each face object also owns a single @FT_GlyphSlot object, as well  */
+  /*    as one or more @FT_Size objects.                                   */
+  /*                                                                       */
+  /*    Use @FT_New_Face or @FT_Open_Face to create a new face object from */
+  /*    a given filepathname or a custom input stream.                     */
+  /*                                                                       */
+  /*    Use @FT_Done_Face to destroy it (along with its slot and sizes).   */
+  /*                                                                       */
+  /* <Also>                                                                */
+  /*    See @FT_FaceRec for the publicly accessible fields of a given face */
+  /*    object.                                                            */
+  /*                                                                       */
+  typedef struct FT_FaceRec_*  FT_Face;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Size                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to an object used to model a face scaled to a given       */
+  /*    character size.                                                    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Each @FT_Face has an _active_ @FT_Size object that is used by      */
+  /*    functions like @FT_Load_Glyph to determine the scaling             */
+  /*    transformation which is used to load and hint glyphs and metrics.  */
+  /*                                                                       */
+  /*    You can use @FT_Set_Char_Size, @FT_Set_Pixel_Sizes,                */
+  /*    @FT_Request_Size or even @FT_Select_Size to change the content     */
+  /*    (i.e., the scaling values) of the active @FT_Size.                 */
+  /*                                                                       */
+  /*    You can use @FT_New_Size to create additional size objects for a   */
+  /*    given @FT_Face, but they won't be used by other functions until    */
+  /*    you activate it through @FT_Activate_Size.  Only one size can be   */
+  /*    activated at any given time per face.                              */
+  /*                                                                       */
+  /* <Also>                                                                */
+  /*    See @FT_SizeRec for the publicly accessible fields of a given size */
+  /*    object.                                                            */
+  /*                                                                       */
+  typedef struct FT_SizeRec_*  FT_Size;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_GlyphSlot                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a given `glyph slot'.  A slot is a container where it  */
+  /*    is possible to load any of the glyphs contained in its parent      */
+  /*    face.                                                              */
+  /*                                                                       */
+  /*    In other words, each time you call @FT_Load_Glyph or               */
+  /*    @FT_Load_Char, the slot's content is erased by the new glyph data, */
+  /*    i.e., the glyph's metrics, its image (bitmap or outline), and      */
+  /*    other control information.                                         */
+  /*                                                                       */
+  /* <Also>                                                                */
+  /*    See @FT_GlyphSlotRec for the publicly accessible glyph fields.     */
+  /*                                                                       */
+  typedef struct FT_GlyphSlotRec_*  FT_GlyphSlot;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_CharMap                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a given character map.  A charmap is used to translate */
+  /*    character codes in a given encoding into glyph indexes for its     */
+  /*    parent's face.  Some font formats may provide several charmaps per */
+  /*    font.                                                              */
+  /*                                                                       */
+  /*    Each face object owns zero or more charmaps, but only one of them  */
+  /*    can be `active' and used by @FT_Get_Char_Index or @FT_Load_Char.   */
+  /*                                                                       */
+  /*    The list of available charmaps in a face is available through the  */
+  /*    `face->num_charmaps' and `face->charmaps' fields of @FT_FaceRec.   */
+  /*                                                                       */
+  /*    The currently active charmap is available as `face->charmap'.      */
+  /*    You should call @FT_Set_Charmap to change it.                      */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    When a new face is created (either through @FT_New_Face or         */
+  /*    @FT_Open_Face), the library looks for a Unicode charmap within     */
+  /*    the list and automatically activates it.                           */
+  /*                                                                       */
+  /* <Also>                                                                */
+  /*    See @FT_CharMapRec for the publicly accessible fields of a given   */
+  /*    character map.                                                     */
+  /*                                                                       */
+  typedef struct FT_CharMapRec_*  FT_CharMap;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_ENC_TAG                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This macro converts four-letter tags into an unsigned long.  It is */
+  /*    used to define `encoding' identifiers (see @FT_Encoding).          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Since many 16-bit compilers don't like 32-bit enumerations, you    */
+  /*    should redefine this macro in case of problems to something like   */
+  /*    this:                                                              */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      #define FT_ENC_TAG( value, a, b, c, d )  value                   */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    to get a simple enumeration without assigning special numbers.     */
+  /*                                                                       */
+
+#ifndef FT_ENC_TAG
+#define FT_ENC_TAG( value, a, b, c, d )         \
+          value = ( ( (FT_UInt32)(a) << 24 ) |  \
+                    ( (FT_UInt32)(b) << 16 ) |  \
+                    ( (FT_UInt32)(c) <<  8 ) |  \
+                      (FT_UInt32)(d)         )
+
+#endif /* FT_ENC_TAG */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Encoding                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration used to specify character sets supported by         */
+  /*    charmaps.  Used in the @FT_Select_Charmap API function.            */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Despite the name, this enumeration lists specific character        */
+  /*    repertories (i.e., charsets), and not text encoding methods (e.g., */
+  /*    UTF-8, UTF-16, etc.).                                              */
+  /*                                                                       */
+  /*    Other encodings might be defined in the future.                    */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_ENCODING_NONE ::                                                */
+  /*      The encoding value~0 is reserved.                                */
+  /*                                                                       */
+  /*    FT_ENCODING_UNICODE ::                                             */
+  /*      Corresponds to the Unicode character set.  This value covers     */
+  /*      all versions of the Unicode repertoire, including ASCII and      */
+  /*      Latin-1.  Most fonts include a Unicode charmap, but not all      */
+  /*      of them.                                                         */
+  /*                                                                       */
+  /*      For example, if you want to access Unicode value U+1F028 (and    */
+  /*      the font contains it), use value 0x1F028 as the input value for  */
+  /*      @FT_Get_Char_Index.                                              */
+  /*                                                                       */
+  /*    FT_ENCODING_MS_SYMBOL ::                                           */
+  /*      Corresponds to the Microsoft Symbol encoding, used to encode     */
+  /*      mathematical symbols in the 32..255 character code range.  For   */
+  /*      more information, see `http://www.ceviz.net/symbol.htm'.         */
+  /*                                                                       */
+  /*    FT_ENCODING_SJIS ::                                                */
+  /*      Corresponds to Japanese SJIS encoding.  More info at             */
+  /*      at `http://langsupport.japanreference.com/encoding.shtml'.       */
+  /*      See note on multi-byte encodings below.                          */
+  /*                                                                       */
+  /*    FT_ENCODING_GB2312 ::                                              */
+  /*      Corresponds to an encoding system for Simplified Chinese as used */
+  /*      used in mainland China.                                          */
+  /*                                                                       */
+  /*    FT_ENCODING_BIG5 ::                                                */
+  /*      Corresponds to an encoding system for Traditional Chinese as     */
+  /*      used in Taiwan and Hong Kong.                                    */
+  /*                                                                       */
+  /*    FT_ENCODING_WANSUNG ::                                             */
+  /*      Corresponds to the Korean encoding system known as Wansung.      */
+  /*      For more information see                                         */
+  /*      `http://www.microsoft.com/typography/unicode/949.txt'.           */
+  /*                                                                       */
+  /*    FT_ENCODING_JOHAB ::                                               */
+  /*      The Korean standard character set (KS~C 5601-1992), which        */
+  /*      corresponds to MS Windows code page 1361.  This character set    */
+  /*      includes all possible Hangeul character combinations.            */
+  /*                                                                       */
+  /*    FT_ENCODING_ADOBE_LATIN_1 ::                                       */
+  /*      Corresponds to a Latin-1 encoding as defined in a Type~1         */
+  /*      PostScript font.  It is limited to 256 character codes.          */
+  /*                                                                       */
+  /*    FT_ENCODING_ADOBE_STANDARD ::                                      */
+  /*      Corresponds to the Adobe Standard encoding, as found in Type~1,  */
+  /*      CFF, and OpenType/CFF fonts.  It is limited to 256 character     */
+  /*      codes.                                                           */
+  /*                                                                       */
+  /*    FT_ENCODING_ADOBE_EXPERT ::                                        */
+  /*      Corresponds to the Adobe Expert encoding, as found in Type~1,    */
+  /*      CFF, and OpenType/CFF fonts.  It is limited to 256 character     */
+  /*      codes.                                                           */
+  /*                                                                       */
+  /*    FT_ENCODING_ADOBE_CUSTOM ::                                        */
+  /*      Corresponds to a custom encoding, as found in Type~1, CFF, and   */
+  /*      OpenType/CFF fonts.  It is limited to 256 character codes.       */
+  /*                                                                       */
+  /*    FT_ENCODING_APPLE_ROMAN ::                                         */
+  /*      Corresponds to the 8-bit Apple roman encoding.  Many TrueType    */
+  /*      and OpenType fonts contain a charmap for this encoding, since    */
+  /*      older versions of Mac OS are able to use it.                     */
+  /*                                                                       */
+  /*    FT_ENCODING_OLD_LATIN_2 ::                                         */
+  /*      This value is deprecated and was never used nor reported by      */
+  /*      FreeType.  Don't use or test for it.                             */
+  /*                                                                       */
+  /*    FT_ENCODING_MS_SJIS ::                                             */
+  /*      Same as FT_ENCODING_SJIS.  Deprecated.                           */
+  /*                                                                       */
+  /*    FT_ENCODING_MS_GB2312 ::                                           */
+  /*      Same as FT_ENCODING_GB2312.  Deprecated.                         */
+  /*                                                                       */
+  /*    FT_ENCODING_MS_BIG5 ::                                             */
+  /*      Same as FT_ENCODING_BIG5.  Deprecated.                           */
+  /*                                                                       */
+  /*    FT_ENCODING_MS_WANSUNG ::                                          */
+  /*      Same as FT_ENCODING_WANSUNG.  Deprecated.                        */
+  /*                                                                       */
+  /*    FT_ENCODING_MS_JOHAB ::                                            */
+  /*      Same as FT_ENCODING_JOHAB.  Deprecated.                          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    By default, FreeType automatically synthesizes a Unicode charmap   */
+  /*    for PostScript fonts, using their glyph names dictionaries.        */
+  /*    However, it also reports the encodings defined explicitly in the   */
+  /*    font file, for the cases when they are needed, with the Adobe      */
+  /*    values as well.                                                    */
+  /*                                                                       */
+  /*    FT_ENCODING_NONE is set by the BDF and PCF drivers if the charmap  */
+  /*    is neither Unicode nor ISO-8859-1 (otherwise it is set to          */
+  /*    FT_ENCODING_UNICODE).  Use @FT_Get_BDF_Charset_ID to find out      */
+  /*    which encoding is really present.  If, for example, the            */
+  /*    `cs_registry' field is `KOI8' and the `cs_encoding' field is `R',  */
+  /*    the font is encoded in KOI8-R.                                     */
+  /*                                                                       */
+  /*    FT_ENCODING_NONE is always set (with a single exception) by the    */
+  /*    winfonts driver.  Use @FT_Get_WinFNT_Header and examine the        */
+  /*    `charset' field of the @FT_WinFNT_HeaderRec structure to find out  */
+  /*    which encoding is really present.  For example,                    */
+  /*    @FT_WinFNT_ID_CP1251 (204) means Windows code page 1251 (for       */
+  /*    Russian).                                                          */
+  /*                                                                       */
+  /*    FT_ENCODING_NONE is set if `platform_id' is @TT_PLATFORM_MACINTOSH */
+  /*    and `encoding_id' is not @TT_MAC_ID_ROMAN (otherwise it is set to  */
+  /*    FT_ENCODING_APPLE_ROMAN).                                          */
+  /*                                                                       */
+  /*    If `platform_id' is @TT_PLATFORM_MACINTOSH, use the function       */
+  /*    @FT_Get_CMap_Language_ID  to query the Mac language ID which may   */
+  /*    be needed to be able to distinguish Apple encoding variants.  See  */
+  /*                                                                       */
+  /*      http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/README.TXT  */
+  /*                                                                       */
+  /*    to get an idea how to do that.  Basically, if the language ID      */
+  /*    is~0, don't use it, otherwise subtract 1 from the language ID.     */
+  /*    Then examine `encoding_id'.  If, for example, `encoding_id' is     */
+  /*    @TT_MAC_ID_ROMAN and the language ID (minus~1) is                  */
+  /*    `TT_MAC_LANGID_GREEK', it is the Greek encoding, not Roman.        */
+  /*    @TT_MAC_ID_ARABIC with `TT_MAC_LANGID_FARSI' means the Farsi       */
+  /*    variant the Arabic encoding.                                       */
+  /*                                                                       */
+  typedef enum  FT_Encoding_
+  {
+    FT_ENC_TAG( FT_ENCODING_NONE, 0, 0, 0, 0 ),
+
+    FT_ENC_TAG( FT_ENCODING_MS_SYMBOL, 's', 'y', 'm', 'b' ),
+    FT_ENC_TAG( FT_ENCODING_UNICODE,   'u', 'n', 'i', 'c' ),
+
+    FT_ENC_TAG( FT_ENCODING_SJIS,    's', 'j', 'i', 's' ),
+    FT_ENC_TAG( FT_ENCODING_GB2312,  'g', 'b', ' ', ' ' ),
+    FT_ENC_TAG( FT_ENCODING_BIG5,    'b', 'i', 'g', '5' ),
+    FT_ENC_TAG( FT_ENCODING_WANSUNG, 'w', 'a', 'n', 's' ),
+    FT_ENC_TAG( FT_ENCODING_JOHAB,   'j', 'o', 'h', 'a' ),
+
+    /* for backwards compatibility */
+    FT_ENCODING_MS_SJIS    = FT_ENCODING_SJIS,
+    FT_ENCODING_MS_GB2312  = FT_ENCODING_GB2312,
+    FT_ENCODING_MS_BIG5    = FT_ENCODING_BIG5,
+    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
+    FT_ENCODING_MS_JOHAB   = FT_ENCODING_JOHAB,
+
+    FT_ENC_TAG( FT_ENCODING_ADOBE_STANDARD, 'A', 'D', 'O', 'B' ),
+    FT_ENC_TAG( FT_ENCODING_ADOBE_EXPERT,   'A', 'D', 'B', 'E' ),
+    FT_ENC_TAG( FT_ENCODING_ADOBE_CUSTOM,   'A', 'D', 'B', 'C' ),
+    FT_ENC_TAG( FT_ENCODING_ADOBE_LATIN_1,  'l', 'a', 't', '1' ),
+
+    FT_ENC_TAG( FT_ENCODING_OLD_LATIN_2, 'l', 'a', 't', '2' ),
+
+    FT_ENC_TAG( FT_ENCODING_APPLE_ROMAN, 'a', 'r', 'm', 'n' )
+
+  } FT_Encoding;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    ft_encoding_xxx                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    These constants are deprecated; use the corresponding @FT_Encoding */
+  /*    values instead.                                                    */
+  /*                                                                       */
+#define ft_encoding_none            FT_ENCODING_NONE
+#define ft_encoding_unicode         FT_ENCODING_UNICODE
+#define ft_encoding_symbol          FT_ENCODING_MS_SYMBOL
+#define ft_encoding_latin_1         FT_ENCODING_ADOBE_LATIN_1
+#define ft_encoding_latin_2         FT_ENCODING_OLD_LATIN_2
+#define ft_encoding_sjis            FT_ENCODING_SJIS
+#define ft_encoding_gb2312          FT_ENCODING_GB2312
+#define ft_encoding_big5            FT_ENCODING_BIG5
+#define ft_encoding_wansung         FT_ENCODING_WANSUNG
+#define ft_encoding_johab           FT_ENCODING_JOHAB
+
+#define ft_encoding_adobe_standard  FT_ENCODING_ADOBE_STANDARD
+#define ft_encoding_adobe_expert    FT_ENCODING_ADOBE_EXPERT
+#define ft_encoding_adobe_custom    FT_ENCODING_ADOBE_CUSTOM
+#define ft_encoding_apple_roman     FT_ENCODING_APPLE_ROMAN
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_CharMapRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The base charmap structure.                                        */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    face        :: A handle to the parent face object.                 */
+  /*                                                                       */
+  /*    encoding    :: An @FT_Encoding tag identifying the charmap.  Use   */
+  /*                   this with @FT_Select_Charmap.                       */
+  /*                                                                       */
+  /*    platform_id :: An ID number describing the platform for the        */
+  /*                   following encoding ID.  This comes directly from    */
+  /*                   the TrueType specification and should be emulated   */
+  /*                   for other formats.                                  */
+  /*                                                                       */
+  /*    encoding_id :: A platform specific encoding number.  This also     */
+  /*                   comes from the TrueType specification and should be */
+  /*                   emulated similarly.                                 */
+  /*                                                                       */
+  typedef struct  FT_CharMapRec_
+  {
+    FT_Face      face;
+    FT_Encoding  encoding;
+    FT_UShort    platform_id;
+    FT_UShort    encoding_id;
+
+  } FT_CharMapRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*                                                                       */
+  /*                 B A S E   O B J E C T   C L A S S E S                 */
+  /*                                                                       */
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Face_Internal                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An opaque handle to an `FT_Face_InternalRec' structure, used to    */
+  /*    model private data of a given @FT_Face object.                     */
+  /*                                                                       */
+  /*    This structure might change between releases of FreeType~2 and is  */
+  /*    not generally available to client applications.                    */
+  /*                                                                       */
+  typedef struct FT_Face_InternalRec_*  FT_Face_Internal;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_FaceRec                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    FreeType root face class structure.  A face object models a        */
+  /*    typeface in a font file.                                           */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    num_faces           :: The number of faces in the font file.  Some */
+  /*                           font formats can have multiple faces in     */
+  /*                           a font file.                                */
+  /*                                                                       */
+  /*    face_index          :: The index of the face in the font file.  It */
+  /*                           is set to~0 if there is only one face in    */
+  /*                           the font file.                              */
+  /*                                                                       */
+  /*    face_flags          :: A set of bit flags that give important      */
+  /*                           information about the face; see             */
+  /*                           @FT_FACE_FLAG_XXX for the details.          */
+  /*                                                                       */
+  /*    style_flags         :: A set of bit flags indicating the style of  */
+  /*                           the face; see @FT_STYLE_FLAG_XXX for the    */
+  /*                           details.                                    */
+  /*                                                                       */
+  /*    num_glyphs          :: The number of glyphs in the face.  If the   */
+  /*                           face is scalable and has sbits (see         */
+  /*                           `num_fixed_sizes'), it is set to the number */
+  /*                           of outline glyphs.                          */
+  /*                                                                       */
+  /*                           For CID-keyed fonts, this value gives the   */
+  /*                           highest CID used in the font.               */
+  /*                                                                       */
+  /*    family_name         :: The face's family name.  This is an ASCII   */
+  /*                           string, usually in English, which describes */
+  /*                           the typeface's family (like `Times New      */
+  /*                           Roman', `Bodoni', `Garamond', etc).  This   */
+  /*                           is a least common denominator used to list  */
+  /*                           fonts.  Some formats (TrueType & OpenType)  */
+  /*                           provide localized and Unicode versions of   */
+  /*                           this string.  Applications should use the   */
+  /*                           format specific interface to access them.   */
+  /*                           Can be NULL (e.g., in fonts embedded in a   */
+  /*                           PDF file).                                  */
+  /*                                                                       */
+  /*    style_name          :: The face's style name.  This is an ASCII    */
+  /*                           string, usually in English, which describes */
+  /*                           the typeface's style (like `Italic',        */
+  /*                           `Bold', `Condensed', etc).  Not all font    */
+  /*                           formats provide a style name, so this field */
+  /*                           is optional, and can be set to NULL.  As    */
+  /*                           for `family_name', some formats provide     */
+  /*                           localized and Unicode versions of this      */
+  /*                           string.  Applications should use the format */
+  /*                           specific interface to access them.          */
+  /*                                                                       */
+  /*    num_fixed_sizes     :: The number of bitmap strikes in the face.   */
+  /*                           Even if the face is scalable, there might   */
+  /*                           still be bitmap strikes, which are called   */
+  /*                           `sbits' in that case.                       */
+  /*                                                                       */
+  /*    available_sizes     :: An array of @FT_Bitmap_Size for all bitmap  */
+  /*                           strikes in the face.  It is set to NULL if  */
+  /*                           there is no bitmap strike.                  */
+  /*                                                                       */
+  /*    num_charmaps        :: The number of charmaps in the face.         */
+  /*                                                                       */
+  /*    charmaps            :: An array of the charmaps of the face.       */
+  /*                                                                       */
+  /*    generic             :: A field reserved for client uses.  See the  */
+  /*                           @FT_Generic type description.               */
+  /*                                                                       */
+  /*    bbox                :: The font bounding box.  Coordinates are     */
+  /*                           expressed in font units (see                */
+  /*                           `units_per_EM').  The box is large enough   */
+  /*                           to contain any glyph from the font.  Thus,  */
+  /*                           `bbox.yMax' can be seen as the `maximum     */
+  /*                           ascender', and `bbox.yMin' as the `minimum  */
+  /*                           descender'.  Only relevant for scalable     */
+  /*                           formats.                                    */
+  /*                                                                       */
+  /*                           Note that the bounding box might be off by  */
+  /*                           (at least) one pixel for hinted fonts.  See */
+  /*                           @FT_Size_Metrics for further discussion.    */
+  /*                                                                       */
+  /*    units_per_EM        :: The number of font units per EM square for  */
+  /*                           this face.  This is typically 2048 for      */
+  /*                           TrueType fonts, and 1000 for Type~1 fonts.  */
+  /*                           Only relevant for scalable formats.         */
+  /*                                                                       */
+  /*    ascender            :: The typographic ascender of the face,       */
+  /*                           expressed in font units.  For font formats  */
+  /*                           not having this information, it is set to   */
+  /*                           `bbox.yMax'.  Only relevant for scalable    */
+  /*                           formats.                                    */
+  /*                                                                       */
+  /*    descender           :: The typographic descender of the face,      */
+  /*                           expressed in font units.  For font formats  */
+  /*                           not having this information, it is set to   */
+  /*                           `bbox.yMin'.  Note that this field is       */
+  /*                           usually negative.  Only relevant for        */
+  /*                           scalable formats.                           */
+  /*                                                                       */
+  /*    height              :: The height is the vertical distance         */
+  /*                           between two consecutive baselines,          */
+  /*                           expressed in font units.  It is always      */
+  /*                           positive.  Only relevant for scalable       */
+  /*                           formats.                                    */
+  /*                                                                       */
+  /*    max_advance_width   :: The maximum advance width, in font units,   */
+  /*                           for all glyphs in this face.  This can be   */
+  /*                           used to make word wrapping computations     */
+  /*                           faster.  Only relevant for scalable         */
+  /*                           formats.                                    */
+  /*                                                                       */
+  /*    max_advance_height  :: The maximum advance height, in font units,  */
+  /*                           for all glyphs in this face.  This is only  */
+  /*                           relevant for vertical layouts, and is set   */
+  /*                           to `height' for fonts that do not provide   */
+  /*                           vertical metrics.  Only relevant for        */
+  /*                           scalable formats.                           */
+  /*                                                                       */
+  /*    underline_position  :: The position, in font units, of the         */
+  /*                           underline line for this face.  It is the    */
+  /*                           center of the underlining stem.  Only       */
+  /*                           relevant for scalable formats.              */
+  /*                                                                       */
+  /*    underline_thickness :: The thickness, in font units, of the        */
+  /*                           underline for this face.  Only relevant for */
+  /*                           scalable formats.                           */
+  /*                                                                       */
+  /*    glyph               :: The face's associated glyph slot(s).        */
+  /*                                                                       */
+  /*    size                :: The current active size for this face.      */
+  /*                                                                       */
+  /*    charmap             :: The current active charmap for this face.   */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Fields may be changed after a call to @FT_Attach_File or           */
+  /*    @FT_Attach_Stream.                                                 */
+  /*                                                                       */
+  typedef struct  FT_FaceRec_
+  {
+    FT_Long           num_faces;
+    FT_Long           face_index;
+
+    FT_Long           face_flags;
+    FT_Long           style_flags;
+
+    FT_Long           num_glyphs;
+
+    FT_String*        family_name;
+    FT_String*        style_name;
+
+    FT_Int            num_fixed_sizes;
+    FT_Bitmap_Size*   available_sizes;
+
+    FT_Int            num_charmaps;
+    FT_CharMap*       charmaps;
+
+    FT_Generic        generic;
+
+    /*# The following member variables (down to `underline_thickness') */
+    /*# are only relevant to scalable outlines; cf. @FT_Bitmap_Size    */
+    /*# for bitmap fonts.                                              */
+    FT_BBox           bbox;
+
+    FT_UShort         units_per_EM;
+    FT_Short          ascender;
+    FT_Short          descender;
+    FT_Short          height;
+
+    FT_Short          max_advance_width;
+    FT_Short          max_advance_height;
+
+    FT_Short          underline_position;
+    FT_Short          underline_thickness;
+
+    FT_GlyphSlot      glyph;
+    FT_Size           size;
+    FT_CharMap        charmap;
+
+    /*@private begin */
+
+    FT_Driver         driver;
+    FT_Memory         memory;
+    FT_Stream         stream;
+
+    FT_ListRec        sizes_list;
+
+    FT_Generic        autohint;   /* face-specific auto-hinter data */
+    void*             extensions; /* unused                         */
+
+    FT_Face_Internal  internal;
+
+    /*@private end */
+
+  } FT_FaceRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_FACE_FLAG_XXX                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of bit flags used in the `face_flags' field of the          */
+  /*    @FT_FaceRec structure.  They inform client applications of         */
+  /*    properties of the corresponding face.                              */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_FACE_FLAG_SCALABLE ::                                           */
+  /*      Indicates that the face contains outline glyphs.  This doesn't   */
+  /*      prevent bitmap strikes, i.e., a face can have both this and      */
+  /*      and @FT_FACE_FLAG_FIXED_SIZES set.                               */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_FIXED_SIZES ::                                        */
+  /*      Indicates that the face contains bitmap strikes.  See also the   */
+  /*      `num_fixed_sizes' and `available_sizes' fields of @FT_FaceRec.   */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_FIXED_WIDTH ::                                        */
+  /*      Indicates that the face contains fixed-width characters (like    */
+  /*      Courier, Lucido, MonoType, etc.).                                */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_SFNT ::                                               */
+  /*      Indicates that the face uses the `sfnt' storage scheme.  For     */
+  /*      now, this means TrueType and OpenType.                           */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_HORIZONTAL ::                                         */
+  /*      Indicates that the face contains horizontal glyph metrics.  This */
+  /*      should be set for all common formats.                            */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_VERTICAL ::                                           */
+  /*      Indicates that the face contains vertical glyph metrics.  This   */
+  /*      is only available in some formats, not all of them.              */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_KERNING ::                                            */
+  /*      Indicates that the face contains kerning information.  If set,   */
+  /*      the kerning distance can be retrieved through the function       */
+  /*      @FT_Get_Kerning.  Otherwise the function always return the       */
+  /*      vector (0,0).  Note that FreeType doesn't handle kerning data    */
+  /*      from the `GPOS' table (as present in some OpenType fonts).       */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_FAST_GLYPHS ::                                        */
+  /*      THIS FLAG IS DEPRECATED.  DO NOT USE OR TEST IT.                 */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_MULTIPLE_MASTERS ::                                   */
+  /*      Indicates that the font contains multiple masters and is capable */
+  /*      of interpolating between them.  See the multiple-masters         */
+  /*      specific API for details.                                        */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_GLYPH_NAMES ::                                        */
+  /*      Indicates that the font contains glyph names that can be         */
+  /*      retrieved through @FT_Get_Glyph_Name.  Note that some TrueType   */
+  /*      fonts contain broken glyph name tables.  Use the function        */
+  /*      @FT_Has_PS_Glyph_Names when needed.                              */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_EXTERNAL_STREAM ::                                    */
+  /*      Used internally by FreeType to indicate that a face's stream was */
+  /*      provided by the client application and should not be destroyed   */
+  /*      when @FT_Done_Face is called.  Don't read or test this flag.     */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_HINTER ::                                             */
+  /*      Set if the font driver has a hinting machine of its own.  For    */
+  /*      example, with TrueType fonts, it makes sense to use data from    */
+  /*      the SFNT `gasp' table only if the native TrueType hinting engine */
+  /*      (with the bytecode interpreter) is available and active.         */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_CID_KEYED ::                                          */
+  /*      Set if the font is CID-keyed.  In that case, the font is not     */
+  /*      accessed by glyph indices but by CID values.  For subsetted      */
+  /*      CID-keyed fonts this has the consequence that not all index      */
+  /*      values are a valid argument to FT_Load_Glyph.  Only the CID      */
+  /*      values for which corresponding glyphs in the subsetted font      */
+  /*      exist make FT_Load_Glyph return successfully; in all other cases */
+  /*      you get an `FT_Err_Invalid_Argument' error.                      */
+  /*                                                                       */
+  /*      Note that CID-keyed fonts which are in an SFNT wrapper don't     */
+  /*      have this flag set since the glyphs are accessed in the normal   */
+  /*      way (using contiguous indices); the `CID-ness' isn't visible to  */
+  /*      the application.                                                 */
+  /*                                                                       */
+  /*    FT_FACE_FLAG_TRICKY ::                                             */
+  /*      Set if the font is `tricky', this is, it always needs the        */
+  /*      font format's native hinting engine to get a reasonable result.  */
+  /*      A typical example is the Chinese font `mingli.ttf' which uses    */
+  /*      TrueType bytecode instructions to move and scale all of its      */
+  /*      subglyphs.                                                       */
+  /*                                                                       */
+  /*      It is not possible to autohint such fonts using                  */
+  /*      @FT_LOAD_FORCE_AUTOHINT; it will also ignore                     */
+  /*      @FT_LOAD_NO_HINTING.  You have to set both @FT_LOAD_NO_HINTING   */
+  /*      and @FT_LOAD_NO_AUTOHINT to really disable hinting; however, you */
+  /*      probably never want this except for demonstration purposes.      */
+  /*                                                                       */
+  /*      Currently, there are about a dozen TrueType fonts in the list of */
+  /*      tricky fonts; they are hard-coded in file `ttobjs.c'.            */
+  /*                                                                       */
+#define FT_FACE_FLAG_SCALABLE          ( 1L <<  0 )
+#define FT_FACE_FLAG_FIXED_SIZES       ( 1L <<  1 )
+#define FT_FACE_FLAG_FIXED_WIDTH       ( 1L <<  2 )
+#define FT_FACE_FLAG_SFNT              ( 1L <<  3 )
+#define FT_FACE_FLAG_HORIZONTAL        ( 1L <<  4 )
+#define FT_FACE_FLAG_VERTICAL          ( 1L <<  5 )
+#define FT_FACE_FLAG_KERNING           ( 1L <<  6 )
+#define FT_FACE_FLAG_FAST_GLYPHS       ( 1L <<  7 )
+#define FT_FACE_FLAG_MULTIPLE_MASTERS  ( 1L <<  8 )
+#define FT_FACE_FLAG_GLYPH_NAMES       ( 1L <<  9 )
+#define FT_FACE_FLAG_EXTERNAL_STREAM   ( 1L << 10 )
+#define FT_FACE_FLAG_HINTER            ( 1L << 11 )
+#define FT_FACE_FLAG_CID_KEYED         ( 1L << 12 )
+#define FT_FACE_FLAG_TRICKY            ( 1L << 13 )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_HORIZONTAL( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains
+   *   horizontal metrics (this is true for all font formats though).
+   *
+   * @also:
+   *   @FT_HAS_VERTICAL can be used to check for vertical metrics.
+   *
+   */
+#define FT_HAS_HORIZONTAL( face ) \
+          ( face->face_flags & FT_FACE_FLAG_HORIZONTAL )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_VERTICAL( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains real
+   *   vertical metrics (and not only synthesized ones).
+   *
+   */
+#define FT_HAS_VERTICAL( face ) \
+          ( face->face_flags & FT_FACE_FLAG_VERTICAL )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_KERNING( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains kerning
+   *   data that can be accessed with @FT_Get_Kerning.
+   *
+   */
+#define FT_HAS_KERNING( face ) \
+          ( face->face_flags & FT_FACE_FLAG_KERNING )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_IS_SCALABLE( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains a scalable
+   *   font face (true for TrueType, Type~1, Type~42, CID, OpenType/CFF,
+   *   and PFR font formats.
+   *
+   */
+#define FT_IS_SCALABLE( face ) \
+          ( face->face_flags & FT_FACE_FLAG_SCALABLE )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_IS_SFNT( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains a font
+   *   whose format is based on the SFNT storage scheme.  This usually
+   *   means: TrueType fonts, OpenType fonts, as well as SFNT-based embedded
+   *   bitmap fonts.
+   *
+   *   If this macro is true, all functions defined in @FT_SFNT_NAMES_H and
+   *   @FT_TRUETYPE_TABLES_H are available.
+   *
+   */
+#define FT_IS_SFNT( face ) \
+          ( face->face_flags & FT_FACE_FLAG_SFNT )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_IS_FIXED_WIDTH( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains a font face
+   *   that contains fixed-width (or `monospace', `fixed-pitch', etc.)
+   *   glyphs.
+   *
+   */
+#define FT_IS_FIXED_WIDTH( face ) \
+          ( face->face_flags & FT_FACE_FLAG_FIXED_WIDTH )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_FIXED_SIZES( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains some
+   *   embedded bitmaps.  See the `available_sizes' field of the
+   *   @FT_FaceRec structure.
+   *
+   */
+#define FT_HAS_FIXED_SIZES( face ) \
+          ( face->face_flags & FT_FACE_FLAG_FIXED_SIZES )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_FAST_GLYPHS( face )
+   *
+   * @description:
+   *   Deprecated.
+   *
+   */
+#define FT_HAS_FAST_GLYPHS( face )  0
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_GLYPH_NAMES( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains some glyph
+   *   names that can be accessed through @FT_Get_Glyph_Name.
+   *
+   */
+#define FT_HAS_GLYPH_NAMES( face ) \
+          ( face->face_flags & FT_FACE_FLAG_GLYPH_NAMES )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_HAS_MULTIPLE_MASTERS( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains some
+   *   multiple masters.  The functions provided by @FT_MULTIPLE_MASTERS_H
+   *   are then available to choose the exact design you want.
+   *
+   */
+#define FT_HAS_MULTIPLE_MASTERS( face ) \
+          ( face->face_flags & FT_FACE_FLAG_MULTIPLE_MASTERS )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_IS_CID_KEYED( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face object contains a CID-keyed
+   *   font.  See the discussion of @FT_FACE_FLAG_CID_KEYED for more
+   *   details.
+   *
+   *   If this macro is true, all functions defined in @FT_CID_H are
+   *   available.
+   *
+   */
+#define FT_IS_CID_KEYED( face ) \
+          ( face->face_flags & FT_FACE_FLAG_CID_KEYED )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_IS_TRICKY( face )
+   *
+   * @description:
+   *   A macro that returns true whenever a face represents a `tricky' font.
+   *   See the discussion of @FT_FACE_FLAG_TRICKY for more details.
+   *
+   */
+#define FT_IS_TRICKY( face ) \
+          ( face->face_flags & FT_FACE_FLAG_TRICKY )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Const>                                                               */
+  /*    FT_STYLE_FLAG_XXX                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of bit-flags used to indicate the style of a given face.    */
+  /*    These are used in the `style_flags' field of @FT_FaceRec.          */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_STYLE_FLAG_ITALIC ::                                            */
+  /*      Indicates that a given face style is italic or oblique.          */
+  /*                                                                       */
+  /*    FT_STYLE_FLAG_BOLD ::                                              */
+  /*      Indicates that a given face is bold.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The style information as provided by FreeType is very basic.  More */
+  /*    details are beyond the scope and should be done on a higher level  */
+  /*    (for example, by analyzing various fields of the `OS/2' table in   */
+  /*    SFNT based fonts).                                                 */
+  /*                                                                       */
+#define FT_STYLE_FLAG_ITALIC  ( 1 << 0 )
+#define FT_STYLE_FLAG_BOLD    ( 1 << 1 )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Size_Internal                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An opaque handle to an `FT_Size_InternalRec' structure, used to    */
+  /*    model private data of a given @FT_Size object.                     */
+  /*                                                                       */
+  typedef struct FT_Size_InternalRec_*  FT_Size_Internal;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Size_Metrics                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The size metrics structure gives the metrics of a size object.     */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    x_ppem       :: The width of the scaled EM square in pixels, hence */
+  /*                    the term `ppem' (pixels per EM).  It is also       */
+  /*                    referred to as `nominal width'.                    */
+  /*                                                                       */
+  /*    y_ppem       :: The height of the scaled EM square in pixels,      */
+  /*                    hence the term `ppem' (pixels per EM).  It is also */
+  /*                    referred to as `nominal height'.                   */
+  /*                                                                       */
+  /*    x_scale      :: A 16.16 fractional scaling value used to convert   */
+  /*                    horizontal metrics from font units to 26.6         */
+  /*                    fractional pixels.  Only relevant for scalable     */
+  /*                    font formats.                                      */
+  /*                                                                       */
+  /*    y_scale      :: A 16.16 fractional scaling value used to convert   */
+  /*                    vertical metrics from font units to 26.6           */
+  /*                    fractional pixels.  Only relevant for scalable     */
+  /*                    font formats.                                      */
+  /*                                                                       */
+  /*    ascender     :: The ascender in 26.6 fractional pixels.  See       */
+  /*                    @FT_FaceRec for the details.                       */
+  /*                                                                       */
+  /*    descender    :: The descender in 26.6 fractional pixels.  See      */
+  /*                    @FT_FaceRec for the details.                       */
+  /*                                                                       */
+  /*    height       :: The height in 26.6 fractional pixels.  See         */
+  /*                    @FT_FaceRec for the details.                       */
+  /*                                                                       */
+  /*    max_advance  :: The maximum advance width in 26.6 fractional       */
+  /*                    pixels.  See @FT_FaceRec for the details.          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The scaling values, if relevant, are determined first during a     */
+  /*    size changing operation.  The remaining fields are then set by the */
+  /*    driver.  For scalable formats, they are usually set to scaled      */
+  /*    values of the corresponding fields in @FT_FaceRec.                 */
+  /*                                                                       */
+  /*    Note that due to glyph hinting, these values might not be exact    */
+  /*    for certain fonts.  Thus they must be treated as unreliable        */
+  /*    with an error margin of at least one pixel!                        */
+  /*                                                                       */
+  /*    Indeed, the only way to get the exact metrics is to render _all_   */
+  /*    glyphs.  As this would be a definite performance hit, it is up to  */
+  /*    client applications to perform such computations.                  */
+  /*                                                                       */
+  /*    The FT_Size_Metrics structure is valid for bitmap fonts also.      */
+  /*                                                                       */
+  typedef struct  FT_Size_Metrics_
+  {
+    FT_UShort  x_ppem;      /* horizontal pixels per EM               */
+    FT_UShort  y_ppem;      /* vertical pixels per EM                 */
+
+    FT_Fixed   x_scale;     /* scaling values used to convert font    */
+    FT_Fixed   y_scale;     /* units to 26.6 fractional pixels        */
+
+    FT_Pos     ascender;    /* ascender in 26.6 frac. pixels          */
+    FT_Pos     descender;   /* descender in 26.6 frac. pixels         */
+    FT_Pos     height;      /* text height in 26.6 frac. pixels       */
+    FT_Pos     max_advance; /* max horizontal advance, in 26.6 pixels */
+
+  } FT_Size_Metrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_SizeRec                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    FreeType root size class structure.  A size object models a face   */
+  /*    object at a given size.                                            */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    face    :: Handle to the parent face object.                       */
+  /*                                                                       */
+  /*    generic :: A typeless pointer, which is unused by the FreeType     */
+  /*               library or any of its drivers.  It can be used by       */
+  /*               client applications to link their own data to each size */
+  /*               object.                                                 */
+  /*                                                                       */
+  /*    metrics :: Metrics for this size object.  This field is read-only. */
+  /*                                                                       */
+  typedef struct  FT_SizeRec_
+  {
+    FT_Face           face;      /* parent face object              */
+    FT_Generic        generic;   /* generic pointer for client uses */
+    FT_Size_Metrics   metrics;   /* size metrics                    */
+    FT_Size_Internal  internal;
+
+  } FT_SizeRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_SubGlyph                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The subglyph structure is an internal object used to describe      */
+  /*    subglyphs (for example, in the case of composites).                */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The subglyph implementation is not part of the high-level API,     */
+  /*    hence the forward structure declaration.                           */
+  /*                                                                       */
+  /*    You can however retrieve subglyph information with                 */
+  /*    @FT_Get_SubGlyph_Info.                                             */
+  /*                                                                       */
+  typedef struct FT_SubGlyphRec_*  FT_SubGlyph;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Slot_Internal                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An opaque handle to an `FT_Slot_InternalRec' structure, used to    */
+  /*    model private data of a given @FT_GlyphSlot object.                */
+  /*                                                                       */
+  typedef struct FT_Slot_InternalRec_*  FT_Slot_Internal;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_GlyphSlotRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    FreeType root glyph slot class structure.  A glyph slot is a       */
+  /*    container where individual glyphs can be loaded, be they in        */
+  /*    outline or bitmap format.                                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    library           :: A handle to the FreeType library instance     */
+  /*                         this slot belongs to.                         */
+  /*                                                                       */
+  /*    face              :: A handle to the parent face object.           */
+  /*                                                                       */
+  /*    next              :: In some cases (like some font tools), several */
+  /*                         glyph slots per face object can be a good     */
+  /*                         thing.  As this is rare, the glyph slots are  */
+  /*                         listed through a direct, single-linked list   */
+  /*                         using its `next' field.                       */
+  /*                                                                       */
+  /*    generic           :: A typeless pointer which is unused by the     */
+  /*                         FreeType library or any of its drivers.  It   */
+  /*                         can be used by client applications to link    */
+  /*                         their own data to each glyph slot object.     */
+  /*                                                                       */
+  /*    metrics           :: The metrics of the last loaded glyph in the   */
+  /*                         slot.  The returned values depend on the last */
+  /*                         load flags (see the @FT_Load_Glyph API        */
+  /*                         function) and can be expressed either in 26.6 */
+  /*                         fractional pixels or font units.              */
+  /*                                                                       */
+  /*                         Note that even when the glyph image is        */
+  /*                         transformed, the metrics are not.             */
+  /*                                                                       */
+  /*    linearHoriAdvance :: The advance width of the unhinted glyph.      */
+  /*                         Its value is expressed in 16.16 fractional    */
+  /*                         pixels, unless @FT_LOAD_LINEAR_DESIGN is set  */
+  /*                         when loading the glyph.  This field can be    */
+  /*                         important to perform correct WYSIWYG layout.  */
+  /*                         Only relevant for outline glyphs.             */
+  /*                                                                       */
+  /*    linearVertAdvance :: The advance height of the unhinted glyph.     */
+  /*                         Its value is expressed in 16.16 fractional    */
+  /*                         pixels, unless @FT_LOAD_LINEAR_DESIGN is set  */
+  /*                         when loading the glyph.  This field can be    */
+  /*                         important to perform correct WYSIWYG layout.  */
+  /*                         Only relevant for outline glyphs.             */
+  /*                                                                       */
+  /*    advance           :: This shorthand is, depending on               */
+  /*                         @FT_LOAD_IGNORE_TRANSFORM, the transformed    */
+  /*                         advance width for the glyph (in 26.6          */
+  /*                         fractional pixel format).  As specified with  */
+  /*                         @FT_LOAD_VERTICAL_LAYOUT, it uses either the  */
+  /*                         `horiAdvance' or the `vertAdvance' value of   */
+  /*                         `metrics' field.                              */
+  /*                                                                       */
+  /*    format            :: This field indicates the format of the image  */
+  /*                         contained in the glyph slot.  Typically       */
+  /*                         @FT_GLYPH_FORMAT_BITMAP,                      */
+  /*                         @FT_GLYPH_FORMAT_OUTLINE, or                  */
+  /*                         @FT_GLYPH_FORMAT_COMPOSITE, but others are    */
+  /*                         possible.                                     */
+  /*                                                                       */
+  /*    bitmap            :: This field is used as a bitmap descriptor     */
+  /*                         when the slot format is                       */
+  /*                         @FT_GLYPH_FORMAT_BITMAP.  Note that the       */
+  /*                         address and content of the bitmap buffer can  */
+  /*                         change between calls of @FT_Load_Glyph and a  */
+  /*                         few other functions.                          */
+  /*                                                                       */
+  /*    bitmap_left       :: This is the bitmap's left bearing expressed   */
+  /*                         in integer pixels.  Of course, this is only   */
+  /*                         valid if the format is                        */
+  /*                         @FT_GLYPH_FORMAT_BITMAP.                      */
+  /*                                                                       */
+  /*    bitmap_top        :: This is the bitmap's top bearing expressed in */
+  /*                         integer pixels.  Remember that this is the    */
+  /*                         distance from the baseline to the top-most    */
+  /*                         glyph scanline, upwards y~coordinates being   */
+  /*                         *positive*.                                   */
+  /*                                                                       */
+  /*    outline           :: The outline descriptor for the current glyph  */
+  /*                         image if its format is                        */
+  /*                         @FT_GLYPH_FORMAT_OUTLINE.  Once a glyph is    */
+  /*                         loaded, `outline' can be transformed,         */
+  /*                         distorted, embolded, etc.  However, it must   */
+  /*                         not be freed.                                 */
+  /*                                                                       */
+  /*    num_subglyphs     :: The number of subglyphs in a composite glyph. */
+  /*                         This field is only valid for the composite    */
+  /*                         glyph format that should normally only be     */
+  /*                         loaded with the @FT_LOAD_NO_RECURSE flag.     */
+  /*                         For now this is internal to FreeType.         */
+  /*                                                                       */
+  /*    subglyphs         :: An array of subglyph descriptors for          */
+  /*                         composite glyphs.  There are `num_subglyphs'  */
+  /*                         elements in there.  Currently internal to     */
+  /*                         FreeType.                                     */
+  /*                                                                       */
+  /*    control_data      :: Certain font drivers can also return the      */
+  /*                         control data for a given glyph image (e.g.    */
+  /*                         TrueType bytecode, Type~1 charstrings, etc.). */
+  /*                         This field is a pointer to such data.         */
+  /*                                                                       */
+  /*    control_len       :: This is the length in bytes of the control    */
+  /*                         data.                                         */
+  /*                                                                       */
+  /*    other             :: Really wicked formats can use this pointer to */
+  /*                         present their own glyph image to client       */
+  /*                         applications.  Note that the application      */
+  /*                         needs to know about the image format.         */
+  /*                                                                       */
+  /*    lsb_delta         :: The difference between hinted and unhinted    */
+  /*                         left side bearing while autohinting is        */
+  /*                         active.  Zero otherwise.                      */
+  /*                                                                       */
+  /*    rsb_delta         :: The difference between hinted and unhinted    */
+  /*                         right side bearing while autohinting is       */
+  /*                         active.  Zero otherwise.                      */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If @FT_Load_Glyph is called with default flags (see                */
+  /*    @FT_LOAD_DEFAULT) the glyph image is loaded in the glyph slot in   */
+  /*    its native format (e.g., an outline glyph for TrueType and Type~1  */
+  /*    formats).                                                          */
+  /*                                                                       */
+  /*    This image can later be converted into a bitmap by calling         */
+  /*    @FT_Render_Glyph.  This function finds the current renderer for    */
+  /*    the native image's format, then invokes it.                        */
+  /*                                                                       */
+  /*    The renderer is in charge of transforming the native image through */
+  /*    the slot's face transformation fields, then converting it into a   */
+  /*    bitmap that is returned in `slot->bitmap'.                         */
+  /*                                                                       */
+  /*    Note that `slot->bitmap_left' and `slot->bitmap_top' are also used */
+  /*    to specify the position of the bitmap relative to the current pen  */
+  /*    position (e.g., coordinates (0,0) on the baseline).  Of course,    */
+  /*    `slot->format' is also changed to @FT_GLYPH_FORMAT_BITMAP.         */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Here a small pseudo code fragment which shows how to use           */
+  /*    `lsb_delta' and `rsb_delta':                                       */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      FT_Pos  origin_x       = 0;                                      */
+  /*      FT_Pos  prev_rsb_delta = 0;                                      */
+  /*                                                                       */
+  /*                                                                       */
+  /*      for all glyphs do                                                */
+  /*        <compute kern between current and previous glyph and add it to */
+  /*         `origin_x'>                                                   */
+  /*                                                                       */
+  /*        <load glyph with `FT_Load_Glyph'>                              */
+  /*                                                                       */
+  /*        if ( prev_rsb_delta - face->glyph->lsb_delta >= 32 )           */
+  /*          origin_x -= 64;                                              */
+  /*        else if ( prev_rsb_delta - face->glyph->lsb_delta < -32 )      */
+  /*          origin_x += 64;                                              */
+  /*                                                                       */
+  /*        prev_rsb_delta = face->glyph->rsb_delta;                       */
+  /*                                                                       */
+  /*        <save glyph image, or render glyph, or ...>                    */
+  /*                                                                       */
+  /*        origin_x += face->glyph->advance.x;                            */
+  /*      endfor                                                           */
+  /*    }                                                                  */
+  /*                                                                       */
+  typedef struct  FT_GlyphSlotRec_
+  {
+    FT_Library        library;
+    FT_Face           face;
+    FT_GlyphSlot      next;
+    FT_UInt           reserved;       /* retained for binary compatibility */
+    FT_Generic        generic;
+
+    FT_Glyph_Metrics  metrics;
+    FT_Fixed          linearHoriAdvance;
+    FT_Fixed          linearVertAdvance;
+    FT_Vector         advance;
+
+    FT_Glyph_Format   format;
+
+    FT_Bitmap         bitmap;
+    FT_Int            bitmap_left;
+    FT_Int            bitmap_top;
+
+    FT_Outline        outline;
+
+    FT_UInt           num_subglyphs;
+    FT_SubGlyph       subglyphs;
+
+    void*             control_data;
+    long              control_len;
+
+    FT_Pos            lsb_delta;
+    FT_Pos            rsb_delta;
+
+    void*             other;
+
+    FT_Slot_Internal  internal;
+
+  } FT_GlyphSlotRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*                                                                       */
+  /*                         F U N C T I O N S                             */
+  /*                                                                       */
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Init_FreeType                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Initialize a new FreeType library object.  The set of modules      */
+  /*    that are registered by this function is determined at build time.  */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    alibrary :: A handle to a new library object.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    In case you want to provide your own memory allocating routines,   */
+  /*    use @FT_New_Library instead, followed by a call to                 */
+  /*    @FT_Add_Default_Modules (or a series of calls to @FT_Add_Module).  */
+  /*                                                                       */
+  /*    For multi-threading applications each thread should have its own   */
+  /*    FT_Library object.                                                 */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Init_FreeType( FT_Library  *alibrary );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_FreeType                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroy a given FreeType library object and all of its children,   */
+  /*    including resources, drivers, faces, sizes, etc.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to the target library object.                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Done_FreeType( FT_Library  library );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_OPEN_XXX                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of bit-field constants used within the `flags' field of the */
+  /*    @FT_Open_Args structure.                                           */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_OPEN_MEMORY   :: This is a memory-based stream.                 */
+  /*                                                                       */
+  /*    FT_OPEN_STREAM   :: Copy the stream from the `stream' field.       */
+  /*                                                                       */
+  /*    FT_OPEN_PATHNAME :: Create a new input stream from a C~path        */
+  /*                        name.                                          */
+  /*                                                                       */
+  /*    FT_OPEN_DRIVER   :: Use the `driver' field.                        */
+  /*                                                                       */
+  /*    FT_OPEN_PARAMS   :: Use the `num_params' and `params' fields.      */
+  /*                                                                       */
+  /*    ft_open_memory   :: Deprecated; use @FT_OPEN_MEMORY instead.       */
+  /*                                                                       */
+  /*    ft_open_stream   :: Deprecated; use @FT_OPEN_STREAM instead.       */
+  /*                                                                       */
+  /*    ft_open_pathname :: Deprecated; use @FT_OPEN_PATHNAME instead.     */
+  /*                                                                       */
+  /*    ft_open_driver   :: Deprecated; use @FT_OPEN_DRIVER instead.       */
+  /*                                                                       */
+  /*    ft_open_params   :: Deprecated; use @FT_OPEN_PARAMS instead.       */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The `FT_OPEN_MEMORY', `FT_OPEN_STREAM', and `FT_OPEN_PATHNAME'     */
+  /*    flags are mutually exclusive.                                      */
+  /*                                                                       */
+#define FT_OPEN_MEMORY    0x1
+#define FT_OPEN_STREAM    0x2
+#define FT_OPEN_PATHNAME  0x4
+#define FT_OPEN_DRIVER    0x8
+#define FT_OPEN_PARAMS    0x10
+
+#define ft_open_memory    FT_OPEN_MEMORY     /* deprecated */
+#define ft_open_stream    FT_OPEN_STREAM     /* deprecated */
+#define ft_open_pathname  FT_OPEN_PATHNAME   /* deprecated */
+#define ft_open_driver    FT_OPEN_DRIVER     /* deprecated */
+#define ft_open_params    FT_OPEN_PARAMS     /* deprecated */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Parameter                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to pass more or less generic parameters to */
+  /*    @FT_Open_Face.                                                     */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    tag  :: A four-byte identification tag.                            */
+  /*                                                                       */
+  /*    data :: A pointer to the parameter data.                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The ID and function of parameters are driver-specific.  See the    */
+  /*    various FT_PARAM_TAG_XXX flags for more information.               */
+  /*                                                                       */
+  typedef struct  FT_Parameter_
+  {
+    FT_ULong    tag;
+    FT_Pointer  data;
+
+  } FT_Parameter;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Open_Args                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to indicate how to open a new font file or        */
+  /*    stream.  A pointer to such a structure can be used as a parameter  */
+  /*    for the functions @FT_Open_Face and @FT_Attach_Stream.             */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    flags       :: A set of bit flags indicating how to use the        */
+  /*                   structure.                                          */
+  /*                                                                       */
+  /*    memory_base :: The first byte of the file in memory.               */
+  /*                                                                       */
+  /*    memory_size :: The size in bytes of the file in memory.            */
+  /*                                                                       */
+  /*    pathname    :: A pointer to an 8-bit file pathname.                */
+  /*                                                                       */
+  /*    stream      :: A handle to a source stream object.                 */
+  /*                                                                       */
+  /*    driver      :: This field is exclusively used by @FT_Open_Face;    */
+  /*                   it simply specifies the font driver to use to open  */
+  /*                   the face.  If set to~0, FreeType tries to load the  */
+  /*                   face with each one of the drivers in its list.      */
+  /*                                                                       */
+  /*    num_params  :: The number of extra parameters.                     */
+  /*                                                                       */
+  /*    params      :: Extra parameters passed to the font driver when     */
+  /*                   opening a new face.                                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The stream type is determined by the contents of `flags' which     */
+  /*    are tested in the following order by @FT_Open_Face:                */
+  /*                                                                       */
+  /*    If the `FT_OPEN_MEMORY' bit is set, assume that this is a          */
+  /*    memory file of `memory_size' bytes, located at `memory_address'.   */
+  /*    The data are are not copied, and the client is responsible for     */
+  /*    releasing and destroying them _after_ the corresponding call to    */
+  /*    @FT_Done_Face.                                                     */
+  /*                                                                       */
+  /*    Otherwise, if the `FT_OPEN_STREAM' bit is set, assume that a       */
+  /*    custom input stream `stream' is used.                              */
+  /*                                                                       */
+  /*    Otherwise, if the `FT_OPEN_PATHNAME' bit is set, assume that this  */
+  /*    is a normal file and use `pathname' to open it.                    */
+  /*                                                                       */
+  /*    If the `FT_OPEN_DRIVER' bit is set, @FT_Open_Face only tries to    */
+  /*    open the file with the driver whose handler is in `driver'.        */
+  /*                                                                       */
+  /*    If the `FT_OPEN_PARAMS' bit is set, the parameters given by        */
+  /*    `num_params' and `params' is used.  They are ignored otherwise.    */
+  /*                                                                       */
+  /*    Ideally, both the `pathname' and `params' fields should be tagged  */
+  /*    as `const'; this is missing for API backwards compatibility.  In   */
+  /*    other words, applications should treat them as read-only.          */
+  /*                                                                       */
+  typedef struct  FT_Open_Args_
+  {
+    FT_UInt         flags;
+    const FT_Byte*  memory_base;
+    FT_Long         memory_size;
+    FT_String*      pathname;
+    FT_Stream       stream;
+    FT_Module       driver;
+    FT_Int          num_params;
+    FT_Parameter*   params;
+
+  } FT_Open_Args;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Face                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function calls @FT_Open_Face to open a font by its pathname.  */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library resource.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    pathname   :: A path to the font file.                             */
+  /*                                                                       */
+  /*    face_index :: The index of the face within the font.  The first    */
+  /*                  face has index~0.                                    */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aface      :: A handle to a new face object.  If `face_index' is   */
+  /*                  greater than or equal to zero, it must be non-NULL.  */
+  /*                  See @FT_Open_Face for more details.                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Face( FT_Library   library,
+               const char*  filepathname,
+               FT_Long      face_index,
+               FT_Face     *aface );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Memory_Face                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function calls @FT_Open_Face to open a font which has been    */
+  /*    loaded into memory.                                                */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library resource.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    file_base  :: A pointer to the beginning of the font data.         */
+  /*                                                                       */
+  /*    file_size  :: The size of the memory chunk used by the font data.  */
+  /*                                                                       */
+  /*    face_index :: The index of the face within the font.  The first    */
+  /*                  face has index~0.                                    */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aface      :: A handle to a new face object.  If `face_index' is   */
+  /*                  greater than or equal to zero, it must be non-NULL.  */
+  /*                  See @FT_Open_Face for more details.                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You must not deallocate the memory before calling @FT_Done_Face.   */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Memory_Face( FT_Library      library,
+                      const FT_Byte*  file_base,
+                      FT_Long         file_size,
+                      FT_Long         face_index,
+                      FT_Face        *aface );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Open_Face                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a face object from a given resource described by            */
+  /*    @FT_Open_Args.                                                     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library resource.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    args       :: A pointer to an `FT_Open_Args' structure which must  */
+  /*                  be filled by the caller.                             */
+  /*                                                                       */
+  /*    face_index :: The index of the face within the font.  The first    */
+  /*                  face has index~0.                                    */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aface      :: A handle to a new face object.  If `face_index' is   */
+  /*                  greater than or equal to zero, it must be non-NULL.  */
+  /*                  See note below.                                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Unlike FreeType 1.x, this function automatically creates a glyph   */
+  /*    slot for the face object which can be accessed directly through    */
+  /*    `face->glyph'.                                                     */
+  /*                                                                       */
+  /*    FT_Open_Face can be used to quickly check whether the font         */
+  /*    format of a given font resource is supported by FreeType.  If the  */
+  /*    `face_index' field is negative, the function's return value is~0   */
+  /*    if the font format is recognized, or non-zero otherwise;           */
+  /*    the function returns a more or less empty face handle in `*aface'  */
+  /*    (if `aface' isn't NULL).  The only useful field in this special    */
+  /*    case is `face->num_faces' which gives the number of faces within   */
+  /*    the font file.  After examination, the returned @FT_Face structure */
+  /*    should be deallocated with a call to @FT_Done_Face.                */
+  /*                                                                       */
+  /*    Each new face object created with this function also owns a        */
+  /*    default @FT_Size object, accessible as `face->size'.               */
+  /*                                                                       */
+  /*    One @FT_Library instance can have multiple face objects, this is,  */
+  /*    @FT_Open_Face and its siblings can be called multiple times using  */
+  /*    the same `library' argument.                                       */
+  /*                                                                       */
+  /*    See the discussion of reference counters in the description of     */
+  /*    @FT_Reference_Face.                                                */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Open_Face( FT_Library           library,
+                const FT_Open_Args*  args,
+                FT_Long              face_index,
+                FT_Face             *aface );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Attach_File                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function calls @FT_Attach_Stream to attach a file.            */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face         :: The target face object.                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    filepathname :: The pathname.                                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Attach_File( FT_Face      face,
+                  const char*  filepathname );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Attach_Stream                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    `Attach' data to a face object.  Normally, this is used to read    */
+  /*    additional information for the face object.  For example, you can  */
+  /*    attach an AFM file that comes with a Type~1 font to get the        */
+  /*    kerning values and other metrics.                                  */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face       :: The target face object.                              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    parameters :: A pointer to @FT_Open_Args which must be filled by   */
+  /*                  the caller.                                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The meaning of the `attach' (i.e., what really happens when the    */
+  /*    new file is read) is not fixed by FreeType itself.  It really      */
+  /*    depends on the font format (and thus the font driver).             */
+  /*                                                                       */
+  /*    Client applications are expected to know what they are doing       */
+  /*    when invoking this function.  Most drivers simply do not implement */
+  /*    file attachments.                                                  */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Attach_Stream( FT_Face        face,
+                    FT_Open_Args*  parameters );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Reference_Face                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A counter gets initialized to~1 at the time an @FT_Face structure  */
+  /*    is created.  This function increments the counter.  @FT_Done_Face  */
+  /*    then only destroys a face if the counter is~1, otherwise it simply */
+  /*    decrements the counter.                                            */
+  /*                                                                       */
+  /*    This function helps in managing life-cycles of structures which    */
+  /*    reference @FT_Face objects.                                        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to a target face object.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.4.2                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Reference_Face( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_Face                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Discard a given face object, as well as all of its child slots and */
+  /*    sizes.                                                             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to a target face object.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    See the discussion of reference counters in the description of     */
+  /*    @FT_Reference_Face.                                                */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Done_Face( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Select_Size                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Select a bitmap strike.                                            */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face         :: A handle to a target face object.                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    strike_index :: The index of the bitmap strike in the              */
+  /*                    `available_sizes' field of @FT_FaceRec structure.  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Select_Size( FT_Face  face,
+                  FT_Int   strike_index );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Size_Request_Type                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration type that lists the supported size request types.   */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_SIZE_REQUEST_TYPE_NOMINAL ::                                    */
+  /*      The nominal size.  The `units_per_EM' field of @FT_FaceRec is    */
+  /*      used to determine both scaling values.                           */
+  /*                                                                       */
+  /*    FT_SIZE_REQUEST_TYPE_REAL_DIM ::                                   */
+  /*      The real dimension.  The sum of the the `ascender' and (minus    */
+  /*      of) the `descender' fields of @FT_FaceRec are used to determine  */
+  /*      both scaling values.                                             */
+  /*                                                                       */
+  /*    FT_SIZE_REQUEST_TYPE_BBOX ::                                       */
+  /*      The font bounding box.  The width and height of the `bbox' field */
+  /*      of @FT_FaceRec are used to determine the horizontal and vertical */
+  /*      scaling value, respectively.                                     */
+  /*                                                                       */
+  /*    FT_SIZE_REQUEST_TYPE_CELL ::                                       */
+  /*      The `max_advance_width' field of @FT_FaceRec is used to          */
+  /*      determine the horizontal scaling value; the vertical scaling     */
+  /*      value is determined the same way as                              */
+  /*      @FT_SIZE_REQUEST_TYPE_REAL_DIM does.  Finally, both scaling      */
+  /*      values are set to the smaller one.  This type is useful if you   */
+  /*      want to specify the font size for, say, a window of a given      */
+  /*      dimension and 80x24 cells.                                       */
+  /*                                                                       */
+  /*    FT_SIZE_REQUEST_TYPE_SCALES ::                                     */
+  /*      Specify the scaling values directly.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The above descriptions only apply to scalable formats.  For bitmap */
+  /*    formats, the behaviour is up to the driver.                        */
+  /*                                                                       */
+  /*    See the note section of @FT_Size_Metrics if you wonder how size    */
+  /*    requesting relates to scaling values.                              */
+  /*                                                                       */
+  typedef enum  FT_Size_Request_Type_
+  {
+    FT_SIZE_REQUEST_TYPE_NOMINAL,
+    FT_SIZE_REQUEST_TYPE_REAL_DIM,
+    FT_SIZE_REQUEST_TYPE_BBOX,
+    FT_SIZE_REQUEST_TYPE_CELL,
+    FT_SIZE_REQUEST_TYPE_SCALES,
+
+    FT_SIZE_REQUEST_TYPE_MAX
+
+  } FT_Size_Request_Type;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Size_RequestRec                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a size request.                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    type           :: See @FT_Size_Request_Type.                       */
+  /*                                                                       */
+  /*    width          :: The desired width.                               */
+  /*                                                                       */
+  /*    height         :: The desired height.                              */
+  /*                                                                       */
+  /*    horiResolution :: The horizontal resolution.  If set to zero,      */
+  /*                      `width' is treated as a 26.6 fractional pixel    */
+  /*                      value.                                           */
+  /*                                                                       */
+  /*    vertResolution :: The vertical resolution.  If set to zero,        */
+  /*                      `height' is treated as a 26.6 fractional pixel   */
+  /*                      value.                                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If `width' is zero, then the horizontal scaling value is set equal */
+  /*    to the vertical scaling value, and vice versa.                     */
+  /*                                                                       */
+  typedef struct  FT_Size_RequestRec_
+  {
+    FT_Size_Request_Type  type;
+    FT_Long               width;
+    FT_Long               height;
+    FT_UInt               horiResolution;
+    FT_UInt               vertResolution;
+
+  } FT_Size_RequestRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Size_Request                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a size request structure.                              */
+  /*                                                                       */
+  typedef struct FT_Size_RequestRec_  *FT_Size_Request;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Request_Size                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Resize the scale of the active @FT_Size object in a face.          */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face :: A handle to a target face object.                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    req  :: A pointer to a @FT_Size_RequestRec.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Although drivers may select the bitmap strike matching the         */
+  /*    request, you should not rely on this if you intend to select a     */
+  /*    particular bitmap strike.  Use @FT_Select_Size instead in that     */
+  /*    case.                                                              */
+  /*                                                                       */
+  /*    The relation between the requested size and the resulting glyph    */
+  /*    size is dependent entirely on how the size is defined in the       */
+  /*    source face.  The font designer chooses the final size of each     */
+  /*    glyph relative to this size.  For more information refer to        */
+  /*    `http://www.freetype.org/freetype2/docs/glyphs/glyphs-2.html'      */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Request_Size( FT_Face          face,
+                   FT_Size_Request  req );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Char_Size                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function calls @FT_Request_Size to request the nominal size   */
+  /*    (in points).                                                       */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face            :: A handle to a target face object.               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    char_width      :: The nominal width, in 26.6 fractional points.   */
+  /*                                                                       */
+  /*    char_height     :: The nominal height, in 26.6 fractional points.  */
+  /*                                                                       */
+  /*    horz_resolution :: The horizontal resolution in dpi.               */
+  /*                                                                       */
+  /*    vert_resolution :: The vertical resolution in dpi.                 */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If either the character width or height is zero, it is set equal   */
+  /*    to the other value.                                                */
+  /*                                                                       */
+  /*    If either the horizontal or vertical resolution is zero, it is set */
+  /*    equal to the other value.                                          */
+  /*                                                                       */
+  /*    A character width or height smaller than 1pt is set to 1pt; if     */
+  /*    both resolution values are zero, they are set to 72dpi.            */
+  /*                                                                       */
+  /*    Don't use this function if you are using the FreeType cache API.   */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_Char_Size( FT_Face     face,
+                    FT_F26Dot6  char_width,
+                    FT_F26Dot6  char_height,
+                    FT_UInt     horz_resolution,
+                    FT_UInt     vert_resolution );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Pixel_Sizes                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function calls @FT_Request_Size to request the nominal size   */
+  /*    (in pixels).                                                       */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face         :: A handle to the target face object.                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    pixel_width  :: The nominal width, in pixels.                      */
+  /*                                                                       */
+  /*    pixel_height :: The nominal height, in pixels.                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You should not rely on the resulting glyphs matching, or being     */
+  /*    constrained, to this pixel size.  Refer to @FT_Request_Size to     */
+  /*    understand how requested sizes relate to actual sizes.             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_Pixel_Sizes( FT_Face  face,
+                      FT_UInt  pixel_width,
+                      FT_UInt  pixel_height );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Load_Glyph                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to load a single glyph into the glyph slot of a    */
+  /*    face object.                                                       */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face        :: A handle to the target face object where the glyph  */
+  /*                   is loaded.                                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    glyph_index :: The index of the glyph in the font file.  For       */
+  /*                   CID-keyed fonts (either in PS or in CFF format)     */
+  /*                   this argument specifies the CID value.              */
+  /*                                                                       */
+  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
+  /*                   @FT_LOAD_XXX constants can be used to control the   */
+  /*                   glyph loading process (e.g., whether the outline    */
+  /*                   should be scaled, whether to load bitmaps or not,   */
+  /*                   whether to hint the outline, etc).                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The loaded glyph may be transformed.  See @FT_Set_Transform for    */
+  /*    the details.                                                       */
+  /*                                                                       */
+  /*    For subsetted CID-keyed fonts, `FT_Err_Invalid_Argument' is        */
+  /*    returned for invalid CID values (this is, for CID values which     */
+  /*    don't have a corresponding glyph in the font).  See the discussion */
+  /*    of the @FT_FACE_FLAG_CID_KEYED flag for more details.              */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Load_Glyph( FT_Face   face,
+                 FT_UInt   glyph_index,
+                 FT_Int32  load_flags );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Load_Char                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to load a single glyph into the glyph slot of a    */
+  /*    face object, according to its character code.                      */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face        :: A handle to a target face object where the glyph    */
+  /*                   is loaded.                                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    char_code   :: The glyph's character code, according to the        */
+  /*                   current charmap used in the face.                   */
+  /*                                                                       */
+  /*    load_flags  :: A flag indicating what to load for this glyph.  The */
+  /*                   @FT_LOAD_XXX constants can be used to control the   */
+  /*                   glyph loading process (e.g., whether the outline    */
+  /*                   should be scaled, whether to load bitmaps or not,   */
+  /*                   whether to hint the outline, etc).                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function simply calls @FT_Get_Char_Index and @FT_Load_Glyph.  */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Load_Char( FT_Face   face,
+                FT_ULong  char_code,
+                FT_Int32  load_flags );
+
+
+  /*************************************************************************
+   *
+   * @enum:
+   *   FT_LOAD_XXX
+   *
+   * @description:
+   *   A list of bit-field constants used with @FT_Load_Glyph to indicate
+   *   what kind of operations to perform during glyph loading.
+   *
+   * @values:
+   *   FT_LOAD_DEFAULT ::
+   *     Corresponding to~0, this value is used as the default glyph load
+   *     operation.  In this case, the following happens:
+   *
+   *     1. FreeType looks for a bitmap for the glyph corresponding to the
+   *        face's current size.  If one is found, the function returns.
+   *        The bitmap data can be accessed from the glyph slot (see note
+   *        below).
+   *
+   *     2. If no embedded bitmap is searched or found, FreeType looks for a
+   *        scalable outline.  If one is found, it is loaded from the font
+   *        file, scaled to device pixels, then `hinted' to the pixel grid
+   *        in order to optimize it.  The outline data can be accessed from
+   *        the glyph slot (see note below).
+   *
+   *     Note that by default, the glyph loader doesn't render outlines into
+   *     bitmaps.  The following flags are used to modify this default
+   *     behaviour to more specific and useful cases.
+   *
+   *   FT_LOAD_NO_SCALE ::
+   *     Don't scale the loaded outline glyph but keep it in font units.
+   *
+   *     This flag implies @FT_LOAD_NO_HINTING and @FT_LOAD_NO_BITMAP, and
+   *     unsets @FT_LOAD_RENDER.
+   *
+   *     If the font is `tricky' (see @FT_FACE_FLAG_TRICKY for more), using
+   *     FT_LOAD_NO_SCALE usually yields meaningless outlines because the
+   *     subglyphs must be scaled and positioned with hinting instructions. 
+   *     This can be solved by loading the font without FT_LOAD_NO_SCALE and
+   *     setting the character size to `font->units_per_EM'.
+   *
+   *   FT_LOAD_NO_HINTING ::
+   *     Disable hinting.  This generally generates `blurrier' bitmap glyphs
+   *     when the glyph are rendered in any of the anti-aliased modes.  See
+   *     also the note below.
+   *
+   *     This flag is implied by @FT_LOAD_NO_SCALE.
+   *
+   *   FT_LOAD_RENDER ::
+   *     Call @FT_Render_Glyph after the glyph is loaded.  By default, the
+   *     glyph is rendered in @FT_RENDER_MODE_NORMAL mode.  This can be
+   *     overridden by @FT_LOAD_TARGET_XXX or @FT_LOAD_MONOCHROME.
+   *
+   *     This flag is unset by @FT_LOAD_NO_SCALE.
+   *
+   *   FT_LOAD_NO_BITMAP ::
+   *     Ignore bitmap strikes when loading.  Bitmap-only fonts ignore this
+   *     flag.
+   *
+   *     @FT_LOAD_NO_SCALE always sets this flag.
+   *
+   *   FT_LOAD_VERTICAL_LAYOUT ::
+   *     Load the glyph for vertical text layout.  In particular, the
+   *     `advance' value in the @FT_GlyphSlotRec structure is set to the
+   *     `vertAdvance' value of the `metrics' field.
+   *
+   *     In case @FT_HAS_VERTICAL doesn't return true, you shouldn't use
+   *     this flag currently.  Reason is that in this case vertical metrics
+   *     get synthesized, and those values are not always consistent across
+   *     various font formats.
+   *
+   *   FT_LOAD_FORCE_AUTOHINT ::
+   *     Indicates that the auto-hinter is preferred over the font's native
+   *     hinter.  See also the note below.
+   *
+   *   FT_LOAD_CROP_BITMAP ::
+   *     Indicates that the font driver should crop the loaded bitmap glyph
+   *     (i.e., remove all space around its black bits).  Not all drivers
+   *     implement this.
+   *
+   *   FT_LOAD_PEDANTIC ::
+   *     Indicates that the font driver should perform pedantic verifications
+   *     during glyph loading.  This is mostly used to detect broken glyphs
+   *     in fonts.  By default, FreeType tries to handle broken fonts also.
+   *
+   *     In particular, errors from the TrueType bytecode engine are not
+   *     passed to the application if this flag is not set; this might
+   *     result in partially hinted or distorted glyphs in case a glyph's
+   *     bytecode is buggy.
+   *
+   *   FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH ::
+   *     Ignored.  Deprecated.
+   *
+   *   FT_LOAD_NO_RECURSE ::
+   *     This flag is only used internally.  It merely indicates that the
+   *     font driver should not load composite glyphs recursively.  Instead,
+   *     it should set the `num_subglyph' and `subglyphs' values of the
+   *     glyph slot accordingly, and set `glyph->format' to
+   *     @FT_GLYPH_FORMAT_COMPOSITE.
+   *
+   *     The description of sub-glyphs is not available to client
+   *     applications for now.
+   *
+   *     This flag implies @FT_LOAD_NO_SCALE and @FT_LOAD_IGNORE_TRANSFORM.
+   *
+   *   FT_LOAD_IGNORE_TRANSFORM ::
+   *     Indicates that the transform matrix set by @FT_Set_Transform should
+   *     be ignored.
+   *
+   *   FT_LOAD_MONOCHROME ::
+   *     This flag is used with @FT_LOAD_RENDER to indicate that you want to
+   *     render an outline glyph to a 1-bit monochrome bitmap glyph, with
+   *     8~pixels packed into each byte of the bitmap data.
+   *
+   *     Note that this has no effect on the hinting algorithm used.  You
+   *     should rather use @FT_LOAD_TARGET_MONO so that the
+   *     monochrome-optimized hinting algorithm is used.
+   *
+   *   FT_LOAD_LINEAR_DESIGN ::
+   *     Indicates that the `linearHoriAdvance' and `linearVertAdvance'
+   *     fields of @FT_GlyphSlotRec should be kept in font units.  See
+   *     @FT_GlyphSlotRec for details.
+   *
+   *   FT_LOAD_NO_AUTOHINT ::
+   *     Disable auto-hinter.  See also the note below.
+   *
+   * @note:
+   *   By default, hinting is enabled and the font's native hinter (see
+   *   @FT_FACE_FLAG_HINTER) is preferred over the auto-hinter.  You can
+   *   disable hinting by setting @FT_LOAD_NO_HINTING or change the
+   *   precedence by setting @FT_LOAD_FORCE_AUTOHINT.  You can also set
+   *   @FT_LOAD_NO_AUTOHINT in case you don't want the auto-hinter to be
+   *   used at all.
+   *
+   *   See the description of @FT_FACE_FLAG_TRICKY for a special exception
+   *   (affecting only a handful of Asian fonts).
+   *
+   *   Besides deciding which hinter to use, you can also decide which
+   *   hinting algorithm to use.  See @FT_LOAD_TARGET_XXX for details.
+   *
+   *   Note that the auto-hinter needs a valid Unicode cmap (either a native
+   *   one or synthesized by FreeType) for producing correct results.  If a
+   *   font provides an incorrect mapping (for example, assigning the
+   *   character code U+005A, LATIN CAPITAL LETTER Z, to a glyph depicting a
+   *   mathematical integral sign), the auto-hinter might produce useless
+   *   results.
+   *
+   */
+#define FT_LOAD_DEFAULT                      0x0
+#define FT_LOAD_NO_SCALE                     ( 1L << 0 )
+#define FT_LOAD_NO_HINTING                   ( 1L << 1 )
+#define FT_LOAD_RENDER                       ( 1L << 2 )
+#define FT_LOAD_NO_BITMAP                    ( 1L << 3 )
+#define FT_LOAD_VERTICAL_LAYOUT              ( 1L << 4 )
+#define FT_LOAD_FORCE_AUTOHINT               ( 1L << 5 )
+#define FT_LOAD_CROP_BITMAP                  ( 1L << 6 )
+#define FT_LOAD_PEDANTIC                     ( 1L << 7 )
+#define FT_LOAD_IGNORE_GLOBAL_ADVANCE_WIDTH  ( 1L << 9 )
+#define FT_LOAD_NO_RECURSE                   ( 1L << 10 )
+#define FT_LOAD_IGNORE_TRANSFORM             ( 1L << 11 )
+#define FT_LOAD_MONOCHROME                   ( 1L << 12 )
+#define FT_LOAD_LINEAR_DESIGN                ( 1L << 13 )
+#define FT_LOAD_NO_AUTOHINT                  ( 1L << 15 )
+
+  /* */
+
+  /* used internally only by certain font drivers! */
+#define FT_LOAD_ADVANCE_ONLY                 ( 1L << 8 )
+#define FT_LOAD_SBITS_ONLY                   ( 1L << 14 )
+
+
+  /**************************************************************************
+   *
+   * @enum:
+   *   FT_LOAD_TARGET_XXX
+   *
+   * @description:
+   *   A list of values that are used to select a specific hinting algorithm
+   *   to use by the hinter.  You should OR one of these values to your
+   *   `load_flags' when calling @FT_Load_Glyph.
+   *
+   *   Note that font's native hinters may ignore the hinting algorithm you
+   *   have specified (e.g., the TrueType bytecode interpreter).  You can set
+   *   @FT_LOAD_FORCE_AUTOHINT to ensure that the auto-hinter is used.
+   *
+   *   Also note that @FT_LOAD_TARGET_LIGHT is an exception, in that it
+   *   always implies @FT_LOAD_FORCE_AUTOHINT.
+   *
+   * @values:
+   *   FT_LOAD_TARGET_NORMAL ::
+   *     This corresponds to the default hinting algorithm, optimized for
+   *     standard gray-level rendering.  For monochrome output, use
+   *     @FT_LOAD_TARGET_MONO instead.
+   *
+   *   FT_LOAD_TARGET_LIGHT ::
+   *     A lighter hinting algorithm for non-monochrome modes.  Many
+   *     generated glyphs are more fuzzy but better resemble its original
+   *     shape.  A bit like rendering on Mac OS~X.
+   *
+   *     As a special exception, this target implies @FT_LOAD_FORCE_AUTOHINT.
+   *
+   *   FT_LOAD_TARGET_MONO ::
+   *     Strong hinting algorithm that should only be used for monochrome
+   *     output.  The result is probably unpleasant if the glyph is rendered
+   *     in non-monochrome modes.
+   *
+   *   FT_LOAD_TARGET_LCD ::
+   *     A variant of @FT_LOAD_TARGET_NORMAL optimized for horizontally
+   *     decimated LCD displays.
+   *
+   *   FT_LOAD_TARGET_LCD_V ::
+   *     A variant of @FT_LOAD_TARGET_NORMAL optimized for vertically
+   *     decimated LCD displays.
+   *
+   * @note:
+   *   You should use only _one_ of the FT_LOAD_TARGET_XXX values in your
+   *   `load_flags'.  They can't be ORed.
+   *
+   *   If @FT_LOAD_RENDER is also set, the glyph is rendered in the
+   *   corresponding mode (i.e., the mode which matches the used algorithm
+   *   best).  An exeption is FT_LOAD_TARGET_MONO since it implies
+   *   @FT_LOAD_MONOCHROME.
+   *
+   *   You can use a hinting algorithm that doesn't correspond to the same
+   *   rendering mode.  As an example, it is possible to use the `light'
+   *   hinting algorithm and have the results rendered in horizontal LCD
+   *   pixel mode, with code like
+   *
+   *     {
+   *       FT_Load_Glyph( face, glyph_index,
+   *                      load_flags | FT_LOAD_TARGET_LIGHT );
+   *
+   *       FT_Render_Glyph( face->glyph, FT_RENDER_MODE_LCD );
+   *     }
+   *
+   */
+#define FT_LOAD_TARGET_( x )   ( (FT_Int32)( (x) & 15 ) << 16 )
+
+#define FT_LOAD_TARGET_NORMAL  FT_LOAD_TARGET_( FT_RENDER_MODE_NORMAL )
+#define FT_LOAD_TARGET_LIGHT   FT_LOAD_TARGET_( FT_RENDER_MODE_LIGHT  )
+#define FT_LOAD_TARGET_MONO    FT_LOAD_TARGET_( FT_RENDER_MODE_MONO   )
+#define FT_LOAD_TARGET_LCD     FT_LOAD_TARGET_( FT_RENDER_MODE_LCD    )
+#define FT_LOAD_TARGET_LCD_V   FT_LOAD_TARGET_( FT_RENDER_MODE_LCD_V  )
+
+
+  /**************************************************************************
+   *
+   * @macro:
+   *   FT_LOAD_TARGET_MODE
+   *
+   * @description:
+   *   Return the @FT_Render_Mode corresponding to a given
+   *   @FT_LOAD_TARGET_XXX value.
+   *
+   */
+#define FT_LOAD_TARGET_MODE( x )  ( (FT_Render_Mode)( ( (x) >> 16 ) & 15 ) )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Transform                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to set the transformation that is applied to glyph */
+  /*    images when they are loaded into a glyph slot through              */
+  /*    @FT_Load_Glyph.                                                    */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face   :: A handle to the source face object.                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    matrix :: A pointer to the transformation's 2x2 matrix.  Use~0 for */
+  /*              the identity matrix.                                     */
+  /*    delta  :: A pointer to the translation vector.  Use~0 for the null */
+  /*              vector.                                                  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The transformation is only applied to scalable image formats after */
+  /*    the glyph has been loaded.  It means that hinting is unaltered by  */
+  /*    the transformation and is performed on the character size given in */
+  /*    the last call to @FT_Set_Char_Size or @FT_Set_Pixel_Sizes.         */
+  /*                                                                       */
+  /*    Note that this also transforms the `face.glyph.advance' field, but */
+  /*    *not* the values in `face.glyph.metrics'.                          */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Set_Transform( FT_Face     face,
+                    FT_Matrix*  matrix,
+                    FT_Vector*  delta );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Render_Mode                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration type that lists the render modes supported by       */
+  /*    FreeType~2.  Each mode corresponds to a specific type of scanline  */
+  /*    conversion performed on the outline.                               */
+  /*                                                                       */
+  /*    For bitmap fonts and embedded bitmaps the `bitmap->pixel_mode'     */
+  /*    field in the @FT_GlyphSlotRec structure gives the format of the    */
+  /*    returned bitmap.                                                   */
+  /*                                                                       */
+  /*    All modes except @FT_RENDER_MODE_MONO use 256 levels of opacity.   */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_RENDER_MODE_NORMAL ::                                           */
+  /*      This is the default render mode; it corresponds to 8-bit         */
+  /*      anti-aliased bitmaps.                                            */
+  /*                                                                       */
+  /*    FT_RENDER_MODE_LIGHT ::                                            */
+  /*      This is equivalent to @FT_RENDER_MODE_NORMAL.  It is only        */
+  /*      defined as a separate value because render modes are also used   */
+  /*      indirectly to define hinting algorithm selectors.  See           */
+  /*      @FT_LOAD_TARGET_XXX for details.                                 */
+  /*                                                                       */
+  /*    FT_RENDER_MODE_MONO ::                                             */
+  /*      This mode corresponds to 1-bit bitmaps (with 2~levels of         */
+  /*      opacity).                                                        */
+  /*                                                                       */
+  /*    FT_RENDER_MODE_LCD ::                                              */
+  /*      This mode corresponds to horizontal RGB and BGR sub-pixel        */
+  /*      displays like LCD screens.  It produces 8-bit bitmaps that are   */
+  /*      3~times the width of the original glyph outline in pixels, and   */
+  /*      which use the @FT_PIXEL_MODE_LCD mode.                           */
+  /*                                                                       */
+  /*    FT_RENDER_MODE_LCD_V ::                                            */
+  /*      This mode corresponds to vertical RGB and BGR sub-pixel displays */
+  /*      (like PDA screens, rotated LCD displays, etc.).  It produces     */
+  /*      8-bit bitmaps that are 3~times the height of the original        */
+  /*      glyph outline in pixels and use the @FT_PIXEL_MODE_LCD_V mode.   */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The LCD-optimized glyph bitmaps produced by FT_Render_Glyph can be */
+  /*    filtered to reduce color-fringes by using @FT_Library_SetLcdFilter */
+  /*    (not active in the default builds).  It is up to the caller to     */
+  /*    either call @FT_Library_SetLcdFilter (if available) or do the      */
+  /*    filtering itself.                                                  */
+  /*                                                                       */
+  /*    The selected render mode only affects vector glyphs of a font.     */
+  /*    Embedded bitmaps often have a different pixel mode like            */
+  /*    @FT_PIXEL_MODE_MONO.  You can use @FT_Bitmap_Convert to transform  */
+  /*    them into 8-bit pixmaps.                                           */
+  /*                                                                       */
+  typedef enum  FT_Render_Mode_
+  {
+    FT_RENDER_MODE_NORMAL = 0,
+    FT_RENDER_MODE_LIGHT,
+    FT_RENDER_MODE_MONO,
+    FT_RENDER_MODE_LCD,
+    FT_RENDER_MODE_LCD_V,
+
+    FT_RENDER_MODE_MAX
+
+  } FT_Render_Mode;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    ft_render_mode_xxx                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    These constants are deprecated.  Use the corresponding             */
+  /*    @FT_Render_Mode values instead.                                    */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    ft_render_mode_normal :: see @FT_RENDER_MODE_NORMAL                */
+  /*    ft_render_mode_mono   :: see @FT_RENDER_MODE_MONO                  */
+  /*                                                                       */
+#define ft_render_mode_normal  FT_RENDER_MODE_NORMAL
+#define ft_render_mode_mono    FT_RENDER_MODE_MONO
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Render_Glyph                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Convert a given glyph image to a bitmap.  It does so by inspecting */
+  /*    the glyph image format, finding the relevant renderer, and         */
+  /*    invoking it.                                                       */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    slot        :: A handle to the glyph slot containing the image to  */
+  /*                   convert.                                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    render_mode :: This is the render mode used to render the glyph    */
+  /*                   image into a bitmap.  See @FT_Render_Mode for a     */
+  /*                   list of possible values.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Render_Glyph( FT_GlyphSlot    slot,
+                   FT_Render_Mode  render_mode );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Kerning_Mode                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration used to specify which kerning values to return in   */
+  /*    @FT_Get_Kerning.                                                   */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_KERNING_DEFAULT  :: Return scaled and grid-fitted kerning       */
+  /*                           distances (value is~0).                     */
+  /*                                                                       */
+  /*    FT_KERNING_UNFITTED :: Return scaled but un-grid-fitted kerning    */
+  /*                           distances.                                  */
+  /*                                                                       */
+  /*    FT_KERNING_UNSCALED :: Return the kerning vector in original font  */
+  /*                           units.                                      */
+  /*                                                                       */
+  typedef enum  FT_Kerning_Mode_
+  {
+    FT_KERNING_DEFAULT  = 0,
+    FT_KERNING_UNFITTED,
+    FT_KERNING_UNSCALED
+
+  } FT_Kerning_Mode;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Const>                                                               */
+  /*    ft_kerning_default                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This constant is deprecated.  Please use @FT_KERNING_DEFAULT       */
+  /*    instead.                                                           */
+  /*                                                                       */
+#define ft_kerning_default   FT_KERNING_DEFAULT
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Const>                                                               */
+  /*    ft_kerning_unfitted                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This constant is deprecated.  Please use @FT_KERNING_UNFITTED      */
+  /*    instead.                                                           */
+  /*                                                                       */
+#define ft_kerning_unfitted  FT_KERNING_UNFITTED
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Const>                                                               */
+  /*    ft_kerning_unscaled                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This constant is deprecated.  Please use @FT_KERNING_UNSCALED      */
+  /*    instead.                                                           */
+  /*                                                                       */
+#define ft_kerning_unscaled  FT_KERNING_UNSCALED
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Kerning                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the kerning vector between two glyphs of a same face.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face        :: A handle to a source face object.                   */
+  /*                                                                       */
+  /*    left_glyph  :: The index of the left glyph in the kern pair.       */
+  /*                                                                       */
+  /*    right_glyph :: The index of the right glyph in the kern pair.      */
+  /*                                                                       */
+  /*    kern_mode   :: See @FT_Kerning_Mode for more information.          */
+  /*                   Determines the scale and dimension of the returned  */
+  /*                   kerning vector.                                     */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    akerning    :: The kerning vector.  This is either in font units   */
+  /*                   or in pixels (26.6 format) for scalable formats,    */
+  /*                   and in pixels for fixed-sizes formats.              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Only horizontal layouts (left-to-right & right-to-left) are        */
+  /*    supported by this method.  Other layouts, or more sophisticated    */
+  /*    kernings, are out of the scope of this API function -- they can be */
+  /*    implemented through format-specific interfaces.                    */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Kerning( FT_Face     face,
+                  FT_UInt     left_glyph,
+                  FT_UInt     right_glyph,
+                  FT_UInt     kern_mode,
+                  FT_Vector  *akerning );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Track_Kerning                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the track kerning for a given face object at a given size.  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face       :: A handle to a source face object.                    */
+  /*                                                                       */
+  /*    point_size :: The point size in 16.16 fractional points.           */
+  /*                                                                       */
+  /*    degree     :: The degree of tightness.  Increasingly negative      */
+  /*                  values represent tighter track kerning, while        */
+  /*                  increasingly positive values represent looser track  */
+  /*                  kerning.  Value zero means no track kerning.         */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    akerning   :: The kerning in 16.16 fractional points, to be        */
+  /*                  uniformly applied between all glyphs.                */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Currently, only the Type~1 font driver supports track kerning,     */
+  /*    using data from AFM files (if attached with @FT_Attach_File or     */
+  /*    @FT_Attach_Stream).                                                */
+  /*                                                                       */
+  /*    Only very few AFM files come with track kerning data; please refer */
+  /*    to the Adobe's AFM specification for more details.                 */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Track_Kerning( FT_Face    face,
+                        FT_Fixed   point_size,
+                        FT_Int     degree,
+                        FT_Fixed*  akerning );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Glyph_Name                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the ASCII name of a given glyph in a face.  This only     */
+  /*    works for those faces where @FT_HAS_GLYPH_NAMES(face) returns~1.   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face        :: A handle to a source face object.                   */
+  /*                                                                       */
+  /*    glyph_index :: The glyph index.                                    */
+  /*                                                                       */
+  /*    buffer_max  :: The maximum number of bytes available in the        */
+  /*                   buffer.                                             */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    buffer      :: A pointer to a target buffer where the name is      */
+  /*                   copied to.                                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    An error is returned if the face doesn't provide glyph names or if */
+  /*    the glyph index is invalid.  In all cases of failure, the first    */
+  /*    byte of `buffer' is set to~0 to indicate an empty name.            */
+  /*                                                                       */
+  /*    The glyph name is truncated to fit within the buffer if it is too  */
+  /*    long.  The returned string is always zero-terminated.              */
+  /*                                                                       */
+  /*    Be aware that FreeType reorders glyph indices internally so that   */
+  /*    glyph index~0 always corresponds to the `missing glyph' (called    */
+  /*    `.notdef').                                                        */
+  /*                                                                       */
+  /*    This function is not compiled within the library if the config     */
+  /*    macro `FT_CONFIG_OPTION_NO_GLYPH_NAMES' is defined in              */
+  /*    `include/freetype/config/ftoptions.h'.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Glyph_Name( FT_Face     face,
+                     FT_UInt     glyph_index,
+                     FT_Pointer  buffer,
+                     FT_UInt     buffer_max );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Postscript_Name                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the ASCII PostScript name of a given face, if available.  */
+  /*    This only works with PostScript and TrueType fonts.                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the source face object.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A pointer to the face's PostScript name.  NULL if unavailable.     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The returned pointer is owned by the face and is destroyed with    */
+  /*    it.                                                                */
+  /*                                                                       */
+  FT_EXPORT( const char* )
+  FT_Get_Postscript_Name( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Select_Charmap                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Select a given charmap by its encoding tag (as listed in           */
+  /*    `freetype.h').                                                     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face     :: A handle to the source face object.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    encoding :: A handle to the selected encoding.                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function returns an error if no charmap in the face           */
+  /*    corresponds to the encoding queried here.                          */
+  /*                                                                       */
+  /*    Because many fonts contain more than a single cmap for Unicode     */
+  /*    encoding, this function has some special code to select the one    */
+  /*    which covers Unicode best (`best' in the sense that a UCS-4 cmap   */
+  /*    is preferred to a UCS-2 cmap).  It is thus preferable to           */
+  /*    @FT_Set_Charmap in this case.                                      */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Select_Charmap( FT_Face      face,
+                     FT_Encoding  encoding );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Charmap                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Select a given charmap for character code to glyph index mapping.  */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face    :: A handle to the source face object.                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    charmap :: A handle to the selected charmap.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function returns an error if the charmap is not part of       */
+  /*    the face (i.e., if it is not listed in the `face->charmaps'        */
+  /*    table).                                                            */
+  /*                                                                       */
+  /*    It also fails if a type~14 charmap is selected.                    */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_Charmap( FT_Face     face,
+                  FT_CharMap  charmap );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Get_Charmap_Index
+   *
+   * @description:
+   *   Retrieve index of a given charmap.
+   *
+   * @input:
+   *   charmap ::
+   *     A handle to a charmap.
+   *
+   * @return:
+   *   The index into the array of character maps within the face to which
+   *   `charmap' belongs.  If an error occurs, -1 is returned.
+   *
+   */
+  FT_EXPORT( FT_Int )
+  FT_Get_Charmap_Index( FT_CharMap  charmap );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Char_Index                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the glyph index of a given character code.  This function   */
+  /*    uses a charmap object to do the mapping.                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face     :: A handle to the source face object.                    */
+  /*                                                                       */
+  /*    charcode :: The character code.                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The glyph index.  0~means `undefined character code'.              */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If you use FreeType to manipulate the contents of font files       */
+  /*    directly, be aware that the glyph index returned by this function  */
+  /*    doesn't always correspond to the internal indices used within the  */
+  /*    file.  This is done to ensure that value~0 always corresponds to   */
+  /*    the `missing glyph'.  If the first glyph is not named `.notdef',   */
+  /*    then for Type~1 and Type~42 fonts, `.notdef' will be moved into    */
+  /*    the glyph ID~0 position, and whatever was there will be moved to   */
+  /*    the position `.notdef' had.  For Type~1 fonts, if there is no      */
+  /*    `.notdef' glyph at all, then one will be created at index~0 and    */
+  /*    whatever was there will be moved to the last index -- Type~42      */
+  /*    fonts are considered invalid under this condition.                 */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt )
+  FT_Get_Char_Index( FT_Face   face,
+                     FT_ULong  charcode );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_First_Char                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function is used to return the first character code in the    */
+  /*    current charmap of a given face.  It also returns the              */
+  /*    corresponding glyph index.                                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face    :: A handle to the source face object.                     */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    agindex :: Glyph index of first character code.  0~if charmap is   */
+  /*               empty.                                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The charmap's first character code.                                */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You should use this function with @FT_Get_Next_Char to be able to  */
+  /*    parse all character codes available in a given charmap.  The code  */
+  /*    should look like this:                                             */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      FT_ULong  charcode;                                              */
+  /*      FT_UInt   gindex;                                                */
+  /*                                                                       */
+  /*                                                                       */
+  /*      charcode = FT_Get_First_Char( face, &gindex );                   */
+  /*      while ( gindex != 0 )                                            */
+  /*      {                                                                */
+  /*        ... do something with (charcode,gindex) pair ...               */
+  /*                                                                       */
+  /*        charcode = FT_Get_Next_Char( face, charcode, &gindex );        */
+  /*      }                                                                */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    Note that `*agindex' is set to~0 if the charmap is empty.  The     */
+  /*    result itself can be~0 in two cases: if the charmap is empty or    */
+  /*    if the value~0 is the first valid character code.                  */
+  /*                                                                       */
+  FT_EXPORT( FT_ULong )
+  FT_Get_First_Char( FT_Face   face,
+                     FT_UInt  *agindex );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Next_Char                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function is used to return the next character code in the     */
+  /*    current charmap of a given face following the value `char_code',   */
+  /*    as well as the corresponding glyph index.                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face      :: A handle to the source face object.                   */
+  /*    char_code :: The starting character code.                          */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    agindex   :: Glyph index of next character code.  0~if charmap     */
+  /*                 is empty.                                             */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The charmap's next character code.                                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You should use this function with @FT_Get_First_Char to walk       */
+  /*    over all character codes available in a given charmap.  See the    */
+  /*    note for this function for a simple code example.                  */
+  /*                                                                       */
+  /*    Note that `*agindex' is set to~0 when there are no more codes in   */
+  /*    the charmap.                                                       */
+  /*                                                                       */
+  FT_EXPORT( FT_ULong )
+  FT_Get_Next_Char( FT_Face    face,
+                    FT_ULong   char_code,
+                    FT_UInt   *agindex );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Name_Index                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the glyph index of a given glyph name.  This function uses  */
+  /*    driver specific objects to do the translation.                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face       :: A handle to the source face object.                  */
+  /*                                                                       */
+  /*    glyph_name :: The glyph name.                                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The glyph index.  0~means `undefined character code'.              */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt )
+  FT_Get_Name_Index( FT_Face     face,
+                     FT_String*  glyph_name );
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_SUBGLYPH_FLAG_XXX
+   *
+   * @description:
+   *   A list of constants used to describe subglyphs.  Please refer to the
+   *   TrueType specification for the meaning of the various flags.
+   *
+   * @values:
+   *   FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS ::
+   *   FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES ::
+   *   FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID ::
+   *   FT_SUBGLYPH_FLAG_SCALE ::
+   *   FT_SUBGLYPH_FLAG_XY_SCALE ::
+   *   FT_SUBGLYPH_FLAG_2X2 ::
+   *   FT_SUBGLYPH_FLAG_USE_MY_METRICS ::
+   *
+   */
+#define FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS          1
+#define FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES      2
+#define FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID        4
+#define FT_SUBGLYPH_FLAG_SCALE                   8
+#define FT_SUBGLYPH_FLAG_XY_SCALE             0x40
+#define FT_SUBGLYPH_FLAG_2X2                  0x80
+#define FT_SUBGLYPH_FLAG_USE_MY_METRICS      0x200
+
+
+  /*************************************************************************
+   *
+   * @func:
+   *   FT_Get_SubGlyph_Info
+   *
+   * @description:
+   *   Retrieve a description of a given subglyph.  Only use it if
+   *   `glyph->format' is @FT_GLYPH_FORMAT_COMPOSITE; an error is
+   *   returned otherwise.
+   *
+   * @input:
+   *   glyph ::
+   *     The source glyph slot.
+   *
+   *   sub_index ::
+   *     The index of the subglyph.  Must be less than
+   *     `glyph->num_subglyphs'.
+   *
+   * @output:
+   *   p_index ::
+   *     The glyph index of the subglyph.
+   *
+   *   p_flags ::
+   *     The subglyph flags, see @FT_SUBGLYPH_FLAG_XXX.
+   *
+   *   p_arg1 ::
+   *     The subglyph's first argument (if any).
+   *
+   *   p_arg2 ::
+   *     The subglyph's second argument (if any).
+   *
+   *   p_transform ::
+   *     The subglyph transformation (if any).
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   The values of `*p_arg1', `*p_arg2', and `*p_transform' must be
+   *   interpreted depending on the flags returned in `*p_flags'.  See the
+   *   TrueType specification for details.
+   *
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_SubGlyph_Info( FT_GlyphSlot  glyph,
+                        FT_UInt       sub_index,
+                        FT_Int       *p_index,
+                        FT_UInt      *p_flags,
+                        FT_Int       *p_arg1,
+                        FT_Int       *p_arg2,
+                        FT_Matrix    *p_transform );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_FSTYPE_XXX                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of bit flags used in the `fsType' field of the OS/2 table   */
+  /*    in a TrueType or OpenType font and the `FSType' entry in a         */
+  /*    PostScript font.  These bit flags are returned by                  */
+  /*    @FT_Get_FSType_Flags; they inform client applications of embedding */
+  /*    and subsetting restrictions associated with a font.                */
+  /*                                                                       */
+  /*    See http://www.adobe.com/devnet/acrobat/pdfs/FontPolicies.pdf for  */
+  /*    more details.                                                      */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_FSTYPE_INSTALLABLE_EMBEDDING ::                                 */
+  /*      Fonts with no fsType bit set may be embedded and permanently     */
+  /*      installed on the remote system by an application.                */
+  /*                                                                       */
+  /*    FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING ::                          */
+  /*      Fonts that have only this bit set must not be modified, embedded */
+  /*      or exchanged in any manner without first obtaining permission of */
+  /*      the font software copyright owner.                               */
+  /*                                                                       */
+  /*    FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING ::                           */
+  /*      If this bit is set, the font may be embedded and temporarily     */
+  /*      loaded on the remote system.  Documents containing Preview &     */
+  /*      Print fonts must be opened `read-only'; no edits can be applied  */
+  /*      to the document.                                                 */
+  /*                                                                       */
+  /*    FT_FSTYPE_EDITABLE_EMBEDDING ::                                    */
+  /*      If this bit is set, the font may be embedded but must only be    */
+  /*      installed temporarily on other systems.  In contrast to Preview  */
+  /*      & Print fonts, documents containing editable fonts may be opened */
+  /*      for reading, editing is permitted, and changes may be saved.     */
+  /*                                                                       */
+  /*    FT_FSTYPE_NO_SUBSETTING ::                                         */
+  /*      If this bit is set, the font may not be subsetted prior to       */
+  /*      embedding.                                                       */
+  /*                                                                       */
+  /*    FT_FSTYPE_BITMAP_EMBEDDING_ONLY ::                                 */
+  /*      If this bit is set, only bitmaps contained in the font may be    */
+  /*      embedded; no outline data may be embedded.  If there are no      */
+  /*      bitmaps available in the font, then the font is unembeddable.    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    While the fsType flags can indicate that a font may be embedded, a */
+  /*    license with the font vendor may be separately required to use the */
+  /*    font in this way.                                                  */
+  /*                                                                       */
+#define FT_FSTYPE_INSTALLABLE_EMBEDDING         0x0000
+#define FT_FSTYPE_RESTRICTED_LICENSE_EMBEDDING  0x0002
+#define FT_FSTYPE_PREVIEW_AND_PRINT_EMBEDDING   0x0004
+#define FT_FSTYPE_EDITABLE_EMBEDDING            0x0008
+#define FT_FSTYPE_NO_SUBSETTING                 0x0100
+#define FT_FSTYPE_BITMAP_EMBEDDING_ONLY         0x0200
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_FSType_Flags                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the fsType flags for a font.                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the source face object.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The fsType flags, @FT_FSTYPE_XXX.                                  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Use this function rather than directly reading the `fs_type' field */
+  /*    in the @PS_FontInfoRec structure which is only guaranteed to       */
+  /*    return the correct results for Type~1 fonts.                       */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.8                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_UShort )
+  FT_Get_FSType_Flags( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    glyph_variants                                                     */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Glyph Variants                                                     */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    The FreeType~2 interface to Unicode Ideographic Variation          */
+  /*    Sequences (IVS), using the SFNT cmap format~14.                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Many CJK characters have variant forms.  They are a sort of grey   */
+  /*    area somewhere between being totally irrelevant and semantically   */
+  /*    distinct; for this reason, the Unicode consortium decided to       */
+  /*    introduce Ideographic Variation Sequences (IVS), consisting of a   */
+  /*    Unicode base character and one of 240 variant selectors            */
+  /*    (U+E0100-U+E01EF), instead of further extending the already huge   */
+  /*    code range for CJK characters.                                     */
+  /*                                                                       */
+  /*    An IVS is registered and unique; for further details please refer  */
+  /*    to Unicode Technical Standard #37, the Ideographic Variation       */
+  /*    Database:                                                          */
+  /*                                                                       */
+  /*      http://www.unicode.org/reports/tr37/                             */
+  /*                                                                       */
+  /*    To date (November 2012), the character with the most variants is   */
+  /*    U+9089, having 31 such IVS.                                        */
+  /*                                                                       */
+  /*    Adobe and MS decided to support IVS with a new cmap subtable       */
+  /*    (format~14).  It is an odd subtable because it is not a mapping of */
+  /*    input code points to glyphs, but contains lists of all variants    */
+  /*    supported by the font.                                             */
+  /*                                                                       */
+  /*    A variant may be either `default' or `non-default'.  A default     */
+  /*    variant is the one you will get for that code point if you look it */
+  /*    up in the standard Unicode cmap.  A non-default variant is a       */
+  /*    different glyph.                                                   */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_GetCharVariantIndex                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the glyph index of a given character code as modified by    */
+  /*    the variation selector.                                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face ::                                                            */
+  /*      A handle to the source face object.                              */
+  /*                                                                       */
+  /*    charcode ::                                                        */
+  /*      The character code point in Unicode.                             */
+  /*                                                                       */
+  /*    variantSelector ::                                                 */
+  /*      The Unicode code point of the variation selector.                */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The glyph index.  0~means either `undefined character code', or    */
+  /*    `undefined selector code', or `no variation selector cmap          */
+  /*    subtable', or `current CharMap is not Unicode'.                    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If you use FreeType to manipulate the contents of font files       */
+  /*    directly, be aware that the glyph index returned by this function  */
+  /*    doesn't always correspond to the internal indices used within      */
+  /*    the file.  This is done to ensure that value~0 always corresponds  */
+  /*    to the `missing glyph'.                                            */
+  /*                                                                       */
+  /*    This function is only meaningful if                                */
+  /*      a) the font has a variation selector cmap sub table,             */
+  /*    and                                                                */
+  /*      b) the current charmap has a Unicode encoding.                   */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.6                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt )
+  FT_Face_GetCharVariantIndex( FT_Face   face,
+                               FT_ULong  charcode,
+                               FT_ULong  variantSelector );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_GetCharVariantIsDefault                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Check whether this variant of this Unicode character is the one to */
+  /*    be found in the `cmap'.                                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face ::                                                            */
+  /*      A handle to the source face object.                              */
+  /*                                                                       */
+  /*    charcode ::                                                        */
+  /*      The character codepoint in Unicode.                              */
+  /*                                                                       */
+  /*    variantSelector ::                                                 */
+  /*      The Unicode codepoint of the variation selector.                 */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    1~if found in the standard (Unicode) cmap, 0~if found in the       */
+  /*    variation selector cmap, or -1 if it is not a variant.             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function is only meaningful if the font has a variation       */
+  /*    selector cmap subtable.                                            */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.6                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_Int )
+  FT_Face_GetCharVariantIsDefault( FT_Face   face,
+                                   FT_ULong  charcode,
+                                   FT_ULong  variantSelector );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_GetVariantSelectors                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return a zero-terminated list of Unicode variant selectors found   */
+  /*    in the font.                                                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face ::                                                            */
+  /*      A handle to the source face object.                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A pointer to an array of selector code points, or NULL if there is */
+  /*    no valid variant selector cmap subtable.                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The last item in the array is~0; the array is owned by the         */
+  /*    @FT_Face object but can be overwritten or released on the next     */
+  /*    call to a FreeType function.                                       */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.6                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt32* )
+  FT_Face_GetVariantSelectors( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_GetVariantsOfChar                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return a zero-terminated list of Unicode variant selectors found   */
+  /*    for the specified character code.                                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face ::                                                            */
+  /*      A handle to the source face object.                              */
+  /*                                                                       */
+  /*    charcode ::                                                        */
+  /*      The character codepoint in Unicode.                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A pointer to an array of variant selector code points which are    */
+  /*    active for the given character, or NULL if the corresponding list  */
+  /*    is empty.                                                          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The last item in the array is~0; the array is owned by the         */
+  /*    @FT_Face object but can be overwritten or released on the next     */
+  /*    call to a FreeType function.                                       */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.6                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt32* )
+  FT_Face_GetVariantsOfChar( FT_Face   face,
+                             FT_ULong  charcode );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_GetCharsOfVariant                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return a zero-terminated list of Unicode character codes found for */
+  /*    the specified variant selector.                                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face ::                                                            */
+  /*      A handle to the source face object.                              */
+  /*                                                                       */
+  /*    variantSelector ::                                                 */
+  /*      The variant selector code point in Unicode.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A list of all the code points which are specified by this selector */
+  /*    (both default and non-default codes are returned) or NULL if there */
+  /*    is no valid cmap or the variant selector is invalid.               */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The last item in the array is~0; the array is owned by the         */
+  /*    @FT_Face object but can be overwritten or released on the next     */
+  /*    call to a FreeType function.                                       */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.6                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt32* )
+  FT_Face_GetCharsOfVariant( FT_Face   face,
+                             FT_ULong  variantSelector );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    computations                                                       */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Computations                                                       */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Crunching fixed numbers and vectors.                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains various functions used to perform            */
+  /*    computations on 16.16 fixed-float numbers or 2d vectors.           */
+  /*                                                                       */
+  /* <Order>                                                               */
+  /*    FT_MulDiv                                                          */
+  /*    FT_MulFix                                                          */
+  /*    FT_DivFix                                                          */
+  /*    FT_RoundFix                                                        */
+  /*    FT_CeilFix                                                         */
+  /*    FT_FloorFix                                                        */
+  /*    FT_Vector_Transform                                                */
+  /*    FT_Matrix_Multiply                                                 */
+  /*    FT_Matrix_Invert                                                   */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_MulDiv                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to perform the computation `(a*b)/c'   */
+  /*    with maximum accuracy (it uses a 64-bit intermediate integer       */
+  /*    whenever necessary).                                               */
+  /*                                                                       */
+  /*    This function isn't necessarily as fast as some processor specific */
+  /*    operations, but is at least completely portable.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The first multiplier.                                         */
+  /*    b :: The second multiplier.                                        */
+  /*    c :: The divisor.                                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `(a*b)/c'.  This function never traps when trying to */
+  /*    divide by zero; it simply returns `MaxInt' or `MinInt' depending   */
+  /*    on the signs of `a' and `b'.                                       */
+  /*                                                                       */
+  FT_EXPORT( FT_Long )
+  FT_MulDiv( FT_Long  a,
+             FT_Long  b,
+             FT_Long  c );
+
+
+  /* */
+
+  /* The following #if 0 ... #endif is for the documentation formatter, */
+  /* hiding the internal `FT_MULFIX_INLINED' macro.                     */
+
+#if 0
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_MulFix                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to perform the computation             */
+  /*    `(a*b)/0x10000' with maximum accuracy.  Most of the time this is   */
+  /*    used to multiply a given value by a 16.16 fixed float factor.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The first multiplier.                                         */
+  /*    b :: The second multiplier.  Use a 16.16 factor here whenever      */
+  /*         possible (see note below).                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `(a*b)/0x10000'.                                     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function has been optimized for the case where the absolute   */
+  /*    value of `a' is less than 2048, and `b' is a 16.16 scaling factor. */
+  /*    As this happens mainly when scaling from notional units to         */
+  /*    fractional pixels in FreeType, it resulted in noticeable speed     */
+  /*    improvements between versions 2.x and 1.x.                         */
+  /*                                                                       */
+  /*    As a conclusion, always try to place a 16.16 factor as the         */
+  /*    _second_ argument of this function; this can make a great          */
+  /*    difference.                                                        */
+  /*                                                                       */
+  FT_EXPORT( FT_Long )
+  FT_MulFix( FT_Long  a,
+             FT_Long  b );
+
+  /* */
+#endif
+
+#ifdef FT_MULFIX_INLINED
+#define FT_MulFix( a, b )  FT_MULFIX_INLINED( a, b )
+#else
+  FT_EXPORT( FT_Long )
+  FT_MulFix( FT_Long  a,
+             FT_Long  b );
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_DivFix                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to perform the computation             */
+  /*    `(a*0x10000)/b' with maximum accuracy.  Most of the time, this is  */
+  /*    used to divide a given value by a 16.16 fixed float factor.        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The first multiplier.                                         */
+  /*    b :: The second multiplier.  Use a 16.16 factor here whenever      */
+  /*         possible (see note below).                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `(a*0x10000)/b'.                                     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The optimization for FT_DivFix() is simple: If (a~<<~16) fits in   */
+  /*    32~bits, then the division is computed directly.  Otherwise, we    */
+  /*    use a specialized version of @FT_MulDiv.                           */
+  /*                                                                       */
+  FT_EXPORT( FT_Long )
+  FT_DivFix( FT_Long  a,
+             FT_Long  b );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_RoundFix                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to round a 16.16 fixed number.         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The number to be rounded.                                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `(a + 0x8000) & -0x10000'.                           */
+  /*                                                                       */
+  FT_EXPORT( FT_Fixed )
+  FT_RoundFix( FT_Fixed  a );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_CeilFix                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to compute the ceiling function of a   */
+  /*    16.16 fixed number.                                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The number for which the ceiling function is to be computed.  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `(a + 0x10000 - 1) & -0x10000'.                      */
+  /*                                                                       */
+  FT_EXPORT( FT_Fixed )
+  FT_CeilFix( FT_Fixed  a );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_FloorFix                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to compute the floor function of a     */
+  /*    16.16 fixed number.                                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The number for which the floor function is to be computed.    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `a & -0x10000'.                                      */
+  /*                                                                       */
+  FT_EXPORT( FT_Fixed )
+  FT_FloorFix( FT_Fixed  a );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Vector_Transform                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Transform a single vector through a 2x2 matrix.                    */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    vector :: The target vector to transform.                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    matrix :: A pointer to the source 2x2 matrix.                      */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The result is undefined if either `vector' or `matrix' is invalid. */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Vector_Transform( FT_Vector*        vec,
+                       const FT_Matrix*  matrix );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    version                                                            */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    FreeType Version                                                   */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Functions and macros related to FreeType versions.                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Note that those functions and macros are of limited use because    */
+  /*    even a new release of FreeType with only documentation changes     */
+  /*    increases the version number.                                      */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @enum:
+   *   FREETYPE_XXX
+   *
+   * @description:
+   *   These three macros identify the FreeType source code version.
+   *   Use @FT_Library_Version to access them at runtime.
+   *
+   * @values:
+   *   FREETYPE_MAJOR :: The major version number.
+   *   FREETYPE_MINOR :: The minor version number.
+   *   FREETYPE_PATCH :: The patch level.
+   *
+   * @note:
+   *   The version number of FreeType if built as a dynamic link library
+   *   with the `libtool' package is _not_ controlled by these three
+   *   macros.
+   *
+   */
+#define FREETYPE_MAJOR  2
+#define FREETYPE_MINOR  4
+#define FREETYPE_PATCH  11
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Library_Version                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the version of the FreeType library being used.  This is    */
+  /*    useful when dynamically linking to the library, since one cannot   */
+  /*    use the macros @FREETYPE_MAJOR, @FREETYPE_MINOR, and               */
+  /*    @FREETYPE_PATCH.                                                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A source library handle.                                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    amajor  :: The major version number.                               */
+  /*                                                                       */
+  /*    aminor  :: The minor version number.                               */
+  /*                                                                       */
+  /*    apatch  :: The patch version number.                               */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The reason why this function takes a `library' argument is because */
+  /*    certain programs implement library initialization in a custom way  */
+  /*    that doesn't use @FT_Init_FreeType.                                */
+  /*                                                                       */
+  /*    In such cases, the library version might not be available before   */
+  /*    the library object has been created.                               */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Library_Version( FT_Library   library,
+                      FT_Int      *amajor,
+                      FT_Int      *aminor,
+                      FT_Int      *apatch );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_CheckTrueTypePatents                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Parse all bytecode instructions of a TrueType font file to check   */
+  /*    whether any of the patented opcodes are used.  This is only useful */
+  /*    if you want to be able to use the unpatented hinter with           */
+  /*    fonts that do *not* use these opcodes.                             */
+  /*                                                                       */
+  /*    Note that this function parses *all* glyph instructions in the     */
+  /*    font file, which may be slow.                                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A face handle.                                             */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    1~if this is a TrueType font that uses one of the patented         */
+  /*    opcodes, 0~otherwise.                                              */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Since May 2010, TrueType hinting is no longer patented.            */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.5                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_Bool )
+  FT_Face_CheckTrueTypePatents( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Face_SetUnpatentedHinting                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Enable or disable the unpatented hinter for a given face.          */
+  /*    Only enable it if you have determined that the face doesn't        */
+  /*    use any patented opcodes (see @FT_Face_CheckTrueTypePatents).      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face  :: A face handle.                                            */
+  /*                                                                       */
+  /*    value :: New boolean setting.                                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The old setting value.  This will always be false if this is not   */
+  /*    an SFNT font, or if the unpatented hinter is not compiled in this  */
+  /*    instance of the library.                                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Since May 2010, TrueType hinting is no longer patented.            */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.3.5                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_Bool )
+  FT_Face_SetUnpatentedHinting( FT_Face  face,
+                                FT_Bool  value );
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FREETYPE_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftadvanc.h b/include/freetype/ftadvanc.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftadvanc.h
@@ -0,0 +1,179 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftadvanc.h                                                             */
+/*                                                                         */
+/*    Quick computation of advance widths (specification only).            */
+/*                                                                         */
+/*  Copyright 2008 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTADVANC_H__
+#define __FTADVANC_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /**************************************************************************
+   *
+   * @section:
+   *   quick_advance
+   *
+   * @title:
+   *   Quick retrieval of advance values
+   *
+   * @abstract:
+   *   Retrieve horizontal and vertical advance values without processing
+   *   glyph outlines, if possible.
+   *
+   * @description:
+   *   This section contains functions to quickly extract advance values
+   *   without handling glyph outlines, if possible.
+   */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Const>                                                               */
+  /*    FT_ADVANCE_FLAG_FAST_ONLY                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A bit-flag to be OR-ed with the `flags' parameter of the           */
+  /*    @FT_Get_Advance and @FT_Get_Advances functions.                    */
+  /*                                                                       */
+  /*    If set, it indicates that you want these functions to fail if the  */
+  /*    corresponding hinting mode or font driver doesn't allow for very   */
+  /*    quick advance computation.                                         */
+  /*                                                                       */
+  /*    Typically, glyphs which are either unscaled, unhinted, bitmapped,  */
+  /*    or light-hinted can have their advance width computed very         */
+  /*    quickly.                                                           */
+  /*                                                                       */
+  /*    Normal and bytecode hinted modes, which require loading, scaling,  */
+  /*    and hinting of the glyph outline, are extremely slow by            */
+  /*    comparison.                                                        */
+  /*                                                                       */
+#define FT_ADVANCE_FLAG_FAST_ONLY  0x20000000UL
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Advance                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the advance value of a given glyph outline in an          */
+  /*    @FT_Face.  By default, the unhinted advance is returned in font    */
+  /*    units.                                                             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face       :: The source @FT_Face handle.                          */
+  /*                                                                       */
+  /*    gindex     :: The glyph index.                                     */
+  /*                                                                       */
+  /*    load_flags :: A set of bit flags similar to those used when        */
+  /*                  calling @FT_Load_Glyph, used to determine what kind  */
+  /*                  of advances you need.                                */
+  /* <Output>                                                              */
+  /*    padvance :: The advance value, in either font units or 16.16       */
+  /*                format.                                                */
+  /*                                                                       */
+  /*                If @FT_LOAD_VERTICAL_LAYOUT is set, this is the        */
+  /*                vertical advance corresponding to a vertical layout.   */
+  /*                Otherwise, it is the horizontal advance in a           */
+  /*                horizontal layout.                                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function may fail if you use @FT_ADVANCE_FLAG_FAST_ONLY and   */
+  /*    if the corresponding font backend doesn't have a quick way to      */
+  /*    retrieve the advances.                                             */
+  /*                                                                       */
+  /*    A scaled advance is returned in 16.16 format but isn't transformed */
+  /*    by the affine transformation specified by @FT_Set_Transform.       */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Advance( FT_Face    face,
+                  FT_UInt    gindex,
+                  FT_Int32   load_flags,
+                  FT_Fixed  *padvance );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Advances                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the advance values of several glyph outlines in an        */
+  /*    @FT_Face.  By default, the unhinted advances are returned in font  */
+  /*    units.                                                             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face        :: The source @FT_Face handle.                         */
+  /*                                                                       */
+  /*    start       :: The first glyph index.                              */
+  /*                                                                       */
+  /*    count       :: The number of advance values you want to retrieve.  */
+  /*                                                                       */
+  /*    load_flags  :: A set of bit flags similar to those used when       */
+  /*                   calling @FT_Load_Glyph.                             */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    padvance :: The advances, in either font units or 16.16 format.    */
+  /*                This array must contain at least `count' elements.     */
+  /*                                                                       */
+  /*                If @FT_LOAD_VERTICAL_LAYOUT is set, these are the      */
+  /*                vertical advances corresponding to a vertical layout.  */
+  /*                Otherwise, they are the horizontal advances in a       */
+  /*                horizontal layout.                                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function may fail if you use @FT_ADVANCE_FLAG_FAST_ONLY and   */
+  /*    if the corresponding font backend doesn't have a quick way to      */
+  /*    retrieve the advances.                                             */
+  /*                                                                       */
+  /*    Scaled advances are returned in 16.16 format but aren't            */
+  /*    transformed by the affine transformation specified by              */
+  /*    @FT_Set_Transform.                                                 */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Advances( FT_Face    face,
+                   FT_UInt    start,
+                   FT_UInt    count,
+                   FT_Int32   load_flags,
+                   FT_Fixed  *padvances );
+
+/* */
+
+
+FT_END_HEADER
+
+#endif /* __FTADVANC_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftautoh.h b/include/freetype/ftautoh.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftautoh.h
@@ -0,0 +1,349 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftautoh.h                                                              */
+/*                                                                         */
+/*    FreeType API for controlling the auto-hinter (specification only).   */
+/*                                                                         */
+/*  Copyright 2012 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTAUTOH_H__
+#define __FTAUTOH_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /**************************************************************************
+   *
+   * @section:
+   *   auto_hinter
+   *
+   * @title:
+   *   The auto-hinter
+   *
+   * @abstract:
+   *   Controlling the auto-hinting module.
+   *
+   * @description:
+   *   While FreeType's auto-hinter doesn't expose API functions by itself,
+   *   it is possible to control its behaviour with @FT_Property_Set and
+   *   @FT_Property_Get.  The following lists the available properties
+   *   together with the necessary macros and structures.
+   *
+   *   Note that the auto-hinter's module name is `autofitter' for
+   *   historical reasons.
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @property:
+   *   glyph-to-script-map
+   *
+   * @description:
+   *   The auto-hinter provides various script modules to hint glyphs.
+   *   Examples of supported scripts are Latin or CJK.  Before a glyph is
+   *   auto-hinted, the Unicode character map of the font gets examined, and
+   *   the script is then determined based on Unicode character ranges, see
+   *   below.
+   *
+   *   OpenType fonts, however, often provide much more glyphs than
+   *   character codes (small caps, superscripts, ligatures, swashes, etc.),
+   *   to be controlled by so-called `features'.  Handling OpenType features
+   *   can be quite complicated and thus needs a separate library on top of
+   *   FreeType.
+   *
+   *   The mapping between glyph indices and scripts (in the auto-hinter
+   *   sense, see the @FT_AUTOHINTER_SCRIPT_XXX values) is stored as an
+   *   array with `num_glyphs' elements, as found in the font's @FT_Face
+   *   structure.  The `glyph-to-script-map' property returns a pointer to
+   *   this array which can be modified as needed.  Note that the
+   *   modification should happen before the first glyph gets processed by
+   *   the auto-hinter so that the global analysis of the font shapes
+   *   actually uses the modified mapping.
+   *
+   *   The following example code demonstrates how to access it (omitting
+   *   the error handling).
+   *
+   *   {
+   *     FT_Library                library;
+   *     FT_Face                   face;
+   *     FT_Prop_GlyphToScriptMap  prop;
+   *
+   *
+   *     FT_Init_FreeType( &library );
+   *     FT_New_Face( library, "foo.ttf", 0, &face );
+   *
+   *     prop.face = face;
+   *
+   *     FT_Property_Get( library, "autofitter",
+   *                               "glyph-to-script-map", &prop );
+   *
+   *     // adjust `prop.map' as needed right here
+   *
+   *     FT_Load_Glyph( face, ..., FT_LOAD_FORCE_AUTOHINT );
+   *   }
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @enum:
+   *   FT_AUTOHINTER_SCRIPT_XXX
+   *
+   * @description:
+   *   A list of constants used for the @glyph-to-script-map property to
+   *   specify the script submodule the auto-hinter should use for hinting a
+   *   particular glyph.
+   *
+   * @values:
+   *   FT_AUTOHINTER_SCRIPT_NONE ::
+   *     Don't auto-hint this glyph.
+   *
+   *   FT_AUTOHINTER_SCRIPT_LATIN ::
+   *     Apply the latin auto-hinter.  For the auto-hinter, `latin' is a
+   *     very broad term, including Cyrillic and Greek also since characters
+   *     from those scripts share the same design constraints.
+   *
+   *     By default, characters from the following Unicode ranges are
+   *     assigned to this submodule.
+   *
+   *     {
+   *       U+0020 - U+007F  // Basic Latin (no control characters)
+   *       U+00A0 - U+00FF  // Latin-1 Supplement (no control characters)
+   *       U+0100 - U+017F  // Latin Extended-A
+   *       U+0180 - U+024F  // Latin Extended-B
+   *       U+0250 - U+02AF  // IPA Extensions
+   *       U+02B0 - U+02FF  // Spacing Modifier Letters
+   *       U+0300 - U+036F  // Combining Diacritical Marks
+   *       U+0370 - U+03FF  // Greek and Coptic
+   *       U+0400 - U+04FF  // Cyrillic
+   *       U+0500 - U+052F  // Cyrillic Supplement
+   *       U+1D00 - U+1D7F  // Phonetic Extensions
+   *       U+1D80 - U+1DBF  // Phonetic Extensions Supplement
+   *       U+1DC0 - U+1DFF  // Combining Diacritical Marks Supplement
+   *       U+1E00 - U+1EFF  // Latin Extended Additional
+   *       U+1F00 - U+1FFF  // Greek Extended
+   *       U+2000 - U+206F  // General Punctuation
+   *       U+2070 - U+209F  // Superscripts and Subscripts
+   *       U+20A0 - U+20CF  // Currency Symbols
+   *       U+2150 - U+218F  // Number Forms
+   *       U+2460 - U+24FF  // Enclosed Alphanumerics
+   *       U+2C60 - U+2C7F  // Latin Extended-C
+   *       U+2DE0 - U+2DFF  // Cyrillic Extended-A
+   *       U+2E00 - U+2E7F  // Supplemental Punctuation
+   *       U+A640 - U+A69F  // Cyrillic Extended-B
+   *       U+A720 - U+A7FF  // Latin Extended-D
+   *       U+FB00 - U+FB06  // Alphab. Present. Forms (Latin Ligatures)
+   *      U+1D400 - U+1D7FF // Mathematical Alphanumeric Symbols
+   *      U+1F100 - U+1F1FF // Enclosed Alphanumeric Supplement
+   *     }
+   *
+   *   FT_AUTOHINTER_SCRIPT_CJK ::
+   *     Apply the CJK auto-hinter, covering Chinese, Japanese, Korean, old
+   *     Vietnamese, and some other scripts.
+   *
+   *     By default, characters from the following Unicode ranges are
+   *     assigned to this submodule.
+   *
+   *     {
+   *       U+1100 - U+11FF  // Hangul Jamo
+   *       U+2E80 - U+2EFF  // CJK Radicals Supplement
+   *       U+2F00 - U+2FDF  // Kangxi Radicals
+   *       U+2FF0 - U+2FFF  // Ideographic Description Characters
+   *       U+3000 - U+303F  // CJK Symbols and Punctuation
+   *       U+3040 - U+309F  // Hiragana
+   *       U+30A0 - U+30FF  // Katakana
+   *       U+3100 - U+312F  // Bopomofo
+   *       U+3130 - U+318F  // Hangul Compatibility Jamo
+   *       U+3190 - U+319F  // Kanbun
+   *       U+31A0 - U+31BF  // Bopomofo Extended
+   *       U+31C0 - U+31EF  // CJK Strokes
+   *       U+31F0 - U+31FF  // Katakana Phonetic Extensions
+   *       U+3200 - U+32FF  // Enclosed CJK Letters and Months
+   *       U+3300 - U+33FF  // CJK Compatibility
+   *       U+3400 - U+4DBF  // CJK Unified Ideographs Extension A
+   *       U+4DC0 - U+4DFF  // Yijing Hexagram Symbols
+   *       U+4E00 - U+9FFF  // CJK Unified Ideographs
+   *       U+A960 - U+A97F  // Hangul Jamo Extended-A
+   *       U+AC00 - U+D7AF  // Hangul Syllables
+   *       U+D7B0 - U+D7FF  // Hangul Jamo Extended-B
+   *       U+F900 - U+FAFF  // CJK Compatibility Ideographs
+   *       U+FE10 - U+FE1F  // Vertical forms
+   *       U+FE30 - U+FE4F  // CJK Compatibility Forms
+   *       U+FF00 - U+FFEF  // Halfwidth and Fullwidth Forms
+   *      U+1B000 - U+1B0FF // Kana Supplement
+   *      U+1D300 - U+1D35F // Tai Xuan Hing Symbols
+   *      U+1F200 - U+1F2FF // Enclosed Ideographic Supplement
+   *      U+20000 - U+2A6DF // CJK Unified Ideographs Extension B
+   *      U+2A700 - U+2B73F // CJK Unified Ideographs Extension C
+   *      U+2B740 - U+2B81F // CJK Unified Ideographs Extension D
+   *      U+2F800 - U+2FA1F // CJK Compatibility Ideographs Supplement
+   *     }
+   *
+   *   FT_AUTOHINTER_SCRIPT_INDIC ::
+   *     Apply the indic auto-hinter, covering all major scripts from the
+   *     Indian sub-continent and some other related scripts like Thai, Lao,
+   *     or Tibetan.
+   *
+   *     By default, characters from the following Unicode ranges are
+   *     assigned to this submodule.
+   *
+   *     {
+   *       U+0900 - U+0DFF  // Indic Range
+   *       U+0F00 - U+0FFF  // Tibetan
+   *       U+1900 - U+194F  // Limbu
+   *       U+1B80 - U+1BBF  // Sundanese
+   *       U+1C80 - U+1CDF  // Meetei Mayak
+   *       U+A800 - U+A82F  // Syloti Nagri 
+   *      U+11800 - U+118DF // Sharada
+   *     }
+   *
+   *     Note that currently Indic support is rudimentary only, missing blue
+   *     zone support.
+   *
+   */
+#define FT_AUTOHINTER_SCRIPT_NONE   0
+#define FT_AUTOHINTER_SCRIPT_LATIN  1
+#define FT_AUTOHINTER_SCRIPT_CJK    2
+#define FT_AUTOHINTER_SCRIPT_INDIC  3
+
+
+  /**************************************************************************
+   *
+   * @struct:
+   *   FT_Prop_GlyphToScriptMap
+   *
+   * @description:
+   *   The data exchange structure for the @glyph-to-script-map property.
+   *
+   */
+   typedef struct  FT_Prop_GlyphToScriptMap_
+   {
+     FT_Face   face;
+     FT_Byte*  map;
+
+   } FT_Prop_GlyphToScriptMap;
+
+
+  /**************************************************************************
+   *
+   * @property:
+   *   fallback-script
+   *
+   * @description:
+   *   If no auto-hinter script module can be assigned to a glyph, a
+   *   fallback script gets assigned to it (see also the
+   *   @glyph-to-script-map property).  By default, this is
+   *   @FT_AUTOHINTER_SCRIPT_CJK.  Using the `fallback-script' property,
+   *   this fallback value can be changed.
+   *
+   *   {
+   *     FT_Library  library;
+   *     FT_UInt     fallback_script = FT_AUTOHINTER_SCRIPT_NONE;
+   *
+   *
+   *     FT_Init_FreeType( &library );
+   *
+   *     FT_Property_Set( library, "autofitter",
+   *                               "fallback-script", &fallback_script );
+   *   }
+   *
+   * @note:
+   *   This property can be used with @FT_Property_Get also.
+   *
+   *   It's important to use the right timing for changing this value: The
+   *   creation of the glyph-to-script map which eventually uses the
+   *   fallback script value gets triggered either by setting or reading a
+   *   face-specific property like @glyph-to-script-map, or by auto-hinting
+   *   any glyph from that face.  In particular, if you have already created
+   *   an @FT_Face structure but not loaded any glyph (using the
+   *   auto-hinter), a change of the fallback glyph will affect this face.
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @property:
+   *   increase-x-height
+   *
+   * @description:
+   *   For ppem values in the range 6~<= ppem <= `increase-x-height', round
+   *   up the font's x~height much more often than normally.  If the value
+   *   is set to~0, which is the default, this feature is switched off.  Use
+   *   this property to improve the legibility of small font sizes if
+   *   necessary.
+   *
+   *   {
+   *     FT_Library               library;
+   *     FT_Face                  face;
+   *     FT_Prop_IncreaseXHeight  prop;
+   *
+   *
+   *     FT_Init_FreeType( &library );
+   *     FT_New_Face( library, "foo.ttf", 0, &face );
+   *     FT_Set_Char_Size( face, 10 * 64, 0, 72, 0 );
+   *
+   *     prop.face  = face;
+   *     prop.limit = 14;
+   *
+   *     FT_Property_Set( library, "autofitter",
+   *                               "increase-x-height", &prop );
+   *   }
+   *
+   * @note:
+   *   This property can be used with @FT_Property_Get also.
+   *
+   *   Set this value right after calling @FT_Set_Char_Size, but before
+   *   loading any glyph (using the auto-hinter).
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @struct:
+   *   FT_Prop_IncreaseXHeight
+   *
+   * @description:
+   *   The data exchange structure for the @increase-x-height property.
+   *
+   */
+   typedef struct  FT_Prop_IncreaseXHeight_
+   {
+     FT_Face  face;
+     FT_UInt  limit;
+
+   } FT_Prop_IncreaseXHeight;
+
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTAUTOH_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftbbox.h b/include/freetype/ftbbox.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftbbox.h
@@ -0,0 +1,102 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftbbox.h                                                               */
+/*                                                                         */
+/*    FreeType exact bbox computation (specification).                     */
+/*                                                                         */
+/*  Copyright 1996-2001, 2003, 2007, 2011 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This component has a _single_ role: to compute exact outline bounding */
+  /* boxes.                                                                */
+  /*                                                                       */
+  /* It is separated from the rest of the engine for various technical     */
+  /* reasons.  It may well be integrated in `ftoutln' later.               */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTBBOX_H__
+#define __FTBBOX_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    outline_processing                                                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Get_BBox                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Compute the exact bounding box of an outline.  This is slower      */
+  /*    than computing the control box.  However, it uses an advanced      */
+  /*    algorithm which returns _very_ quickly when the two boxes          */
+  /*    coincide.  Otherwise, the outline Bézier arcs are traversed to     */
+  /*    extract their extrema.                                             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    outline :: A pointer to the source outline.                        */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    abbox   :: The outline's exact bounding box.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If the font is tricky and the glyph has been loaded with           */
+  /*    @FT_LOAD_NO_SCALE, the resulting BBox is meaningless.  To get      */
+  /*    reasonable values for the BBox it is necessary to load the glyph   */
+  /*    at a large ppem value (so that the hinting instructions can        */
+  /*    properly shift and scale the subglyphs), then extracting the BBox  */
+  /*    which can be eventually converted back to font units.              */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Get_BBox( FT_Outline*  outline,
+                       FT_BBox     *abbox );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTBBOX_H__ */
+
+
+/* END */
+
+
+/* Local Variables: */
+/* coding: utf-8    */
+/* End:             */
diff --git a/include/freetype/ftbdf.h b/include/freetype/ftbdf.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftbdf.h
@@ -0,0 +1,209 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftbdf.h                                                                */
+/*                                                                         */
+/*    FreeType API for accessing BDF-specific strings (specification).     */
+/*                                                                         */
+/*  Copyright 2002, 2003, 2004, 2006, 2009 by                              */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTBDF_H__
+#define __FTBDF_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    bdf_fonts                                                          */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    BDF and PCF Files                                                  */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    BDF and PCF specific API.                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of functions specific to BDF */
+  /*    and PCF fonts.                                                     */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /**********************************************************************
+   *
+   * @enum:
+   *    FT_PropertyType
+   *
+   * @description:
+   *    A list of BDF property types.
+   *
+   * @values:
+   *    BDF_PROPERTY_TYPE_NONE ::
+   *      Value~0 is used to indicate a missing property.
+   *
+   *    BDF_PROPERTY_TYPE_ATOM ::
+   *      Property is a string atom.
+   *
+   *    BDF_PROPERTY_TYPE_INTEGER ::
+   *      Property is a 32-bit signed integer.
+   *
+   *    BDF_PROPERTY_TYPE_CARDINAL ::
+   *      Property is a 32-bit unsigned integer.
+   */
+  typedef enum  BDF_PropertyType_
+  {
+    BDF_PROPERTY_TYPE_NONE     = 0,
+    BDF_PROPERTY_TYPE_ATOM     = 1,
+    BDF_PROPERTY_TYPE_INTEGER  = 2,
+    BDF_PROPERTY_TYPE_CARDINAL = 3
+
+  } BDF_PropertyType;
+
+
+  /**********************************************************************
+   *
+   * @type:
+   *    BDF_Property
+   *
+   * @description:
+   *    A handle to a @BDF_PropertyRec structure to model a given
+   *    BDF/PCF property.
+   */
+  typedef struct BDF_PropertyRec_*  BDF_Property;
+
+
+ /**********************************************************************
+  *
+  * @struct:
+  *    BDF_PropertyRec
+  *
+  * @description:
+  *    This structure models a given BDF/PCF property.
+  *
+  * @fields:
+  *    type ::
+  *      The property type.
+  *
+  *    u.atom ::
+  *      The atom string, if type is @BDF_PROPERTY_TYPE_ATOM.
+  *
+  *    u.integer ::
+  *      A signed integer, if type is @BDF_PROPERTY_TYPE_INTEGER.
+  *
+  *    u.cardinal ::
+  *      An unsigned integer, if type is @BDF_PROPERTY_TYPE_CARDINAL.
+  */
+  typedef struct  BDF_PropertyRec_
+  {
+    BDF_PropertyType  type;
+    union {
+      const char*     atom;
+      FT_Int32        integer;
+      FT_UInt32       cardinal;
+
+    } u;
+
+  } BDF_PropertyRec;
+
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_Get_BDF_Charset_ID
+  *
+  * @description:
+  *    Retrieve a BDF font character set identity, according to
+  *    the BDF specification.
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  * @output:
+  *    acharset_encoding ::
+  *       Charset encoding, as a C~string, owned by the face.
+  *
+  *    acharset_registry ::
+  *       Charset registry, as a C~string, owned by the face.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   This function only works with BDF faces, returning an error otherwise.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Get_BDF_Charset_ID( FT_Face       face,
+                         const char*  *acharset_encoding,
+                         const char*  *acharset_registry );
+
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_Get_BDF_Property
+  *
+  * @description:
+  *    Retrieve a BDF property from a BDF or PCF font file.
+  *
+  * @input:
+  *    face :: A handle to the input face.
+  *
+  *    name :: The property name.
+  *
+  * @output:
+  *    aproperty :: The property.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   This function works with BDF _and_ PCF fonts.  It returns an error
+  *   otherwise.  It also returns an error if the property is not in the
+  *   font.
+  *
+  *   A `property' is a either key-value pair within the STARTPROPERTIES
+  *   ... ENDPROPERTIES block of a BDF font or a key-value pair from the
+  *   `info->props' array within a `FontRec' structure of a PCF font.
+  *
+  *   Integer properties are always stored as `signed' within PCF fonts;
+  *   consequently, @BDF_PROPERTY_TYPE_CARDINAL is a possible return value
+  *   for BDF fonts only.
+  *
+  *   In case of error, `aproperty->type' is always set to
+  *   @BDF_PROPERTY_TYPE_NONE.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Get_BDF_Property( FT_Face           face,
+                       const char*       prop_name,
+                       BDF_PropertyRec  *aproperty );
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTBDF_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftbitmap.h b/include/freetype/ftbitmap.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftbitmap.h
@@ -0,0 +1,227 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftbitmap.h                                                             */
+/*                                                                         */
+/*    FreeType utility functions for bitmaps (specification).              */
+/*                                                                         */
+/*  Copyright 2004, 2005, 2006, 2008 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTBITMAP_H__
+#define __FTBITMAP_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    bitmap_handling                                                    */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Bitmap Handling                                                    */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Handling FT_Bitmap objects.                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains functions for converting FT_Bitmap objects.  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Bitmap_New                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Initialize a pointer to an @FT_Bitmap structure.                   */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    abitmap :: A pointer to the bitmap structure.                      */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Bitmap_New( FT_Bitmap  *abitmap );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Bitmap_Copy                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Copy a bitmap into another one.                                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to a library object.                           */
+  /*                                                                       */
+  /*    source  :: A handle to the source bitmap.                          */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    target  :: A handle to the target bitmap.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Bitmap_Copy( FT_Library        library,
+                  const FT_Bitmap  *source,
+                  FT_Bitmap        *target);
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Bitmap_Embolden                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Embolden a bitmap.  The new bitmap will be about `xStrength'       */
+  /*    pixels wider and `yStrength' pixels higher.  The left and bottom   */
+  /*    borders are kept unchanged.                                        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library   :: A handle to a library object.                         */
+  /*                                                                       */
+  /*    xStrength :: How strong the glyph is emboldened horizontally.      */
+  /*                 Expressed in 26.6 pixel format.                       */
+  /*                                                                       */
+  /*    yStrength :: How strong the glyph is emboldened vertically.        */
+  /*                 Expressed in 26.6 pixel format.                       */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    bitmap    :: A handle to the target bitmap.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The current implementation restricts `xStrength' to be less than   */
+  /*    or equal to~8 if bitmap is of pixel_mode @FT_PIXEL_MODE_MONO.      */
+  /*                                                                       */
+  /*    If you want to embolden the bitmap owned by a @FT_GlyphSlotRec,    */
+  /*    you should call @FT_GlyphSlot_Own_Bitmap on the slot first.        */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Bitmap_Embolden( FT_Library  library,
+                      FT_Bitmap*  bitmap,
+                      FT_Pos      xStrength,
+                      FT_Pos      yStrength );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Bitmap_Convert                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Convert a bitmap object with depth 1bpp, 2bpp, 4bpp, or 8bpp to a  */
+  /*    bitmap object with depth 8bpp, making the number of used bytes per */
+  /*    line (a.k.a. the `pitch') a multiple of `alignment'.               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library   :: A handle to a library object.                         */
+  /*                                                                       */
+  /*    source    :: The source bitmap.                                    */
+  /*                                                                       */
+  /*    alignment :: The pitch of the bitmap is a multiple of this         */
+  /*                 parameter.  Common values are 1, 2, or 4.             */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    target    :: The target bitmap.                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    It is possible to call @FT_Bitmap_Convert multiple times without   */
+  /*    calling @FT_Bitmap_Done (the memory is simply reallocated).        */
+  /*                                                                       */
+  /*    Use @FT_Bitmap_Done to finally remove the bitmap object.           */
+  /*                                                                       */
+  /*    The `library' argument is taken to have access to FreeType's       */
+  /*    memory handling functions.                                         */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Bitmap_Convert( FT_Library        library,
+                     const FT_Bitmap  *source,
+                     FT_Bitmap        *target,
+                     FT_Int            alignment );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_GlyphSlot_Own_Bitmap                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Make sure that a glyph slot owns `slot->bitmap'.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    slot :: The glyph slot.                                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function is to be used in combination with                    */
+  /*    @FT_Bitmap_Embolden.                                               */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Bitmap_Done                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroy a bitmap object created with @FT_Bitmap_New.               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to a library object.                           */
+  /*                                                                       */
+  /*    bitmap  :: The bitmap object to be freed.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The `library' argument is taken to have access to FreeType's       */
+  /*    memory handling functions.                                         */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Bitmap_Done( FT_Library  library,
+                  FT_Bitmap  *bitmap );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTBITMAP_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftbzip2.h b/include/freetype/ftbzip2.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftbzip2.h
@@ -0,0 +1,102 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftbzip2.h                                                              */
+/*                                                                         */
+/*    Bzip2-compressed stream support.                                     */
+/*                                                                         */
+/*  Copyright 2010 by                                                      */
+/*  Joel Klinghed.                                                         */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTBZIP2_H__
+#define __FTBZIP2_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    bzip2                                                              */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    BZIP2 Streams                                                      */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Using bzip2-compressed font files.                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of Bzip2-specific functions. */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+ /************************************************************************
+  *
+  * @function:
+  *   FT_Stream_OpenBzip2
+  *
+  * @description:
+  *   Open a new stream to parse bzip2-compressed font files.  This is
+  *   mainly used to support the compressed `*.pcf.bz2' fonts that come
+  *   with XFree86.
+  *
+  * @input:
+  *   stream ::
+  *     The target embedding stream.
+  *
+  *   source ::
+  *     The source stream.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   The source stream must be opened _before_ calling this function.
+  *
+  *   Calling the internal function `FT_Stream_Close' on the new stream will
+  *   *not* call `FT_Stream_Close' on the source stream.  None of the stream
+  *   objects will be released to the heap.
+  *
+  *   The stream implementation is very basic and resets the decompression
+  *   process each time seeking backwards is needed within the stream.
+  *
+  *   In certain builds of the library, bzip2 compression recognition is
+  *   automatically handled when calling @FT_New_Face or @FT_Open_Face.
+  *   This means that if no font driver is capable of handling the raw
+  *   compressed file, the library will try to open a bzip2 compressed stream
+  *   from it and re-open the face with it.
+  *
+  *   This function may return `FT_Err_Unimplemented_Feature' if your build
+  *   of FreeType was not compiled with bzip2 support.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Stream_OpenBzip2( FT_Stream  stream,
+                       FT_Stream  source );
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTBZIP2_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftcache.h b/include/freetype/ftcache.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftcache.h
@@ -0,0 +1,1140 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftcache.h                                                              */
+/*                                                                         */
+/*    FreeType Cache subsystem (specification).                            */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010 by */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTCACHE_H__
+#define __FTCACHE_H__
+
+
+#include <ft2build.h>
+#include FT_GLYPH_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************
+   *
+   * <Section>
+   *    cache_subsystem
+   *
+   * <Title>
+   *    Cache Sub-System
+   *
+   * <Abstract>
+   *    How to cache face, size, and glyph data with FreeType~2.
+   *
+   * <Description>
+   *   This section describes the FreeType~2 cache sub-system, which is used
+   *   to limit the number of concurrently opened @FT_Face and @FT_Size
+   *   objects, as well as caching information like character maps and glyph
+   *   images while limiting their maximum memory usage.
+   *
+   *   Note that all types and functions begin with the `FTC_' prefix.
+   *
+   *   The cache is highly portable and thus doesn't know anything about the
+   *   fonts installed on your system, or how to access them.  This implies
+   *   the following scheme:
+   *
+   *   First, available or installed font faces are uniquely identified by
+   *   @FTC_FaceID values, provided to the cache by the client.  Note that
+   *   the cache only stores and compares these values, and doesn't try to
+   *   interpret them in any way.
+   *
+   *   Second, the cache calls, only when needed, a client-provided function
+   *   to convert an @FTC_FaceID into a new @FT_Face object.  The latter is
+   *   then completely managed by the cache, including its termination
+   *   through @FT_Done_Face.  To monitor termination of face objects, the
+   *   finalizer callback in the `generic' field of the @FT_Face object can
+   *   be used, which might also be used to store the @FTC_FaceID of the
+   *   face.
+   *
+   *   Clients are free to map face IDs to anything else.  The most simple
+   *   usage is to associate them to a (pathname,face_index) pair that is
+   *   used to call @FT_New_Face.  However, more complex schemes are also
+   *   possible.
+   *
+   *   Note that for the cache to work correctly, the face ID values must be
+   *   *persistent*, which means that the contents they point to should not
+   *   change at runtime, or that their value should not become invalid.
+   *
+   *   If this is unavoidable (e.g., when a font is uninstalled at runtime),
+   *   you should call @FTC_Manager_RemoveFaceID as soon as possible, to let
+   *   the cache get rid of any references to the old @FTC_FaceID it may
+   *   keep internally.  Failure to do so will lead to incorrect behaviour
+   *   or even crashes.
+   *
+   *   To use the cache, start with calling @FTC_Manager_New to create a new
+   *   @FTC_Manager object, which models a single cache instance.  You can
+   *   then look up @FT_Face and @FT_Size objects with
+   *   @FTC_Manager_LookupFace and @FTC_Manager_LookupSize, respectively.
+   *
+   *   If you want to use the charmap caching, call @FTC_CMapCache_New, then
+   *   later use @FTC_CMapCache_Lookup to perform the equivalent of
+   *   @FT_Get_Char_Index, only much faster.
+   *
+   *   If you want to use the @FT_Glyph caching, call @FTC_ImageCache, then
+   *   later use @FTC_ImageCache_Lookup to retrieve the corresponding
+   *   @FT_Glyph objects from the cache.
+   *
+   *   If you need lots of small bitmaps, it is much more memory efficient
+   *   to call @FTC_SBitCache_New followed by @FTC_SBitCache_Lookup.  This
+   *   returns @FTC_SBitRec structures, which are used to store small
+   *   bitmaps directly.  (A small bitmap is one whose metrics and
+   *   dimensions all fit into 8-bit integers).
+   *
+   *   We hope to also provide a kerning cache in the near future.
+   *
+   *
+   * <Order>
+   *   FTC_Manager
+   *   FTC_FaceID
+   *   FTC_Face_Requester
+   *
+   *   FTC_Manager_New
+   *   FTC_Manager_Reset
+   *   FTC_Manager_Done
+   *   FTC_Manager_LookupFace
+   *   FTC_Manager_LookupSize
+   *   FTC_Manager_RemoveFaceID
+   *
+   *   FTC_Node
+   *   FTC_Node_Unref
+   *
+   *   FTC_ImageCache
+   *   FTC_ImageCache_New
+   *   FTC_ImageCache_Lookup
+   *
+   *   FTC_SBit
+   *   FTC_SBitCache
+   *   FTC_SBitCache_New
+   *   FTC_SBitCache_Lookup
+   *
+   *   FTC_CMapCache
+   *   FTC_CMapCache_New
+   *   FTC_CMapCache_Lookup
+   *
+   *************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                    BASIC TYPE DEFINITIONS                     *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @type: FTC_FaceID
+   *
+   * @description:
+   *   An opaque pointer type that is used to identity face objects.  The
+   *   contents of such objects is application-dependent.
+   *
+   *   These pointers are typically used to point to a user-defined
+   *   structure containing a font file path, and face index.
+   *
+   * @note:
+   *   Never use NULL as a valid @FTC_FaceID.
+   *
+   *   Face IDs are passed by the client to the cache manager, which calls,
+   *   when needed, the @FTC_Face_Requester to translate them into new
+   *   @FT_Face objects.
+   *
+   *   If the content of a given face ID changes at runtime, or if the value
+   *   becomes invalid (e.g., when uninstalling a font), you should
+   *   immediately call @FTC_Manager_RemoveFaceID before any other cache
+   *   function.
+   *
+   *   Failure to do so will result in incorrect behaviour or even
+   *   memory leaks and crashes.
+   */
+  typedef FT_Pointer  FTC_FaceID;
+
+
+  /************************************************************************
+   *
+   * @functype:
+   *   FTC_Face_Requester
+   *
+   * @description:
+   *   A callback function provided by client applications.  It is used by
+   *   the cache manager to translate a given @FTC_FaceID into a new valid
+   *   @FT_Face object, on demand.
+   *
+   * <Input>
+   *   face_id ::
+   *     The face ID to resolve.
+   *
+   *   library ::
+   *     A handle to a FreeType library object.
+   *
+   *   req_data ::
+   *     Application-provided request data (see note below).
+   *
+   * <Output>
+   *   aface ::
+   *     A new @FT_Face handle.
+   *
+   * <Return>
+   *   FreeType error code.  0~means success.
+   *
+   * <Note>
+   *   The third parameter `req_data' is the same as the one passed by the
+   *   client when @FTC_Manager_New is called.
+   *
+   *   The face requester should not perform funny things on the returned
+   *   face object, like creating a new @FT_Size for it, or setting a
+   *   transformation through @FT_Set_Transform!
+   */
+  typedef FT_Error
+  (*FTC_Face_Requester)( FTC_FaceID  face_id,
+                         FT_Library  library,
+                         FT_Pointer  request_data,
+                         FT_Face*    aface );
+
+ /* */
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /* these macros are incompatible with LLP64, should not be used */
+
+#define FT_POINTER_TO_ULONG( p )  ( (FT_ULong)(FT_Pointer)(p) )
+
+#define FTC_FACE_ID_HASH( i )                                \
+          ((FT_UInt32)(( FT_POINTER_TO_ULONG( i ) >> 3 ) ^   \
+                       ( FT_POINTER_TO_ULONG( i ) << 7 ) ) )
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                      CACHE MANAGER OBJECT                     *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FTC_Manager                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This object corresponds to one instance of the cache-subsystem.    */
+  /*    It is used to cache one or more @FT_Face objects, along with       */
+  /*    corresponding @FT_Size objects.                                    */
+  /*                                                                       */
+  /*    The manager intentionally limits the total number of opened        */
+  /*    @FT_Face and @FT_Size objects to control memory usage.  See the    */
+  /*    `max_faces' and `max_sizes' parameters of @FTC_Manager_New.        */
+  /*                                                                       */
+  /*    The manager is also used to cache `nodes' of various types while   */
+  /*    limiting their total memory usage.                                 */
+  /*                                                                       */
+  /*    All limitations are enforced by keeping lists of managed objects   */
+  /*    in most-recently-used order, and flushing old nodes to make room   */
+  /*    for new ones.                                                      */
+  /*                                                                       */
+  typedef struct FTC_ManagerRec_*  FTC_Manager;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FTC_Node                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An opaque handle to a cache node object.  Each cache node is       */
+  /*    reference-counted.  A node with a count of~0 might be flushed      */
+  /*    out of a full cache whenever a lookup request is performed.        */
+  /*                                                                       */
+  /*    If you look up nodes, you have the ability to `acquire' them,      */
+  /*    i.e., to increment their reference count.  This will prevent the   */
+  /*    node from being flushed out of the cache until you explicitly      */
+  /*    `release' it (see @FTC_Node_Unref).                                */
+  /*                                                                       */
+  /*    See also @FTC_SBitCache_Lookup and @FTC_ImageCache_Lookup.         */
+  /*                                                                       */
+  typedef struct FTC_NodeRec_*  FTC_Node;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_Manager_New                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new cache manager.                                        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library   :: The parent FreeType library handle to use.            */
+  /*                                                                       */
+  /*    max_faces :: Maximum number of opened @FT_Face objects managed by  */
+  /*                 this cache instance.  Use~0 for defaults.             */
+  /*                                                                       */
+  /*    max_sizes :: Maximum number of opened @FT_Size objects managed by  */
+  /*                 this cache instance.  Use~0 for defaults.             */
+  /*                                                                       */
+  /*    max_bytes :: Maximum number of bytes to use for cached data nodes. */
+  /*                 Use~0 for defaults.  Note that this value does not    */
+  /*                 account for managed @FT_Face and @FT_Size objects.    */
+  /*                                                                       */
+  /*    requester :: An application-provided callback used to translate    */
+  /*                 face IDs into real @FT_Face objects.                  */
+  /*                                                                       */
+  /*    req_data  :: A generic pointer that is passed to the requester     */
+  /*                 each time it is called (see @FTC_Face_Requester).     */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    amanager  :: A handle to a new manager object.  0~in case of       */
+  /*                 failure.                                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_Manager_New( FT_Library          library,
+                   FT_UInt             max_faces,
+                   FT_UInt             max_sizes,
+                   FT_ULong            max_bytes,
+                   FTC_Face_Requester  requester,
+                   FT_Pointer          req_data,
+                   FTC_Manager        *amanager );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_Manager_Reset                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Empty a given cache manager.  This simply gets rid of all the      */
+  /*    currently cached @FT_Face and @FT_Size objects within the manager. */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    manager :: A handle to the manager.                                */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FTC_Manager_Reset( FTC_Manager  manager );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_Manager_Done                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroy a given manager after emptying it.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    manager :: A handle to the target cache manager object.            */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FTC_Manager_Done( FTC_Manager  manager );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_Manager_LookupFace                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the @FT_Face object that corresponds to a given face ID   */
+  /*    through a cache manager.                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    manager :: A handle to the cache manager.                          */
+  /*                                                                       */
+  /*    face_id :: The ID of the face object.                              */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aface   :: A handle to the face object.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The returned @FT_Face object is always owned by the manager.  You  */
+  /*    should never try to discard it yourself.                           */
+  /*                                                                       */
+  /*    The @FT_Face object doesn't necessarily have a current size object */
+  /*    (i.e., face->size can be 0).  If you need a specific `font size',  */
+  /*    use @FTC_Manager_LookupSize instead.                               */
+  /*                                                                       */
+  /*    Never change the face's transformation matrix (i.e., never call    */
+  /*    the @FT_Set_Transform function) on a returned face!  If you need   */
+  /*    to transform glyphs, do it yourself after glyph loading.           */
+  /*                                                                       */
+  /*    When you perform a lookup, out-of-memory errors are detected       */
+  /*    _within_ the lookup and force incremental flushes of the cache     */
+  /*    until enough memory is released for the lookup to succeed.         */
+  /*                                                                       */
+  /*    If a lookup fails with `FT_Err_Out_Of_Memory' the cache has        */
+  /*    already been completely flushed, and still no memory was available */
+  /*    for the operation.                                                 */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_Manager_LookupFace( FTC_Manager  manager,
+                          FTC_FaceID   face_id,
+                          FT_Face     *aface );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FTC_ScalerRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to describe a given character size in either      */
+  /*    pixels or points to the cache manager.  See                        */
+  /*    @FTC_Manager_LookupSize.                                           */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    face_id :: The source face ID.                                     */
+  /*                                                                       */
+  /*    width   :: The character width.                                    */
+  /*                                                                       */
+  /*    height  :: The character height.                                   */
+  /*                                                                       */
+  /*    pixel   :: A Boolean.  If 1, the `width' and `height' fields are   */
+  /*               interpreted as integer pixel character sizes.           */
+  /*               Otherwise, they are expressed as 1/64th of points.      */
+  /*                                                                       */
+  /*    x_res   :: Only used when `pixel' is value~0 to indicate the       */
+  /*               horizontal resolution in dpi.                           */
+  /*                                                                       */
+  /*    y_res   :: Only used when `pixel' is value~0 to indicate the       */
+  /*               vertical resolution in dpi.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This type is mainly used to retrieve @FT_Size objects through the  */
+  /*    cache manager.                                                     */
+  /*                                                                       */
+  typedef struct  FTC_ScalerRec_
+  {
+    FTC_FaceID  face_id;
+    FT_UInt     width;
+    FT_UInt     height;
+    FT_Int      pixel;
+    FT_UInt     x_res;
+    FT_UInt     y_res;
+
+  } FTC_ScalerRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FTC_Scaler                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to an @FTC_ScalerRec structure.                           */
+  /*                                                                       */
+  typedef struct FTC_ScalerRec_*  FTC_Scaler;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_Manager_LookupSize                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the @FT_Size object that corresponds to a given           */
+  /*    @FTC_ScalerRec pointer through a cache manager.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    manager :: A handle to the cache manager.                          */
+  /*                                                                       */
+  /*    scaler  :: A scaler handle.                                        */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    asize   :: A handle to the size object.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The returned @FT_Size object is always owned by the manager.  You  */
+  /*    should never try to discard it by yourself.                        */
+  /*                                                                       */
+  /*    You can access the parent @FT_Face object simply as `size->face'   */
+  /*    if you need it.  Note that this object is also owned by the        */
+  /*    manager.                                                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    When you perform a lookup, out-of-memory errors are detected       */
+  /*    _within_ the lookup and force incremental flushes of the cache     */
+  /*    until enough memory is released for the lookup to succeed.         */
+  /*                                                                       */
+  /*    If a lookup fails with `FT_Err_Out_Of_Memory' the cache has        */
+  /*    already been completely flushed, and still no memory is available  */
+  /*    for the operation.                                                 */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_Manager_LookupSize( FTC_Manager  manager,
+                          FTC_Scaler   scaler,
+                          FT_Size     *asize );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_Node_Unref                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Decrement a cache node's internal reference count.  When the count */
+  /*    reaches 0, it is not destroyed but becomes eligible for subsequent */
+  /*    cache flushes.                                                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    node    :: The cache node handle.                                  */
+  /*                                                                       */
+  /*    manager :: The cache manager handle.                               */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FTC_Node_Unref( FTC_Node     node,
+                  FTC_Manager  manager );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FTC_Manager_RemoveFaceID
+   *
+   * @description:
+   *   A special function used to indicate to the cache manager that
+   *   a given @FTC_FaceID is no longer valid, either because its
+   *   content changed, or because it was deallocated or uninstalled.
+   *
+   * @input:
+   *   manager ::
+   *     The cache manager handle.
+   *
+   *   face_id ::
+   *     The @FTC_FaceID to be removed.
+   *
+   * @note:
+   *   This function flushes all nodes from the cache corresponding to this
+   *   `face_id', with the exception of nodes with a non-null reference
+   *   count.
+   *
+   *   Such nodes are however modified internally so as to never appear
+   *   in later lookups with the same `face_id' value, and to be immediately
+   *   destroyed when released by all their users.
+   *
+   */
+  FT_EXPORT( void )
+  FTC_Manager_RemoveFaceID( FTC_Manager  manager,
+                            FTC_FaceID   face_id );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    cache_subsystem                                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+  /*************************************************************************
+   *
+   * @type:
+   *   FTC_CMapCache
+   *
+   * @description:
+   *   An opaque handle used to model a charmap cache.  This cache is to
+   *   hold character codes -> glyph indices mappings.
+   *
+   */
+  typedef struct FTC_CMapCacheRec_*  FTC_CMapCache;
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FTC_CMapCache_New
+   *
+   * @description:
+   *   Create a new charmap cache.
+   *
+   * @input:
+   *   manager ::
+   *     A handle to the cache manager.
+   *
+   * @output:
+   *   acache ::
+   *     A new cache handle.  NULL in case of error.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   Like all other caches, this one will be destroyed with the cache
+   *   manager.
+   *
+   */
+  FT_EXPORT( FT_Error )
+  FTC_CMapCache_New( FTC_Manager     manager,
+                     FTC_CMapCache  *acache );
+
+
+  /************************************************************************
+   *
+   * @function:
+   *   FTC_CMapCache_Lookup
+   *
+   * @description:
+   *   Translate a character code into a glyph index, using the charmap
+   *   cache.
+   *
+   * @input:
+   *   cache ::
+   *     A charmap cache handle.
+   *
+   *   face_id ::
+   *     The source face ID.
+   *
+   *   cmap_index ::
+   *     The index of the charmap in the source face.  Any negative value
+   *     means to use the cache @FT_Face's default charmap.
+   *
+   *   char_code ::
+   *     The character code (in the corresponding charmap).
+   *
+   * @return:
+   *    Glyph index.  0~means `no glyph'.
+   *
+   */
+  FT_EXPORT( FT_UInt )
+  FTC_CMapCache_Lookup( FTC_CMapCache  cache,
+                        FTC_FaceID     face_id,
+                        FT_Int         cmap_index,
+                        FT_UInt32      char_code );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    cache_subsystem                                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                       IMAGE CACHE OBJECT                      *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @struct:
+   *   FTC_ImageTypeRec
+   *
+   * @description:
+   *   A structure used to model the type of images in a glyph cache.
+   *
+   * @fields:
+   *   face_id ::
+   *     The face ID.
+   *
+   *   width ::
+   *     The width in pixels.
+   *
+   *   height ::
+   *     The height in pixels.
+   *
+   *   flags ::
+   *     The load flags, as in @FT_Load_Glyph.
+   *
+   */
+  typedef struct  FTC_ImageTypeRec_
+  {
+    FTC_FaceID  face_id;
+    FT_Int      width;
+    FT_Int      height;
+    FT_Int32    flags;
+
+  } FTC_ImageTypeRec;
+
+
+  /*************************************************************************
+   *
+   * @type:
+   *   FTC_ImageType
+   *
+   * @description:
+   *   A handle to an @FTC_ImageTypeRec structure.
+   *
+   */
+  typedef struct FTC_ImageTypeRec_*  FTC_ImageType;
+
+
+  /* */
+
+
+#define FTC_IMAGE_TYPE_COMPARE( d1, d2 )      \
+          ( (d1)->face_id == (d2)->face_id && \
+            (d1)->width   == (d2)->width   && \
+            (d1)->flags   == (d2)->flags   )
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /* this macro is incompatible with LLP64, should not be used */
+
+#define FTC_IMAGE_TYPE_HASH( d )                          \
+          (FT_UFast)( FTC_FACE_ID_HASH( (d)->face_id )  ^ \
+                      ( (d)->width << 8 ) ^ (d)->height ^ \
+                      ( (d)->flags << 4 )               )
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FTC_ImageCache                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to an glyph image cache object.  They are designed to     */
+  /*    hold many distinct glyph images while not exceeding a certain      */
+  /*    memory threshold.                                                  */
+  /*                                                                       */
+  typedef struct FTC_ImageCacheRec_*  FTC_ImageCache;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_ImageCache_New                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new glyph image cache.                                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    manager :: The parent manager for the image cache.                 */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    acache  :: A handle to the new glyph image cache object.           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_ImageCache_New( FTC_Manager      manager,
+                      FTC_ImageCache  *acache );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_ImageCache_Lookup                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve a given glyph image from a glyph image cache.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    cache  :: A handle to the source glyph image cache.                */
+  /*                                                                       */
+  /*    type   :: A pointer to a glyph image type descriptor.              */
+  /*                                                                       */
+  /*    gindex :: The glyph index to retrieve.                             */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aglyph :: The corresponding @FT_Glyph object.  0~in case of        */
+  /*              failure.                                                 */
+  /*                                                                       */
+  /*    anode  :: Used to return the address of of the corresponding cache */
+  /*              node after incrementing its reference count (see note    */
+  /*              below).                                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The returned glyph is owned and managed by the glyph image cache.  */
+  /*    Never try to transform or discard it manually!  You can however    */
+  /*    create a copy with @FT_Glyph_Copy and modify the new one.          */
+  /*                                                                       */
+  /*    If `anode' is _not_ NULL, it receives the address of the cache     */
+  /*    node containing the glyph image, after increasing its reference    */
+  /*    count.  This ensures that the node (as well as the @FT_Glyph) will */
+  /*    always be kept in the cache until you call @FTC_Node_Unref to      */
+  /*    `release' it.                                                      */
+  /*                                                                       */
+  /*    If `anode' is NULL, the cache node is left unchanged, which means  */
+  /*    that the @FT_Glyph could be flushed out of the cache on the next   */
+  /*    call to one of the caching sub-system APIs.  Don't assume that it  */
+  /*    is persistent!                                                     */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_ImageCache_Lookup( FTC_ImageCache  cache,
+                         FTC_ImageType   type,
+                         FT_UInt         gindex,
+                         FT_Glyph       *aglyph,
+                         FTC_Node       *anode );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_ImageCache_LookupScaler                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A variant of @FTC_ImageCache_Lookup that uses an @FTC_ScalerRec    */
+  /*    to specify the face ID and its size.                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    cache      :: A handle to the source glyph image cache.            */
+  /*                                                                       */
+  /*    scaler     :: A pointer to a scaler descriptor.                    */
+  /*                                                                       */
+  /*    load_flags :: The corresponding load flags.                        */
+  /*                                                                       */
+  /*    gindex     :: The glyph index to retrieve.                         */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aglyph     :: The corresponding @FT_Glyph object.  0~in case of    */
+  /*                  failure.                                             */
+  /*                                                                       */
+  /*    anode      :: Used to return the address of of the corresponding   */
+  /*                  cache node after incrementing its reference count    */
+  /*                  (see note below).                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The returned glyph is owned and managed by the glyph image cache.  */
+  /*    Never try to transform or discard it manually!  You can however    */
+  /*    create a copy with @FT_Glyph_Copy and modify the new one.          */
+  /*                                                                       */
+  /*    If `anode' is _not_ NULL, it receives the address of the cache     */
+  /*    node containing the glyph image, after increasing its reference    */
+  /*    count.  This ensures that the node (as well as the @FT_Glyph) will */
+  /*    always be kept in the cache until you call @FTC_Node_Unref to      */
+  /*    `release' it.                                                      */
+  /*                                                                       */
+  /*    If `anode' is NULL, the cache node is left unchanged, which means  */
+  /*    that the @FT_Glyph could be flushed out of the cache on the next   */
+  /*    call to one of the caching sub-system APIs.  Don't assume that it  */
+  /*    is persistent!                                                     */
+  /*                                                                       */
+  /*    Calls to @FT_Set_Char_Size and friends have no effect on cached    */
+  /*    glyphs; you should always use the FreeType cache API instead.      */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_ImageCache_LookupScaler( FTC_ImageCache  cache,
+                               FTC_Scaler      scaler,
+                               FT_ULong        load_flags,
+                               FT_UInt         gindex,
+                               FT_Glyph       *aglyph,
+                               FTC_Node       *anode );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FTC_SBit                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a small bitmap descriptor.  See the @FTC_SBitRec       */
+  /*    structure for details.                                             */
+  /*                                                                       */
+  typedef struct FTC_SBitRec_*  FTC_SBit;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FTC_SBitRec                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very compact structure used to describe a small glyph bitmap.    */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    width     :: The bitmap width in pixels.                           */
+  /*                                                                       */
+  /*    height    :: The bitmap height in pixels.                          */
+  /*                                                                       */
+  /*    left      :: The horizontal distance from the pen position to the  */
+  /*                 left bitmap border (a.k.a. `left side bearing', or    */
+  /*                 `lsb').                                               */
+  /*                                                                       */
+  /*    top       :: The vertical distance from the pen position (on the   */
+  /*                 baseline) to the upper bitmap border (a.k.a. `top     */
+  /*                 side bearing').  The distance is positive for upwards */
+  /*                 y~coordinates.                                        */
+  /*                                                                       */
+  /*    format    :: The format of the glyph bitmap (monochrome or gray).  */
+  /*                                                                       */
+  /*    max_grays :: Maximum gray level value (in the range 1 to~255).     */
+  /*                                                                       */
+  /*    pitch     :: The number of bytes per bitmap line.  May be positive */
+  /*                 or negative.                                          */
+  /*                                                                       */
+  /*    xadvance  :: The horizontal advance width in pixels.               */
+  /*                                                                       */
+  /*    yadvance  :: The vertical advance height in pixels.                */
+  /*                                                                       */
+  /*    buffer    :: A pointer to the bitmap pixels.                       */
+  /*                                                                       */
+  typedef struct  FTC_SBitRec_
+  {
+    FT_Byte   width;
+    FT_Byte   height;
+    FT_Char   left;
+    FT_Char   top;
+
+    FT_Byte   format;
+    FT_Byte   max_grays;
+    FT_Short  pitch;
+    FT_Char   xadvance;
+    FT_Char   yadvance;
+
+    FT_Byte*  buffer;
+
+  } FTC_SBitRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FTC_SBitCache                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a small bitmap cache.  These are special cache objects */
+  /*    used to store small glyph bitmaps (and anti-aliased pixmaps) in a  */
+  /*    much more efficient way than the traditional glyph image cache     */
+  /*    implemented by @FTC_ImageCache.                                    */
+  /*                                                                       */
+  typedef struct FTC_SBitCacheRec_*  FTC_SBitCache;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_SBitCache_New                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new cache to store small glyph bitmaps.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    manager :: A handle to the source cache manager.                   */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    acache  :: A handle to the new sbit cache.  NULL in case of error. */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_SBitCache_New( FTC_Manager     manager,
+                     FTC_SBitCache  *acache );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_SBitCache_Lookup                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Look up a given small glyph bitmap in a given sbit cache and       */
+  /*    `lock' it to prevent its flushing from the cache until needed.     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    cache  :: A handle to the source sbit cache.                       */
+  /*                                                                       */
+  /*    type   :: A pointer to the glyph image type descriptor.            */
+  /*                                                                       */
+  /*    gindex :: The glyph index.                                         */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    sbit   :: A handle to a small bitmap descriptor.                   */
+  /*                                                                       */
+  /*    anode  :: Used to return the address of of the corresponding cache */
+  /*              node after incrementing its reference count (see note    */
+  /*              below).                                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The small bitmap descriptor and its bit buffer are owned by the    */
+  /*    cache and should never be freed by the application.  They might    */
+  /*    as well disappear from memory on the next cache lookup, so don't   */
+  /*    treat them as persistent data.                                     */
+  /*                                                                       */
+  /*    The descriptor's `buffer' field is set to~0 to indicate a missing  */
+  /*    glyph bitmap.                                                      */
+  /*                                                                       */
+  /*    If `anode' is _not_ NULL, it receives the address of the cache     */
+  /*    node containing the bitmap, after increasing its reference count.  */
+  /*    This ensures that the node (as well as the image) will always be   */
+  /*    kept in the cache until you call @FTC_Node_Unref to `release' it.  */
+  /*                                                                       */
+  /*    If `anode' is NULL, the cache node is left unchanged, which means  */
+  /*    that the bitmap could be flushed out of the cache on the next      */
+  /*    call to one of the caching sub-system APIs.  Don't assume that it  */
+  /*    is persistent!                                                     */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_SBitCache_Lookup( FTC_SBitCache    cache,
+                        FTC_ImageType    type,
+                        FT_UInt          gindex,
+                        FTC_SBit        *sbit,
+                        FTC_Node        *anode );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FTC_SBitCache_LookupScaler                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A variant of @FTC_SBitCache_Lookup that uses an @FTC_ScalerRec     */
+  /*    to specify the face ID and its size.                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    cache      :: A handle to the source sbit cache.                   */
+  /*                                                                       */
+  /*    scaler     :: A pointer to the scaler descriptor.                  */
+  /*                                                                       */
+  /*    load_flags :: The corresponding load flags.                        */
+  /*                                                                       */
+  /*    gindex     :: The glyph index.                                     */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    sbit       :: A handle to a small bitmap descriptor.               */
+  /*                                                                       */
+  /*    anode      :: Used to return the address of of the corresponding   */
+  /*                  cache node after incrementing its reference count    */
+  /*                  (see note below).                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The small bitmap descriptor and its bit buffer are owned by the    */
+  /*    cache and should never be freed by the application.  They might    */
+  /*    as well disappear from memory on the next cache lookup, so don't   */
+  /*    treat them as persistent data.                                     */
+  /*                                                                       */
+  /*    The descriptor's `buffer' field is set to~0 to indicate a missing  */
+  /*    glyph bitmap.                                                      */
+  /*                                                                       */
+  /*    If `anode' is _not_ NULL, it receives the address of the cache     */
+  /*    node containing the bitmap, after increasing its reference count.  */
+  /*    This ensures that the node (as well as the image) will always be   */
+  /*    kept in the cache until you call @FTC_Node_Unref to `release' it.  */
+  /*                                                                       */
+  /*    If `anode' is NULL, the cache node is left unchanged, which means  */
+  /*    that the bitmap could be flushed out of the cache on the next      */
+  /*    call to one of the caching sub-system APIs.  Don't assume that it  */
+  /*    is persistent!                                                     */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FTC_SBitCache_LookupScaler( FTC_SBitCache  cache,
+                              FTC_Scaler     scaler,
+                              FT_ULong       load_flags,
+                              FT_UInt        gindex,
+                              FTC_SBit      *sbit,
+                              FTC_Node      *anode );
+
+
+ /* */
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /*@***********************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FTC_FontRec                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to describe a given `font' to the cache    */
+  /*    manager.  Note that a `font' is the combination of a given face    */
+  /*    with a given character size.                                       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    face_id    :: The ID of the face to use.                           */
+  /*                                                                       */
+  /*    pix_width  :: The character width in integer pixels.               */
+  /*                                                                       */
+  /*    pix_height :: The character height in integer pixels.              */
+  /*                                                                       */
+  typedef struct  FTC_FontRec_
+  {
+    FTC_FaceID  face_id;
+    FT_UShort   pix_width;
+    FT_UShort   pix_height;
+
+  } FTC_FontRec;
+
+
+  /* */
+
+
+#define FTC_FONT_COMPARE( f1, f2 )                  \
+          ( (f1)->face_id    == (f2)->face_id    && \
+            (f1)->pix_width  == (f2)->pix_width  && \
+            (f1)->pix_height == (f2)->pix_height )
+
+  /* this macro is incompatible with LLP64, should not be used */
+#define FTC_FONT_HASH( f )                              \
+          (FT_UInt32)( FTC_FACE_ID_HASH((f)->face_id) ^ \
+                       ((f)->pix_width << 8)          ^ \
+                       ((f)->pix_height)              )
+
+  typedef FTC_FontRec*  FTC_Font;
+
+
+  FT_EXPORT( FT_Error )
+  FTC_Manager_Lookup_Face( FTC_Manager  manager,
+                           FTC_FaceID   face_id,
+                           FT_Face     *aface );
+
+  FT_EXPORT( FT_Error )
+  FTC_Manager_Lookup_Size( FTC_Manager  manager,
+                           FTC_Font     font,
+                           FT_Face     *aface,
+                           FT_Size     *asize );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTCACHE_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftchapters.h b/include/freetype/ftchapters.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftchapters.h
@@ -0,0 +1,118 @@
+/***************************************************************************/
+/*                                                                         */
+/* This file defines the structure of the FreeType reference.              */
+/* It is used by the python script which generates the HTML files.         */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* <Chapter>                                                               */
+/*    general_remarks                                                      */
+/*                                                                         */
+/* <Title>                                                                 */
+/*    General Remarks                                                      */
+/*                                                                         */
+/* <Sections>                                                              */
+/*    user_allocation                                                      */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* <Chapter>                                                               */
+/*    core_api                                                             */
+/*                                                                         */
+/* <Title>                                                                 */
+/*    Core API                                                             */
+/*                                                                         */
+/* <Sections>                                                              */
+/*    version                                                              */
+/*    basic_types                                                          */
+/*    base_interface                                                       */
+/*    glyph_variants                                                       */
+/*    glyph_management                                                     */
+/*    mac_specific                                                         */
+/*    sizes_management                                                     */
+/*    header_file_macros                                                   */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* <Chapter>                                                               */
+/*    format_specific                                                      */
+/*                                                                         */
+/* <Title>                                                                 */
+/*    Format-Specific API                                                  */
+/*                                                                         */
+/* <Sections>                                                              */
+/*    multiple_masters                                                     */
+/*    truetype_tables                                                      */
+/*    type1_tables                                                         */
+/*    sfnt_names                                                           */
+/*    bdf_fonts                                                            */
+/*    cid_fonts                                                            */
+/*    pfr_fonts                                                            */
+/*    winfnt_fonts                                                         */
+/*    font_formats                                                         */
+/*    gasp_table                                                           */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* <Chapter>                                                               */
+/*    auto_hinter                                                          */
+/*                                                                         */
+/* <Title>                                                                 */
+/*    The Auto-Hinter                                                      */
+/*                                                                         */
+/* <Sections>                                                              */
+/*    auto_hinter                                                          */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* <Chapter>                                                               */
+/*    cache_subsystem                                                      */
+/*                                                                         */
+/* <Title>                                                                 */
+/*    Cache Sub-System                                                     */
+/*                                                                         */
+/* <Sections>                                                              */
+/*    cache_subsystem                                                      */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* <Chapter>                                                               */
+/*    support_api                                                          */
+/*                                                                         */
+/* <Title>                                                                 */
+/*    Support API                                                          */
+/*                                                                         */
+/* <Sections>                                                              */
+/*    computations                                                         */
+/*    list_processing                                                      */
+/*    outline_processing                                                   */
+/*    quick_advance                                                        */
+/*    bitmap_handling                                                      */
+/*    raster                                                               */
+/*    glyph_stroker                                                        */
+/*    system_interface                                                     */
+/*    module_management                                                    */
+/*    gzip                                                                 */
+/*    lzw                                                                  */
+/*    bzip2                                                                */
+/*    lcd_filtering                                                        */
+/*                                                                         */
+/***************************************************************************/
diff --git a/include/freetype/ftcid.h b/include/freetype/ftcid.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftcid.h
@@ -0,0 +1,166 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftcid.h                                                                */
+/*                                                                         */
+/*    FreeType API for accessing CID font information (specification).     */
+/*                                                                         */
+/*  Copyright 2007, 2009 by Dereg Clegg, Michael Toftdal.                  */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTCID_H__
+#define __FTCID_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    cid_fonts                                                          */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    CID Fonts                                                          */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    CID-keyed font specific API.                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of CID-keyed font specific   */
+  /*    functions.                                                         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /**********************************************************************
+   *
+   * @function:
+   *    FT_Get_CID_Registry_Ordering_Supplement
+   *
+   * @description:
+   *    Retrieve the Registry/Ordering/Supplement triple (also known as the
+   *    "R/O/S") from a CID-keyed font.
+   *
+   * @input:
+   *    face ::
+   *       A handle to the input face.
+   *
+   * @output:
+   *    registry ::
+   *       The registry, as a C~string, owned by the face.
+   *
+   *    ordering ::
+   *       The ordering, as a C~string, owned by the face.
+   *
+   *    supplement ::
+   *       The supplement.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *    This function only works with CID faces, returning an error
+   *    otherwise.
+   *
+   * @since:
+   *    2.3.6
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_CID_Registry_Ordering_Supplement( FT_Face       face,
+                                           const char*  *registry,
+                                           const char*  *ordering,
+                                           FT_Int       *supplement);
+
+
+  /**********************************************************************
+   *
+   * @function:
+   *    FT_Get_CID_Is_Internally_CID_Keyed
+   *
+   * @description:
+   *    Retrieve the type of the input face, CID keyed or not.  In
+   *    constrast to the @FT_IS_CID_KEYED macro this function returns
+   *    successfully also for CID-keyed fonts in an SNFT wrapper.
+   *
+   * @input:
+   *    face ::
+   *       A handle to the input face.
+   *
+   * @output:
+   *    is_cid ::
+   *       The type of the face as an @FT_Bool.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *    This function only works with CID faces and OpenType fonts,
+   *    returning an error otherwise.
+   *
+   * @since:
+   *    2.3.9
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_CID_Is_Internally_CID_Keyed( FT_Face   face,
+                                      FT_Bool  *is_cid );
+
+
+  /**********************************************************************
+   *
+   * @function:
+   *    FT_Get_CID_From_Glyph_Index
+   *
+   * @description:
+   *    Retrieve the CID of the input glyph index.
+   *
+   * @input:
+   *    face ::
+   *       A handle to the input face.
+   *
+   *    glyph_index ::
+   *       The input glyph index.
+   *
+   * @output:
+   *    cid ::
+   *       The CID as an @FT_UInt.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *    This function only works with CID faces and OpenType fonts,
+   *    returning an error otherwise.
+   *
+   * @since:
+   *    2.3.9
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_CID_From_Glyph_Index( FT_Face   face,
+                               FT_UInt   glyph_index,
+                               FT_UInt  *cid );
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTCID_H__ */
+
+
+/* END */
diff --git a/include/freetype/fterrdef.h b/include/freetype/fterrdef.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/fterrdef.h
@@ -0,0 +1,247 @@
+/***************************************************************************/
+/*                                                                         */
+/*  fterrdef.h                                                             */
+/*                                                                         */
+/*    FreeType error codes (specification).                                */
+/*                                                                         */
+/*  Copyright 2002, 2004, 2006, 2007, 2010-2012 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*******************************************************************/
+  /*******************************************************************/
+  /*****                                                         *****/
+  /*****                LIST OF ERROR CODES/MESSAGES             *****/
+  /*****                                                         *****/
+  /*******************************************************************/
+  /*******************************************************************/
+
+
+  /* You need to define both FT_ERRORDEF_ and FT_NOERRORDEF_ before */
+  /* including this file.                                           */
+
+
+  /* generic errors */
+
+  FT_NOERRORDEF_( Ok,                                        0x00, \
+                  "no error" )
+
+  FT_ERRORDEF_( Cannot_Open_Resource,                        0x01, \
+                "cannot open resource" )
+  FT_ERRORDEF_( Unknown_File_Format,                         0x02, \
+                "unknown file format" )
+  FT_ERRORDEF_( Invalid_File_Format,                         0x03, \
+                "broken file" )
+  FT_ERRORDEF_( Invalid_Version,                             0x04, \
+                "invalid FreeType version" )
+  FT_ERRORDEF_( Lower_Module_Version,                        0x05, \
+                "module version is too low" )
+  FT_ERRORDEF_( Invalid_Argument,                            0x06, \
+                "invalid argument" )
+  FT_ERRORDEF_( Unimplemented_Feature,                       0x07, \
+                "unimplemented feature" )
+  FT_ERRORDEF_( Invalid_Table,                               0x08, \
+                "broken table" )
+  FT_ERRORDEF_( Invalid_Offset,                              0x09, \
+                "broken offset within table" )
+  FT_ERRORDEF_( Array_Too_Large,                             0x0A, \
+                "array allocation size too large" )
+  FT_ERRORDEF_( Missing_Module,                              0x0B, \
+                "missing module" )
+  FT_ERRORDEF_( Missing_Property,                            0x0C, \
+                "missing property" )
+
+  /* glyph/character errors */
+
+  FT_ERRORDEF_( Invalid_Glyph_Index,                         0x10, \
+                "invalid glyph index" )
+  FT_ERRORDEF_( Invalid_Character_Code,                      0x11, \
+                "invalid character code" )
+  FT_ERRORDEF_( Invalid_Glyph_Format,                        0x12, \
+                "unsupported glyph image format" )
+  FT_ERRORDEF_( Cannot_Render_Glyph,                         0x13, \
+                "cannot render this glyph format" )
+  FT_ERRORDEF_( Invalid_Outline,                             0x14, \
+                "invalid outline" )
+  FT_ERRORDEF_( Invalid_Composite,                           0x15, \
+                "invalid composite glyph" )
+  FT_ERRORDEF_( Too_Many_Hints,                              0x16, \
+                "too many hints" )
+  FT_ERRORDEF_( Invalid_Pixel_Size,                          0x17, \
+                "invalid pixel size" )
+
+  /* handle errors */
+
+  FT_ERRORDEF_( Invalid_Handle,                              0x20, \
+                "invalid object handle" )
+  FT_ERRORDEF_( Invalid_Library_Handle,                      0x21, \
+                "invalid library handle" )
+  FT_ERRORDEF_( Invalid_Driver_Handle,                       0x22, \
+                "invalid module handle" )
+  FT_ERRORDEF_( Invalid_Face_Handle,                         0x23, \
+                "invalid face handle" )
+  FT_ERRORDEF_( Invalid_Size_Handle,                         0x24, \
+                "invalid size handle" )
+  FT_ERRORDEF_( Invalid_Slot_Handle,                         0x25, \
+                "invalid glyph slot handle" )
+  FT_ERRORDEF_( Invalid_CharMap_Handle,                      0x26, \
+                "invalid charmap handle" )
+  FT_ERRORDEF_( Invalid_Cache_Handle,                        0x27, \
+                "invalid cache manager handle" )
+  FT_ERRORDEF_( Invalid_Stream_Handle,                       0x28, \
+                "invalid stream handle" )
+
+  /* driver errors */
+
+  FT_ERRORDEF_( Too_Many_Drivers,                            0x30, \
+                "too many modules" )
+  FT_ERRORDEF_( Too_Many_Extensions,                         0x31, \
+                "too many extensions" )
+
+  /* memory errors */
+
+  FT_ERRORDEF_( Out_Of_Memory,                               0x40, \
+                "out of memory" )
+  FT_ERRORDEF_( Unlisted_Object,                             0x41, \
+                "unlisted object" )
+
+  /* stream errors */
+
+  FT_ERRORDEF_( Cannot_Open_Stream,                          0x51, \
+                "cannot open stream" )
+  FT_ERRORDEF_( Invalid_Stream_Seek,                         0x52, \
+                "invalid stream seek" )
+  FT_ERRORDEF_( Invalid_Stream_Skip,                         0x53, \
+                "invalid stream skip" )
+  FT_ERRORDEF_( Invalid_Stream_Read,                         0x54, \
+                "invalid stream read" )
+  FT_ERRORDEF_( Invalid_Stream_Operation,                    0x55, \
+                "invalid stream operation" )
+  FT_ERRORDEF_( Invalid_Frame_Operation,                     0x56, \
+                "invalid frame operation" )
+  FT_ERRORDEF_( Nested_Frame_Access,                         0x57, \
+                "nested frame access" )
+  FT_ERRORDEF_( Invalid_Frame_Read,                          0x58, \
+                "invalid frame read" )
+
+  /* raster errors */
+
+  FT_ERRORDEF_( Raster_Uninitialized,                        0x60, \
+                "raster uninitialized" )
+  FT_ERRORDEF_( Raster_Corrupted,                            0x61, \
+                "raster corrupted" )
+  FT_ERRORDEF_( Raster_Overflow,                             0x62, \
+                "raster overflow" )
+  FT_ERRORDEF_( Raster_Negative_Height,                      0x63, \
+                "negative height while rastering" )
+
+  /* cache errors */
+
+  FT_ERRORDEF_( Too_Many_Caches,                             0x70, \
+                "too many registered caches" )
+
+  /* TrueType and SFNT errors */
+
+  FT_ERRORDEF_( Invalid_Opcode,                              0x80, \
+                "invalid opcode" )
+  FT_ERRORDEF_( Too_Few_Arguments,                           0x81, \
+                "too few arguments" )
+  FT_ERRORDEF_( Stack_Overflow,                              0x82, \
+                "stack overflow" )
+  FT_ERRORDEF_( Code_Overflow,                               0x83, \
+                "code overflow" )
+  FT_ERRORDEF_( Bad_Argument,                                0x84, \
+                "bad argument" )
+  FT_ERRORDEF_( Divide_By_Zero,                              0x85, \
+                "division by zero" )
+  FT_ERRORDEF_( Invalid_Reference,                           0x86, \
+                "invalid reference" )
+  FT_ERRORDEF_( Debug_OpCode,                                0x87, \
+                "found debug opcode" )
+  FT_ERRORDEF_( ENDF_In_Exec_Stream,                         0x88, \
+                "found ENDF opcode in execution stream" )
+  FT_ERRORDEF_( Nested_DEFS,                                 0x89, \
+                "nested DEFS" )
+  FT_ERRORDEF_( Invalid_CodeRange,                           0x8A, \
+                "invalid code range" )
+  FT_ERRORDEF_( Execution_Too_Long,                          0x8B, \
+                "execution context too long" )
+  FT_ERRORDEF_( Too_Many_Function_Defs,                      0x8C, \
+                "too many function definitions" )
+  FT_ERRORDEF_( Too_Many_Instruction_Defs,                   0x8D, \
+                "too many instruction definitions" )
+  FT_ERRORDEF_( Table_Missing,                               0x8E, \
+                "SFNT font table missing" )
+  FT_ERRORDEF_( Horiz_Header_Missing,                        0x8F, \
+                "horizontal header (hhea) table missing" )
+  FT_ERRORDEF_( Locations_Missing,                           0x90, \
+                "locations (loca) table missing" )
+  FT_ERRORDEF_( Name_Table_Missing,                          0x91, \
+                "name table missing" )
+  FT_ERRORDEF_( CMap_Table_Missing,                          0x92, \
+                "character map (cmap) table missing" )
+  FT_ERRORDEF_( Hmtx_Table_Missing,                          0x93, \
+                "horizontal metrics (hmtx) table missing" )
+  FT_ERRORDEF_( Post_Table_Missing,                          0x94, \
+                "PostScript (post) table missing" )
+  FT_ERRORDEF_( Invalid_Horiz_Metrics,                       0x95, \
+                "invalid horizontal metrics" )
+  FT_ERRORDEF_( Invalid_CharMap_Format,                      0x96, \
+                "invalid character map (cmap) format" )
+  FT_ERRORDEF_( Invalid_PPem,                                0x97, \
+                "invalid ppem value" )
+  FT_ERRORDEF_( Invalid_Vert_Metrics,                        0x98, \
+                "invalid vertical metrics" )
+  FT_ERRORDEF_( Could_Not_Find_Context,                      0x99, \
+                "could not find context" )
+  FT_ERRORDEF_( Invalid_Post_Table_Format,                   0x9A, \
+                "invalid PostScript (post) table format" )
+  FT_ERRORDEF_( Invalid_Post_Table,                          0x9B, \
+                "invalid PostScript (post) table" )
+
+  /* CFF, CID, and Type 1 errors */
+
+  FT_ERRORDEF_( Syntax_Error,                                0xA0, \
+                "opcode syntax error" )
+  FT_ERRORDEF_( Stack_Underflow,                             0xA1, \
+                "argument stack underflow" )
+  FT_ERRORDEF_( Ignore,                                      0xA2, \
+                "ignore" )
+  FT_ERRORDEF_( No_Unicode_Glyph_Name,                       0xA3, \
+                "no Unicode glyph name found" )
+
+  /* BDF errors */
+
+  FT_ERRORDEF_( Missing_Startfont_Field,                     0xB0, \
+                "`STARTFONT' field missing" )
+  FT_ERRORDEF_( Missing_Font_Field,                          0xB1, \
+                "`FONT' field missing" )
+  FT_ERRORDEF_( Missing_Size_Field,                          0xB2, \
+                "`SIZE' field missing" )
+  FT_ERRORDEF_( Missing_Fontboundingbox_Field,               0xB3, \
+                "`FONTBOUNDINGBOX' field missing" )
+  FT_ERRORDEF_( Missing_Chars_Field,                         0xB4, \
+                "`CHARS' field missing" )
+  FT_ERRORDEF_( Missing_Startchar_Field,                     0xB5, \
+                "`STARTCHAR' field missing" )
+  FT_ERRORDEF_( Missing_Encoding_Field,                      0xB6, \
+                "`ENCODING' field missing" )
+  FT_ERRORDEF_( Missing_Bbx_Field,                           0xB7, \
+                "`BBX' field missing" )
+  FT_ERRORDEF_( Bbx_Too_Big,                                 0xB8, \
+                "`BBX' too big" )
+  FT_ERRORDEF_( Corrupted_Font_Header,                       0xB9, \
+                "Font header corrupted or missing fields" )
+  FT_ERRORDEF_( Corrupted_Font_Glyphs,                       0xBA, \
+                "Font glyphs corrupted or missing fields" )
+
+
+/* END */
diff --git a/include/freetype/fterrors.h b/include/freetype/fterrors.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/fterrors.h
@@ -0,0 +1,207 @@
+/***************************************************************************/
+/*                                                                         */
+/*  fterrors.h                                                             */
+/*                                                                         */
+/*    FreeType error code handling (specification).                        */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2004, 2007 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This special header file is used to define the handling of FT2        */
+  /* enumeration constants.  It can also be used to generate error message */
+  /* strings with a small macro trick explained below.                     */
+  /*                                                                       */
+  /* I - Error Formats                                                     */
+  /* -----------------                                                     */
+  /*                                                                       */
+  /*   The configuration macro FT_CONFIG_OPTION_USE_MODULE_ERRORS can be   */
+  /*   defined in ftoption.h in order to make the higher byte indicate     */
+  /*   the module where the error has happened (this is not compatible     */
+  /*   with standard builds of FreeType 2).  You can then use the macro    */
+  /*   FT_ERROR_BASE macro to extract the generic error code from an       */
+  /*   FT_Error value.                                                     */
+  /*                                                                       */
+  /*                                                                       */
+  /* II - Error Message strings                                            */
+  /* --------------------------                                            */
+  /*                                                                       */
+  /*   The error definitions below are made through special macros that    */
+  /*   allow client applications to build a table of error message strings */
+  /*   if they need it.  The strings are not included in a normal build of */
+  /*   FreeType 2 to save space (most client applications do not use       */
+  /*   them).                                                              */
+  /*                                                                       */
+  /*   To do so, you have to define the following macros before including  */
+  /*   this file:                                                          */
+  /*                                                                       */
+  /*   FT_ERROR_START_LIST ::                                              */
+  /*     This macro is called before anything else to define the start of  */
+  /*     the error list.  It is followed by several FT_ERROR_DEF calls     */
+  /*     (see below).                                                      */
+  /*                                                                       */
+  /*   FT_ERROR_DEF( e, v, s ) ::                                          */
+  /*     This macro is called to define one single error.                  */
+  /*     `e' is the error code identifier (e.g. FT_Err_Invalid_Argument).  */
+  /*     `v' is the error numerical value.                                 */
+  /*     `s' is the corresponding error string.                            */
+  /*                                                                       */
+  /*   FT_ERROR_END_LIST ::                                                */
+  /*     This macro ends the list.                                         */
+  /*                                                                       */
+  /*   Additionally, you have to undefine __FTERRORS_H__ before #including */
+  /*   this file.                                                          */
+  /*                                                                       */
+  /*   Here is a simple example:                                           */
+  /*                                                                       */
+  /*     {                                                                 */
+  /*       #undef __FTERRORS_H__                                           */
+  /*       #define FT_ERRORDEF( e, v, s )  { e, s },                       */
+  /*       #define FT_ERROR_START_LIST     {                               */
+  /*       #define FT_ERROR_END_LIST       { 0, 0 } };                     */
+  /*                                                                       */
+  /*       const struct                                                    */
+  /*       {                                                               */
+  /*         int          err_code;                                        */
+  /*         const char*  err_msg;                                         */
+  /*       } ft_errors[] =                                                 */
+  /*                                                                       */
+  /*       #include FT_ERRORS_H                                            */
+  /*     }                                                                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTERRORS_H__
+#define __FTERRORS_H__
+
+
+  /* include module base error codes */
+#include FT_MODULE_ERRORS_H
+
+
+  /*******************************************************************/
+  /*******************************************************************/
+  /*****                                                         *****/
+  /*****                       SETUP MACROS                      *****/
+  /*****                                                         *****/
+  /*******************************************************************/
+  /*******************************************************************/
+
+
+#undef  FT_NEED_EXTERN_C
+
+#undef  FT_ERR_XCAT
+#undef  FT_ERR_CAT
+
+#define FT_ERR_XCAT( x, y )  x ## y
+#define FT_ERR_CAT( x, y )   FT_ERR_XCAT( x, y )
+
+
+  /* FT_ERR_PREFIX is used as a prefix for error identifiers. */
+  /* By default, we use `FT_Err_'.                            */
+  /*                                                          */
+#ifndef FT_ERR_PREFIX
+#define FT_ERR_PREFIX  FT_Err_
+#endif
+
+
+  /* FT_ERR_BASE is used as the base for module-specific errors. */
+  /*                                                             */
+#ifdef FT_CONFIG_OPTION_USE_MODULE_ERRORS
+
+#ifndef FT_ERR_BASE
+#define FT_ERR_BASE  FT_Mod_Err_Base
+#endif
+
+#else
+
+#undef FT_ERR_BASE
+#define FT_ERR_BASE  0
+
+#endif /* FT_CONFIG_OPTION_USE_MODULE_ERRORS */
+
+
+  /* If FT_ERRORDEF is not defined, we need to define a simple */
+  /* enumeration type.                                         */
+  /*                                                           */
+#ifndef FT_ERRORDEF
+
+#define FT_ERRORDEF( e, v, s )  e = v,
+#define FT_ERROR_START_LIST     enum {
+#define FT_ERROR_END_LIST       FT_ERR_CAT( FT_ERR_PREFIX, Max ) };
+
+#ifdef __cplusplus
+#define FT_NEED_EXTERN_C
+  extern "C" {
+#endif
+
+#endif /* !FT_ERRORDEF */
+
+
+  /* this macro is used to define an error */
+#define FT_ERRORDEF_( e, v, s )   \
+          FT_ERRORDEF( FT_ERR_CAT( FT_ERR_PREFIX, e ), v + FT_ERR_BASE, s )
+
+  /* this is only used for <module>_Err_Ok, which must be 0! */
+#define FT_NOERRORDEF_( e, v, s ) \
+          FT_ERRORDEF( FT_ERR_CAT( FT_ERR_PREFIX, e ), v, s )
+
+
+#ifdef FT_ERROR_START_LIST
+  FT_ERROR_START_LIST
+#endif
+
+
+  /* now include the error codes */
+#include FT_ERROR_DEFINITIONS_H
+
+
+#ifdef FT_ERROR_END_LIST
+  FT_ERROR_END_LIST
+#endif
+
+
+  /*******************************************************************/
+  /*******************************************************************/
+  /*****                                                         *****/
+  /*****                      SIMPLE CLEANUP                     *****/
+  /*****                                                         *****/
+  /*******************************************************************/
+  /*******************************************************************/
+
+#ifdef FT_NEED_EXTERN_C
+  }
+#endif
+
+#undef FT_ERROR_START_LIST
+#undef FT_ERROR_END_LIST
+
+#undef FT_ERRORDEF
+#undef FT_ERRORDEF_
+#undef FT_NOERRORDEF_
+
+#undef FT_NEED_EXTERN_C
+#undef FT_ERR_BASE
+
+  /* FT_KEEP_ERR_PREFIX is needed for ftvalid.h */
+#ifndef FT_KEEP_ERR_PREFIX
+#undef FT_ERR_PREFIX
+#else
+#undef FT_KEEP_ERR_PREFIX
+#endif
+
+#endif /* __FTERRORS_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftgasp.h b/include/freetype/ftgasp.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftgasp.h
@@ -0,0 +1,128 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftgasp.h                                                               */
+/*                                                                         */
+/*    Access of TrueType's `gasp' table (specification).                   */
+/*                                                                         */
+/*  Copyright 2007, 2008, 2011 by                                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef _FT_GASP_H_
+#define _FT_GASP_H_
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+  /***************************************************************************
+   *
+   * @section:
+   *   gasp_table
+   *
+   * @title:
+   *   Gasp Table
+   *
+   * @abstract:
+   *   Retrieving TrueType `gasp' table entries.
+   *
+   * @description:
+   *   The function @FT_Get_Gasp can be used to query a TrueType or OpenType
+   *   font for specific entries in its `gasp' table, if any.  This is
+   *   mainly useful when implementing native TrueType hinting with the
+   *   bytecode interpreter to duplicate the Windows text rendering results.
+   */
+
+  /*************************************************************************
+   *
+   * @enum:
+   *   FT_GASP_XXX
+   *
+   * @description:
+   *   A list of values and/or bit-flags returned by the @FT_Get_Gasp
+   *   function.
+   *
+   * @values:
+   *   FT_GASP_NO_TABLE ::
+   *     This special value means that there is no GASP table in this face.
+   *     It is up to the client to decide what to do.
+   *
+   *   FT_GASP_DO_GRIDFIT ::
+   *     Grid-fitting and hinting should be performed at the specified ppem.
+   *     This *really* means TrueType bytecode interpretation.  If this bit
+   *     is not set, no hinting gets applied.
+   *
+   *   FT_GASP_DO_GRAY ::
+   *     Anti-aliased rendering should be performed at the specified ppem.
+   *     If not set, do monochrome rendering.
+   *
+   *   FT_GASP_SYMMETRIC_SMOOTHING ::
+   *     If set, smoothing along multiple axes must be used with ClearType.
+   *
+   *   FT_GASP_SYMMETRIC_GRIDFIT ::
+   *     Grid-fitting must be used with ClearType's symmetric smoothing.
+   *
+   * @note:
+   *   The bit-flags `FT_GASP_DO_GRIDFIT' and `FT_GASP_DO_GRAY' are to be
+   *   used for standard font rasterization only.  Independently of that,
+   *   `FT_GASP_SYMMETRIC_SMOOTHING' and `FT_GASP_SYMMETRIC_GRIDFIT' are to
+   *   be used if ClearType is enabled (and `FT_GASP_DO_GRIDFIT' and
+   *   `FT_GASP_DO_GRAY' are consequently ignored).
+   *
+   *   `ClearType' is Microsoft's implementation of LCD rendering, partly
+   *   protected by patents.
+   *
+   * @since:
+   *   2.3.0
+   */
+#define FT_GASP_NO_TABLE               -1
+#define FT_GASP_DO_GRIDFIT           0x01
+#define FT_GASP_DO_GRAY              0x02
+#define FT_GASP_SYMMETRIC_SMOOTHING  0x08
+#define FT_GASP_SYMMETRIC_GRIDFIT    0x10
+
+
+  /*************************************************************************
+   *
+   * @func:
+   *   FT_Get_Gasp
+   *
+   * @description:
+   *   Read the `gasp' table from a TrueType or OpenType font file and
+   *   return the entry corresponding to a given character pixel size.
+   *
+   * @input:
+   *   face :: The source face handle.
+   *   ppem :: The vertical character pixel size.
+   *
+   * @return:
+   *   Bit flags (see @FT_GASP_XXX), or @FT_GASP_NO_TABLE if there is no
+   *   `gasp' table in the face.
+   *
+   * @since:
+   *   2.3.0
+   */
+  FT_EXPORT( FT_Int )
+  FT_Get_Gasp( FT_Face  face,
+               FT_UInt  ppem );
+
+/* */
+
+#endif /* _FT_GASP_H_ */
+
+
+/* END */
diff --git a/include/freetype/ftglyph.h b/include/freetype/ftglyph.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftglyph.h
@@ -0,0 +1,620 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftglyph.h                                                              */
+/*                                                                         */
+/*    FreeType convenience functions to handle glyphs (specification).     */
+/*                                                                         */
+/*  Copyright 1996-2003, 2006, 2008, 2009, 2011 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This file contains the definition of several convenience functions    */
+  /* that can be used by client applications to easily retrieve glyph      */
+  /* bitmaps and outlines from a given face.                               */
+  /*                                                                       */
+  /* These functions should be optional if you are writing a font server   */
+  /* or text layout engine on top of FreeType.  However, they are pretty   */
+  /* handy for many other simple uses of the library.                      */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTGLYPH_H__
+#define __FTGLYPH_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    glyph_management                                                   */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Glyph Management                                                   */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Generic interface to manage individual glyph data.                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains definitions used to manage glyph data        */
+  /*    through generic FT_Glyph objects.  Each of them can contain a      */
+  /*    bitmap, a vector outline, or even images in other formats.         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* forward declaration to a private type */
+  typedef struct FT_Glyph_Class_  FT_Glyph_Class;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Glyph                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Handle to an object used to model generic glyph images.  It is a   */
+  /*    pointer to the @FT_GlyphRec structure and can contain a glyph      */
+  /*    bitmap or pointer.                                                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Glyph objects are not owned by the library.  You must thus release */
+  /*    them manually (through @FT_Done_Glyph) _before_ calling            */
+  /*    @FT_Done_FreeType.                                                 */
+  /*                                                                       */
+  typedef struct FT_GlyphRec_*  FT_Glyph;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_GlyphRec                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The root glyph structure contains a given glyph image plus its     */
+  /*    advance width in 16.16 fixed float format.                         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    library :: A handle to the FreeType library object.                */
+  /*                                                                       */
+  /*    clazz   :: A pointer to the glyph's class.  Private.               */
+  /*                                                                       */
+  /*    format  :: The format of the glyph's image.                        */
+  /*                                                                       */
+  /*    advance :: A 16.16 vector that gives the glyph's advance width.    */
+  /*                                                                       */
+  typedef struct  FT_GlyphRec_
+  {
+    FT_Library             library;
+    const FT_Glyph_Class*  clazz;
+    FT_Glyph_Format        format;
+    FT_Vector              advance;
+
+  } FT_GlyphRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_BitmapGlyph                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to an object used to model a bitmap glyph image.  This is */
+  /*    a sub-class of @FT_Glyph, and a pointer to @FT_BitmapGlyphRec.     */
+  /*                                                                       */
+  typedef struct FT_BitmapGlyphRec_*  FT_BitmapGlyph;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_BitmapGlyphRec                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used for bitmap glyph images.  This really is a        */
+  /*    `sub-class' of @FT_GlyphRec.                                       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    root   :: The root @FT_Glyph fields.                               */
+  /*                                                                       */
+  /*    left   :: The left-side bearing, i.e., the horizontal distance     */
+  /*              from the current pen position to the left border of the  */
+  /*              glyph bitmap.                                            */
+  /*                                                                       */
+  /*    top    :: The top-side bearing, i.e., the vertical distance from   */
+  /*              the current pen position to the top border of the glyph  */
+  /*              bitmap.  This distance is positive for upwards~y!        */
+  /*                                                                       */
+  /*    bitmap :: A descriptor for the bitmap.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You can typecast an @FT_Glyph to @FT_BitmapGlyph if you have       */
+  /*    `glyph->format == FT_GLYPH_FORMAT_BITMAP'.  This lets you access   */
+  /*    the bitmap's contents easily.                                      */
+  /*                                                                       */
+  /*    The corresponding pixel buffer is always owned by @FT_BitmapGlyph  */
+  /*    and is thus created and destroyed with it.                         */
+  /*                                                                       */
+  typedef struct  FT_BitmapGlyphRec_
+  {
+    FT_GlyphRec  root;
+    FT_Int       left;
+    FT_Int       top;
+    FT_Bitmap    bitmap;
+
+  } FT_BitmapGlyphRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_OutlineGlyph                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to an object used to model an outline glyph image.  This  */
+  /*    is a sub-class of @FT_Glyph, and a pointer to @FT_OutlineGlyphRec. */
+  /*                                                                       */
+  typedef struct FT_OutlineGlyphRec_*  FT_OutlineGlyph;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_OutlineGlyphRec                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used for outline (vectorial) glyph images.  This       */
+  /*    really is a `sub-class' of @FT_GlyphRec.                           */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    root    :: The root @FT_Glyph fields.                              */
+  /*                                                                       */
+  /*    outline :: A descriptor for the outline.                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You can typecast an @FT_Glyph to @FT_OutlineGlyph if you have      */
+  /*    `glyph->format == FT_GLYPH_FORMAT_OUTLINE'.  This lets you access  */
+  /*    the outline's content easily.                                      */
+  /*                                                                       */
+  /*    As the outline is extracted from a glyph slot, its coordinates are */
+  /*    expressed normally in 26.6 pixels, unless the flag                 */
+  /*    @FT_LOAD_NO_SCALE was used in @FT_Load_Glyph() or @FT_Load_Char(). */
+  /*                                                                       */
+  /*    The outline's tables are always owned by the object and are        */
+  /*    destroyed with it.                                                 */
+  /*                                                                       */
+  typedef struct  FT_OutlineGlyphRec_
+  {
+    FT_GlyphRec  root;
+    FT_Outline   outline;
+
+  } FT_OutlineGlyphRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Glyph                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to extract a glyph image from a slot.  Note that   */
+  /*    the created @FT_Glyph object must be released with @FT_Done_Glyph. */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    slot   :: A handle to the source glyph slot.                       */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aglyph :: A handle to the glyph object.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Glyph( FT_GlyphSlot  slot,
+                FT_Glyph     *aglyph );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Glyph_Copy                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to copy a glyph image.  Note that the created      */
+  /*    @FT_Glyph object must be released with @FT_Done_Glyph.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    source :: A handle to the source glyph object.                     */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    target :: A handle to the target glyph object.  0~in case of       */
+  /*              error.                                                   */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Glyph_Copy( FT_Glyph   source,
+                 FT_Glyph  *target );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Glyph_Transform                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Transform a glyph image if its format is scalable.                 */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    glyph  :: A handle to the target glyph object.                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    matrix :: A pointer to a 2x2 matrix to apply.                      */
+  /*                                                                       */
+  /*    delta  :: A pointer to a 2d vector to apply.  Coordinates are      */
+  /*              expressed in 1/64th of a pixel.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code (if not 0, the glyph format is not scalable).  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The 2x2 transformation matrix is also applied to the glyph's       */
+  /*    advance vector.                                                    */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Glyph_Transform( FT_Glyph    glyph,
+                      FT_Matrix*  matrix,
+                      FT_Vector*  delta );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Glyph_BBox_Mode                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The mode how the values of @FT_Glyph_Get_CBox are returned.        */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_GLYPH_BBOX_UNSCALED ::                                          */
+  /*      Return unscaled font units.                                      */
+  /*                                                                       */
+  /*    FT_GLYPH_BBOX_SUBPIXELS ::                                         */
+  /*      Return unfitted 26.6 coordinates.                                */
+  /*                                                                       */
+  /*    FT_GLYPH_BBOX_GRIDFIT ::                                           */
+  /*      Return grid-fitted 26.6 coordinates.                             */
+  /*                                                                       */
+  /*    FT_GLYPH_BBOX_TRUNCATE ::                                          */
+  /*      Return coordinates in integer pixels.                            */
+  /*                                                                       */
+  /*    FT_GLYPH_BBOX_PIXELS ::                                            */
+  /*      Return grid-fitted pixel coordinates.                            */
+  /*                                                                       */
+  typedef enum  FT_Glyph_BBox_Mode_
+  {
+    FT_GLYPH_BBOX_UNSCALED  = 0,
+    FT_GLYPH_BBOX_SUBPIXELS = 0,
+    FT_GLYPH_BBOX_GRIDFIT   = 1,
+    FT_GLYPH_BBOX_TRUNCATE  = 2,
+    FT_GLYPH_BBOX_PIXELS    = 3
+
+  } FT_Glyph_BBox_Mode;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    ft_glyph_bbox_xxx                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    These constants are deprecated.  Use the corresponding             */
+  /*    @FT_Glyph_BBox_Mode values instead.                                */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*   ft_glyph_bbox_unscaled  :: See @FT_GLYPH_BBOX_UNSCALED.             */
+  /*   ft_glyph_bbox_subpixels :: See @FT_GLYPH_BBOX_SUBPIXELS.            */
+  /*   ft_glyph_bbox_gridfit   :: See @FT_GLYPH_BBOX_GRIDFIT.              */
+  /*   ft_glyph_bbox_truncate  :: See @FT_GLYPH_BBOX_TRUNCATE.             */
+  /*   ft_glyph_bbox_pixels    :: See @FT_GLYPH_BBOX_PIXELS.               */
+  /*                                                                       */
+#define ft_glyph_bbox_unscaled   FT_GLYPH_BBOX_UNSCALED
+#define ft_glyph_bbox_subpixels  FT_GLYPH_BBOX_SUBPIXELS
+#define ft_glyph_bbox_gridfit    FT_GLYPH_BBOX_GRIDFIT
+#define ft_glyph_bbox_truncate   FT_GLYPH_BBOX_TRUNCATE
+#define ft_glyph_bbox_pixels     FT_GLYPH_BBOX_PIXELS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Glyph_Get_CBox                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return a glyph's `control box'.  The control box encloses all the  */
+  /*    outline's points, including Bézier control points.  Though it      */
+  /*    coincides with the exact bounding box for most glyphs, it can be   */
+  /*    slightly larger in some situations (like when rotating an outline  */
+  /*    which contains Bézier outside arcs).                               */
+  /*                                                                       */
+  /*    Computing the control box is very fast, while getting the bounding */
+  /*    box can take much more time as it needs to walk over all segments  */
+  /*    and arcs in the outline.  To get the latter, you can use the       */
+  /*    `ftbbox' component which is dedicated to this single task.         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    glyph :: A handle to the source glyph object.                      */
+  /*                                                                       */
+  /*    mode  :: The mode which indicates how to interpret the returned    */
+  /*             bounding box values.                                      */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    acbox :: The glyph coordinate bounding box.  Coordinates are       */
+  /*             expressed in 1/64th of pixels if it is grid-fitted.       */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Coordinates are relative to the glyph origin, using the y~upwards  */
+  /*    convention.                                                        */
+  /*                                                                       */
+  /*    If the glyph has been loaded with @FT_LOAD_NO_SCALE, `bbox_mode'   */
+  /*    must be set to @FT_GLYPH_BBOX_UNSCALED to get unscaled font        */
+  /*    units in 26.6 pixel format.  The value @FT_GLYPH_BBOX_SUBPIXELS    */
+  /*    is another name for this constant.                                 */
+  /*                                                                       */
+  /*    If the font is tricky and the glyph has been loaded with           */
+  /*    @FT_LOAD_NO_SCALE, the resulting CBox is meaningless.  To get      */
+  /*    reasonable values for the CBox it is necessary to load the glyph   */
+  /*    at a large ppem value (so that the hinting instructions can        */
+  /*    properly shift and scale the subglyphs), then extracting the CBox  */
+  /*    which can be eventually converted back to font units.              */
+  /*                                                                       */
+  /*    Note that the maximum coordinates are exclusive, which means that  */
+  /*    one can compute the width and height of the glyph image (be it in  */
+  /*    integer or 26.6 pixels) as:                                        */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      width  = bbox.xMax - bbox.xMin;                                  */
+  /*      height = bbox.yMax - bbox.yMin;                                  */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    Note also that for 26.6 coordinates, if `bbox_mode' is set to      */
+  /*    @FT_GLYPH_BBOX_GRIDFIT, the coordinates will also be grid-fitted,  */
+  /*    which corresponds to:                                              */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      bbox.xMin = FLOOR(bbox.xMin);                                    */
+  /*      bbox.yMin = FLOOR(bbox.yMin);                                    */
+  /*      bbox.xMax = CEILING(bbox.xMax);                                  */
+  /*      bbox.yMax = CEILING(bbox.yMax);                                  */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    To get the bbox in pixel coordinates, set `bbox_mode' to           */
+  /*    @FT_GLYPH_BBOX_TRUNCATE.                                           */
+  /*                                                                       */
+  /*    To get the bbox in grid-fitted pixel coordinates, set `bbox_mode'  */
+  /*    to @FT_GLYPH_BBOX_PIXELS.                                          */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Glyph_Get_CBox( FT_Glyph  glyph,
+                     FT_UInt   bbox_mode,
+                     FT_BBox  *acbox );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Glyph_To_Bitmap                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Convert a given glyph object to a bitmap glyph object.             */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    the_glyph   :: A pointer to a handle to the target glyph.          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    render_mode :: An enumeration that describes how the data is       */
+  /*                   rendered.                                           */
+  /*                                                                       */
+  /*    origin      :: A pointer to a vector used to translate the glyph   */
+  /*                   image before rendering.  Can be~0 (if no            */
+  /*                   translation).  The origin is expressed in           */
+  /*                   26.6 pixels.                                        */
+  /*                                                                       */
+  /*    destroy     :: A boolean that indicates that the original glyph    */
+  /*                   image should be destroyed by this function.  It is  */
+  /*                   never destroyed in case of error.                   */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function does nothing if the glyph format isn't scalable.     */
+  /*                                                                       */
+  /*    The glyph image is translated with the `origin' vector before      */
+  /*    rendering.                                                         */
+  /*                                                                       */
+  /*    The first parameter is a pointer to an @FT_Glyph handle, that will */
+  /*    be _replaced_ by this function (with newly allocated data).        */
+  /*    Typically, you would use (omitting error handling):                */
+  /*                                                                       */
+  /*                                                                       */
+  /*      {                                                                */
+  /*        FT_Glyph        glyph;                                         */
+  /*        FT_BitmapGlyph  glyph_bitmap;                                  */
+  /*                                                                       */
+  /*                                                                       */
+  /*        // load glyph                                                  */
+  /*        error = FT_Load_Char( face, glyph_index, FT_LOAD_DEFAUT );     */
+  /*                                                                       */
+  /*        // extract glyph image                                         */
+  /*        error = FT_Get_Glyph( face->glyph, &glyph );                   */
+  /*                                                                       */
+  /*        // convert to a bitmap (default render mode + destroying old)  */
+  /*        if ( glyph->format != FT_GLYPH_FORMAT_BITMAP )                 */
+  /*        {                                                              */
+  /*          error = FT_Glyph_To_Bitmap( &glyph, FT_RENDER_MODE_NORMAL,   */
+  /*                                      0, 1 );                          */
+  /*          if ( error ) // `glyph' unchanged                            */
+  /*            ...                                                        */
+  /*        }                                                              */
+  /*                                                                       */
+  /*        // access bitmap content by typecasting                        */
+  /*        glyph_bitmap = (FT_BitmapGlyph)glyph;                          */
+  /*                                                                       */
+  /*        // do funny stuff with it, like blitting/drawing               */
+  /*        ...                                                            */
+  /*                                                                       */
+  /*        // discard glyph image (bitmap or not)                         */
+  /*        FT_Done_Glyph( glyph );                                        */
+  /*      }                                                                */
+  /*                                                                       */
+  /*                                                                       */
+  /*    Here another example, again without error handling:                */
+  /*                                                                       */
+  /*                                                                       */
+  /*      {                                                                */
+  /*        FT_Glyph  glyphs[MAX_GLYPHS]                                   */
+  /*                                                                       */
+  /*                                                                       */
+  /*        ...                                                            */
+  /*                                                                       */
+  /*        for ( idx = 0; i < MAX_GLYPHS; i++ )                           */
+  /*          error = FT_Load_Glyph( face, idx, FT_LOAD_DEFAULT ) ||       */
+  /*                  FT_Get_Glyph ( face->glyph, &glyph[idx] );           */
+  /*                                                                       */
+  /*        ...                                                            */
+  /*                                                                       */
+  /*        for ( idx = 0; i < MAX_GLYPHS; i++ )                           */
+  /*        {                                                              */
+  /*          FT_Glyph  bitmap = glyphs[idx];                              */
+  /*                                                                       */
+  /*                                                                       */
+  /*          ...                                                          */
+  /*                                                                       */
+  /*          // after this call, `bitmap' no longer points into           */
+  /*          // the `glyphs' array (and the old value isn't destroyed)    */
+  /*          FT_Glyph_To_Bitmap( &bitmap, FT_RENDER_MODE_MONO, 0, 0 );    */
+  /*                                                                       */
+  /*          ...                                                          */
+  /*                                                                       */
+  /*          FT_Done_Glyph( bitmap );                                     */
+  /*        }                                                              */
+  /*                                                                       */
+  /*        ...                                                            */
+  /*                                                                       */
+  /*        for ( idx = 0; i < MAX_GLYPHS; i++ )                           */
+  /*          FT_Done_Glyph( glyphs[idx] );                                */
+  /*      }                                                                */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Glyph_To_Bitmap( FT_Glyph*       the_glyph,
+                      FT_Render_Mode  render_mode,
+                      FT_Vector*      origin,
+                      FT_Bool         destroy );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_Glyph                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroy a given glyph.                                             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    glyph :: A handle to the target glyph object.                      */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Done_Glyph( FT_Glyph  glyph );
+
+  /* */
+
+
+  /* other helpful functions */
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    computations                                                       */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Matrix_Multiply                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Perform the matrix operation `b = a*b'.                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: A pointer to matrix `a'.                                      */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    b :: A pointer to matrix `b'.                                      */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The result is undefined if either `a' or `b' is zero.              */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Matrix_Multiply( const FT_Matrix*  a,
+                      FT_Matrix*        b );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Matrix_Invert                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Invert a 2x2 matrix.  Return an error if it can't be inverted.     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    matrix :: A pointer to the target matrix.  Remains untouched in    */
+  /*              case of error.                                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Matrix_Invert( FT_Matrix*  matrix );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTGLYPH_H__ */
+
+
+/* END */
+
+
+/* Local Variables: */
+/* coding: utf-8    */
+/* End:             */
diff --git a/include/freetype/ftgxval.h b/include/freetype/ftgxval.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftgxval.h
@@ -0,0 +1,358 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftgxval.h                                                              */
+/*                                                                         */
+/*    FreeType API for validating TrueTypeGX/AAT tables (specification).   */
+/*                                                                         */
+/*  Copyright 2004, 2005, 2006 by                                          */
+/*  Masatake YAMATO, Redhat K.K,                                           */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+/***************************************************************************/
+/*                                                                         */
+/* gxvalid is derived from both gxlayout module and otvalid module.        */
+/* Development of gxlayout is supported by the Information-technology      */
+/* Promotion Agency(IPA), Japan.                                           */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTGXVAL_H__
+#define __FTGXVAL_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    gx_validation                                                      */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    TrueTypeGX/AAT Validation                                          */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    An API to validate TrueTypeGX/AAT tables.                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of functions to validate     */
+  /*    some TrueTypeGX tables (feat, mort, morx, bsln, just, kern, opbd,  */
+  /*    trak, prop, lcar).                                                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                                                                       */
+  /* Warning: Use FT_VALIDATE_XXX to validate a table.                     */
+  /*          Following definitions are for gxvalid developers.            */
+  /*                                                                       */
+  /*                                                                       */
+  /*************************************************************************/
+
+#define FT_VALIDATE_feat_INDEX     0
+#define FT_VALIDATE_mort_INDEX     1
+#define FT_VALIDATE_morx_INDEX     2
+#define FT_VALIDATE_bsln_INDEX     3
+#define FT_VALIDATE_just_INDEX     4
+#define FT_VALIDATE_kern_INDEX     5
+#define FT_VALIDATE_opbd_INDEX     6
+#define FT_VALIDATE_trak_INDEX     7
+#define FT_VALIDATE_prop_INDEX     8
+#define FT_VALIDATE_lcar_INDEX     9
+#define FT_VALIDATE_GX_LAST_INDEX  FT_VALIDATE_lcar_INDEX
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_VALIDATE_GX_LENGTH
+   *
+   * @description:
+   *   The number of tables checked in this module.  Use it as a parameter
+   *   for the `table-length' argument of function @FT_TrueTypeGX_Validate.
+   */
+#define FT_VALIDATE_GX_LENGTH     (FT_VALIDATE_GX_LAST_INDEX + 1)
+
+  /* */
+
+  /* Up to 0x1000 is used by otvalid.
+     Ox2xxx is reserved for feature OT extension. */
+#define FT_VALIDATE_GX_START 0x4000
+#define FT_VALIDATE_GX_BITFIELD( tag )                  \
+  ( FT_VALIDATE_GX_START << FT_VALIDATE_##tag##_INDEX )
+
+
+ /**********************************************************************
+  *
+  * @enum:
+  *    FT_VALIDATE_GXXXX
+  *
+  * @description:
+  *    A list of bit-field constants used with @FT_TrueTypeGX_Validate to
+  *    indicate which TrueTypeGX/AAT Type tables should be validated.
+  *
+  * @values:
+  *    FT_VALIDATE_feat ::
+  *      Validate `feat' table.
+  *
+  *    FT_VALIDATE_mort ::
+  *      Validate `mort' table.
+  *
+  *    FT_VALIDATE_morx ::
+  *      Validate `morx' table.
+  *
+  *    FT_VALIDATE_bsln ::
+  *      Validate `bsln' table.
+  *
+  *    FT_VALIDATE_just ::
+  *      Validate `just' table.
+  *
+  *    FT_VALIDATE_kern ::
+  *      Validate `kern' table.
+  *
+  *    FT_VALIDATE_opbd ::
+  *      Validate `opbd' table.
+  *
+  *    FT_VALIDATE_trak ::
+  *      Validate `trak' table.
+  *
+  *    FT_VALIDATE_prop ::
+  *      Validate `prop' table.
+  *
+  *    FT_VALIDATE_lcar ::
+  *      Validate `lcar' table.
+  *
+  *    FT_VALIDATE_GX ::
+  *      Validate all TrueTypeGX tables (feat, mort, morx, bsln, just, kern,
+  *      opbd, trak, prop and lcar).
+  *
+  */
+
+#define FT_VALIDATE_feat  FT_VALIDATE_GX_BITFIELD( feat )
+#define FT_VALIDATE_mort  FT_VALIDATE_GX_BITFIELD( mort )
+#define FT_VALIDATE_morx  FT_VALIDATE_GX_BITFIELD( morx )
+#define FT_VALIDATE_bsln  FT_VALIDATE_GX_BITFIELD( bsln )
+#define FT_VALIDATE_just  FT_VALIDATE_GX_BITFIELD( just )
+#define FT_VALIDATE_kern  FT_VALIDATE_GX_BITFIELD( kern )
+#define FT_VALIDATE_opbd  FT_VALIDATE_GX_BITFIELD( opbd )
+#define FT_VALIDATE_trak  FT_VALIDATE_GX_BITFIELD( trak )
+#define FT_VALIDATE_prop  FT_VALIDATE_GX_BITFIELD( prop )
+#define FT_VALIDATE_lcar  FT_VALIDATE_GX_BITFIELD( lcar )
+
+#define FT_VALIDATE_GX  ( FT_VALIDATE_feat | \
+                          FT_VALIDATE_mort | \
+                          FT_VALIDATE_morx | \
+                          FT_VALIDATE_bsln | \
+                          FT_VALIDATE_just | \
+                          FT_VALIDATE_kern | \
+                          FT_VALIDATE_opbd | \
+                          FT_VALIDATE_trak | \
+                          FT_VALIDATE_prop | \
+                          FT_VALIDATE_lcar )
+
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_TrueTypeGX_Validate
+  *
+  * @description:
+  *    Validate various TrueTypeGX tables to assure that all offsets and
+  *    indices are valid.  The idea is that a higher-level library which
+  *    actually does the text layout can access those tables without
+  *    error checking (which can be quite time consuming).
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  *    validation_flags ::
+  *       A bit field which specifies the tables to be validated.  See
+  *       @FT_VALIDATE_GXXXX for possible values.
+  *
+  *    table_length ::
+  *       The size of the `tables' array.  Normally, @FT_VALIDATE_GX_LENGTH
+  *       should be passed.
+  *
+  * @output:
+  *    tables ::
+  *       The array where all validated sfnt tables are stored.
+  *       The array itself must be allocated by a client.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   This function only works with TrueTypeGX fonts, returning an error
+  *   otherwise.
+  *
+  *   After use, the application should deallocate the buffers pointed to by
+  *   each `tables' element, by calling @FT_TrueTypeGX_Free.  A NULL value
+  *   indicates that the table either doesn't exist in the font, the
+  *   application hasn't asked for validation, or the validator doesn't have
+  *   the ability to validate the sfnt table.
+  */
+  FT_EXPORT( FT_Error )
+  FT_TrueTypeGX_Validate( FT_Face   face,
+                          FT_UInt   validation_flags,
+                          FT_Bytes  tables[FT_VALIDATE_GX_LENGTH],
+                          FT_UInt   table_length );
+
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_TrueTypeGX_Free
+  *
+  * @description:
+  *    Free the buffer allocated by TrueTypeGX validator.
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  *    table ::
+  *       The pointer to the buffer allocated by
+  *       @FT_TrueTypeGX_Validate.
+  *
+  * @note:
+  *   This function must be used to free the buffer allocated by
+  *   @FT_TrueTypeGX_Validate only.
+  */
+  FT_EXPORT( void )
+  FT_TrueTypeGX_Free( FT_Face   face,
+                      FT_Bytes  table );
+
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @enum:
+  *    FT_VALIDATE_CKERNXXX
+  *
+  * @description:
+  *    A list of bit-field constants used with @FT_ClassicKern_Validate
+  *    to indicate the classic kern dialect or dialects.  If the selected
+  *    type doesn't fit, @FT_ClassicKern_Validate regards the table as
+  *    invalid.
+  *
+  * @values:
+  *    FT_VALIDATE_MS ::
+  *      Handle the `kern' table as a classic Microsoft kern table.
+  *
+  *    FT_VALIDATE_APPLE ::
+  *      Handle the `kern' table as a classic Apple kern table.
+  *
+  *    FT_VALIDATE_CKERN ::
+  *      Handle the `kern' as either classic Apple or Microsoft kern table.
+  */
+#define FT_VALIDATE_MS     ( FT_VALIDATE_GX_START << 0 )
+#define FT_VALIDATE_APPLE  ( FT_VALIDATE_GX_START << 1 )
+
+#define FT_VALIDATE_CKERN  ( FT_VALIDATE_MS | FT_VALIDATE_APPLE )
+
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_ClassicKern_Validate
+  *
+  * @description:
+  *    Validate classic (16-bit format) kern table to assure that the offsets
+  *    and indices are valid.  The idea is that a higher-level library which
+  *    actually does the text layout can access those tables without error
+  *    checking (which can be quite time consuming).
+  *
+  *    The `kern' table validator in @FT_TrueTypeGX_Validate deals with both
+  *    the new 32-bit format and the classic 16-bit format, while
+  *    FT_ClassicKern_Validate only supports the classic 16-bit format.
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  *    validation_flags ::
+  *       A bit field which specifies the dialect to be validated.  See
+  *       @FT_VALIDATE_CKERNXXX for possible values.
+  *
+  * @output:
+  *    ckern_table ::
+  *       A pointer to the kern table.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   After use, the application should deallocate the buffers pointed to by
+  *   `ckern_table', by calling @FT_ClassicKern_Free.  A NULL value
+  *   indicates that the table doesn't exist in the font.
+  */
+  FT_EXPORT( FT_Error )
+  FT_ClassicKern_Validate( FT_Face    face,
+                           FT_UInt    validation_flags,
+                           FT_Bytes  *ckern_table );
+
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_ClassicKern_Free
+  *
+  * @description:
+  *    Free the buffer allocated by classic Kern validator.
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  *    table ::
+  *       The pointer to the buffer that is allocated by
+  *       @FT_ClassicKern_Validate.
+  *
+  * @note:
+  *   This function must be used to free the buffer allocated by
+  *   @FT_ClassicKern_Validate only.
+  */
+  FT_EXPORT( void )
+  FT_ClassicKern_Free( FT_Face   face,
+                       FT_Bytes  table );
+
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTGXVAL_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftgzip.h b/include/freetype/ftgzip.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftgzip.h
@@ -0,0 +1,102 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftgzip.h                                                               */
+/*                                                                         */
+/*    Gzip-compressed stream support.                                      */
+/*                                                                         */
+/*  Copyright 2002, 2003, 2004, 2006 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTGZIP_H__
+#define __FTGZIP_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    gzip                                                               */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    GZIP Streams                                                       */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Using gzip-compressed font files.                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of Gzip-specific functions.  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+ /************************************************************************
+  *
+  * @function:
+  *   FT_Stream_OpenGzip
+  *
+  * @description:
+  *   Open a new stream to parse gzip-compressed font files.  This is
+  *   mainly used to support the compressed `*.pcf.gz' fonts that come
+  *   with XFree86.
+  *
+  * @input:
+  *   stream ::
+  *     The target embedding stream.
+  *
+  *   source ::
+  *     The source stream.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   The source stream must be opened _before_ calling this function.
+  *
+  *   Calling the internal function `FT_Stream_Close' on the new stream will
+  *   *not* call `FT_Stream_Close' on the source stream.  None of the stream
+  *   objects will be released to the heap.
+  *
+  *   The stream implementation is very basic and resets the decompression
+  *   process each time seeking backwards is needed within the stream.
+  *
+  *   In certain builds of the library, gzip compression recognition is
+  *   automatically handled when calling @FT_New_Face or @FT_Open_Face.
+  *   This means that if no font driver is capable of handling the raw
+  *   compressed file, the library will try to open a gzipped stream from
+  *   it and re-open the face with it.
+  *
+  *   This function may return `FT_Err_Unimplemented_Feature' if your build
+  *   of FreeType was not compiled with zlib support.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Stream_OpenGzip( FT_Stream  stream,
+                      FT_Stream  source );
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTGZIP_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftimage.h b/include/freetype/ftimage.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftimage.h
@@ -0,0 +1,1313 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftimage.h                                                              */
+/*                                                                         */
+/*    FreeType glyph image formats and default raster interface            */
+/*    (specification).                                                     */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,   */
+/*            2010 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Note: A `raster' is simply a scan-line converter, used to render      */
+  /*       FT_Outlines into FT_Bitmaps.                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTIMAGE_H__
+#define __FTIMAGE_H__
+
+
+  /* _STANDALONE_ is from ftgrays.c */
+#ifndef _STANDALONE_
+#include <ft2build.h>
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    basic_types                                                        */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Pos                                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The type FT_Pos is used to store vectorial coordinates.  Depending */
+  /*    on the context, these can represent distances in integer font      */
+  /*    units, or 16.16, or 26.6 fixed float pixel coordinates.            */
+  /*                                                                       */
+  typedef signed long  FT_Pos;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Vector                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to store a 2D vector; coordinates are of   */
+  /*    the FT_Pos type.                                                   */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    x :: The horizontal coordinate.                                    */
+  /*    y :: The vertical coordinate.                                      */
+  /*                                                                       */
+  typedef struct  FT_Vector_
+  {
+    FT_Pos  x;
+    FT_Pos  y;
+
+  } FT_Vector;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_BBox                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to hold an outline's bounding box, i.e., the      */
+  /*    coordinates of its extrema in the horizontal and vertical          */
+  /*    directions.                                                        */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    xMin :: The horizontal minimum (left-most).                        */
+  /*                                                                       */
+  /*    yMin :: The vertical minimum (bottom-most).                        */
+  /*                                                                       */
+  /*    xMax :: The horizontal maximum (right-most).                       */
+  /*                                                                       */
+  /*    yMax :: The vertical maximum (top-most).                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The bounding box is specified with the coordinates of the lower    */
+  /*    left and the upper right corner.  In PostScript, those values are  */
+  /*    often called (llx,lly) and (urx,ury), respectively.                */
+  /*                                                                       */
+  /*    If `yMin' is negative, this value gives the glyph's descender.     */
+  /*    Otherwise, the glyph doesn't descend below the baseline.           */
+  /*    Similarly, if `ymax' is positive, this value gives the glyph's     */
+  /*    ascender.                                                          */
+  /*                                                                       */
+  /*    `xMin' gives the horizontal distance from the glyph's origin to    */
+  /*    the left edge of the glyph's bounding box.  If `xMin' is negative, */
+  /*    the glyph extends to the left of the origin.                       */
+  /*                                                                       */
+  typedef struct  FT_BBox_
+  {
+    FT_Pos  xMin, yMin;
+    FT_Pos  xMax, yMax;
+
+  } FT_BBox;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Pixel_Mode                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration type used to describe the format of pixels in a     */
+  /*    given bitmap.  Note that additional formats may be added in the    */
+  /*    future.                                                            */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_PIXEL_MODE_NONE ::                                              */
+  /*      Value~0 is reserved.                                             */
+  /*                                                                       */
+  /*    FT_PIXEL_MODE_MONO ::                                              */
+  /*      A monochrome bitmap, using 1~bit per pixel.  Note that pixels    */
+  /*      are stored in most-significant order (MSB), which means that     */
+  /*      the left-most pixel in a byte has value 128.                     */
+  /*                                                                       */
+  /*    FT_PIXEL_MODE_GRAY ::                                              */
+  /*      An 8-bit bitmap, generally used to represent anti-aliased glyph  */
+  /*      images.  Each pixel is stored in one byte.  Note that the number */
+  /*      of `gray' levels is stored in the `num_grays' field of the       */
+  /*      @FT_Bitmap structure (it generally is 256).                      */
+  /*                                                                       */
+  /*    FT_PIXEL_MODE_GRAY2 ::                                             */
+  /*      A 2-bit per pixel bitmap, used to represent embedded             */
+  /*      anti-aliased bitmaps in font files according to the OpenType     */
+  /*      specification.  We haven't found a single font using this        */
+  /*      format, however.                                                 */
+  /*                                                                       */
+  /*    FT_PIXEL_MODE_GRAY4 ::                                             */
+  /*      A 4-bit per pixel bitmap, representing embedded anti-aliased     */
+  /*      bitmaps in font files according to the OpenType specification.   */
+  /*      We haven't found a single font using this format, however.       */
+  /*                                                                       */
+  /*    FT_PIXEL_MODE_LCD ::                                               */
+  /*      An 8-bit bitmap, representing RGB or BGR decimated glyph images  */
+  /*      used for display on LCD displays; the bitmap is three times      */
+  /*      wider than the original glyph image.  See also                   */
+  /*      @FT_RENDER_MODE_LCD.                                             */
+  /*                                                                       */
+  /*    FT_PIXEL_MODE_LCD_V ::                                             */
+  /*      An 8-bit bitmap, representing RGB or BGR decimated glyph images  */
+  /*      used for display on rotated LCD displays; the bitmap is three    */
+  /*      times taller than the original glyph image.  See also            */
+  /*      @FT_RENDER_MODE_LCD_V.                                           */
+  /*                                                                       */
+  typedef enum  FT_Pixel_Mode_
+  {
+    FT_PIXEL_MODE_NONE = 0,
+    FT_PIXEL_MODE_MONO,
+    FT_PIXEL_MODE_GRAY,
+    FT_PIXEL_MODE_GRAY2,
+    FT_PIXEL_MODE_GRAY4,
+    FT_PIXEL_MODE_LCD,
+    FT_PIXEL_MODE_LCD_V,
+
+    FT_PIXEL_MODE_MAX      /* do not remove */
+
+  } FT_Pixel_Mode;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    ft_pixel_mode_xxx                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of deprecated constants.  Use the corresponding             */
+  /*    @FT_Pixel_Mode values instead.                                     */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    ft_pixel_mode_none  :: See @FT_PIXEL_MODE_NONE.                    */
+  /*    ft_pixel_mode_mono  :: See @FT_PIXEL_MODE_MONO.                    */
+  /*    ft_pixel_mode_grays :: See @FT_PIXEL_MODE_GRAY.                    */
+  /*    ft_pixel_mode_pal2  :: See @FT_PIXEL_MODE_GRAY2.                   */
+  /*    ft_pixel_mode_pal4  :: See @FT_PIXEL_MODE_GRAY4.                   */
+  /*                                                                       */
+#define ft_pixel_mode_none   FT_PIXEL_MODE_NONE
+#define ft_pixel_mode_mono   FT_PIXEL_MODE_MONO
+#define ft_pixel_mode_grays  FT_PIXEL_MODE_GRAY
+#define ft_pixel_mode_pal2   FT_PIXEL_MODE_GRAY2
+#define ft_pixel_mode_pal4   FT_PIXEL_MODE_GRAY4
+
+ /* */
+
+#if 0
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Palette_Mode                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    THIS TYPE IS DEPRECATED.  DO NOT USE IT!                           */
+  /*                                                                       */
+  /*    An enumeration type to describe the format of a bitmap palette,    */
+  /*    used with ft_pixel_mode_pal4 and ft_pixel_mode_pal8.               */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    ft_palette_mode_rgb  :: The palette is an array of 3-byte RGB      */
+  /*                            records.                                   */
+  /*                                                                       */
+  /*    ft_palette_mode_rgba :: The palette is an array of 4-byte RGBA     */
+  /*                            records.                                   */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    As ft_pixel_mode_pal2, pal4 and pal8 are currently unused by       */
+  /*    FreeType, these types are not handled by the library itself.       */
+  /*                                                                       */
+  typedef enum  FT_Palette_Mode_
+  {
+    ft_palette_mode_rgb = 0,
+    ft_palette_mode_rgba,
+
+    ft_palette_mode_max   /* do not remove */
+
+  } FT_Palette_Mode;
+
+  /* */
+
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Bitmap                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to describe a bitmap or pixmap to the raster.     */
+  /*    Note that we now manage pixmaps of various depths through the      */
+  /*    `pixel_mode' field.                                                */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    rows         :: The number of bitmap rows.                         */
+  /*                                                                       */
+  /*    width        :: The number of pixels in bitmap row.                */
+  /*                                                                       */
+  /*    pitch        :: The pitch's absolute value is the number of bytes  */
+  /*                    taken by one bitmap row, including padding.        */
+  /*                    However, the pitch is positive when the bitmap has */
+  /*                    a `down' flow, and negative when it has an `up'    */
+  /*                    flow.  In all cases, the pitch is an offset to add */
+  /*                    to a bitmap pointer in order to go down one row.   */
+  /*                                                                       */
+  /*                    Note that `padding' means the alignment of a       */
+  /*                    bitmap to a byte border, and FreeType functions    */
+  /*                    normally align to the smallest possible integer    */
+  /*                    value.                                             */
+  /*                                                                       */
+  /*                    For the B/W rasterizer, `pitch' is always an even  */
+  /*                    number.                                            */
+  /*                                                                       */
+  /*                    To change the pitch of a bitmap (say, to make it a */
+  /*                    multiple of 4), use @FT_Bitmap_Convert.            */
+  /*                    Alternatively, you might use callback functions to */
+  /*                    directly render to the application's surface; see  */
+  /*                    the file `example2.cpp' in the tutorial for a      */
+  /*                    demonstration.                                     */
+  /*                                                                       */
+  /*    buffer       :: A typeless pointer to the bitmap buffer.  This     */
+  /*                    value should be aligned on 32-bit boundaries in    */
+  /*                    most cases.                                        */
+  /*                                                                       */
+  /*    num_grays    :: This field is only used with                       */
+  /*                    @FT_PIXEL_MODE_GRAY; it gives the number of gray   */
+  /*                    levels used in the bitmap.                         */
+  /*                                                                       */
+  /*    pixel_mode   :: The pixel mode, i.e., how pixel bits are stored.   */
+  /*                    See @FT_Pixel_Mode for possible values.            */
+  /*                                                                       */
+  /*    palette_mode :: This field is intended for paletted pixel modes;   */
+  /*                    it indicates how the palette is stored.  Not       */
+  /*                    used currently.                                    */
+  /*                                                                       */
+  /*    palette      :: A typeless pointer to the bitmap palette; this     */
+  /*                    field is intended for paletted pixel modes.  Not   */
+  /*                    used currently.                                    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*   For now, the only pixel modes supported by FreeType are mono and    */
+  /*   grays.  However, drivers might be added in the future to support    */
+  /*   more `colorful' options.                                            */
+  /*                                                                       */
+  typedef struct  FT_Bitmap_
+  {
+    int             rows;
+    int             width;
+    int             pitch;
+    unsigned char*  buffer;
+    short           num_grays;
+    char            pixel_mode;
+    char            palette_mode;
+    void*           palette;
+
+  } FT_Bitmap;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    outline_processing                                                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Outline                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure is used to describe an outline to the scan-line     */
+  /*    converter.                                                         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    n_contours :: The number of contours in the outline.               */
+  /*                                                                       */
+  /*    n_points   :: The number of points in the outline.                 */
+  /*                                                                       */
+  /*    points     :: A pointer to an array of `n_points' @FT_Vector       */
+  /*                  elements, giving the outline's point coordinates.    */
+  /*                                                                       */
+  /*    tags       :: A pointer to an array of `n_points' chars, giving    */
+  /*                  each outline point's type.                           */
+  /*                                                                       */
+  /*                  If bit~0 is unset, the point is `off' the curve,     */
+  /*                  i.e., a Bézier control point, while it is `on' if    */
+  /*                  set.                                                 */
+  /*                                                                       */
+  /*                  Bit~1 is meaningful for `off' points only.  If set,  */
+  /*                  it indicates a third-order Bézier arc control point; */
+  /*                  and a second-order control point if unset.           */
+  /*                                                                       */
+  /*                  If bit~2 is set, bits 5-7 contain the drop-out mode  */
+  /*                  (as defined in the OpenType specification; the value */
+  /*                  is the same as the argument to the SCANMODE          */
+  /*                  instruction).                                        */
+  /*                                                                       */
+  /*                  Bits 3 and~4 are reserved for internal purposes.     */
+  /*                                                                       */
+  /*    contours   :: An array of `n_contours' shorts, giving the end      */
+  /*                  point of each contour within the outline.  For       */
+  /*                  example, the first contour is defined by the points  */
+  /*                  `0' to `contours[0]', the second one is defined by   */
+  /*                  the points `contours[0]+1' to `contours[1]', etc.    */
+  /*                                                                       */
+  /*    flags      :: A set of bit flags used to characterize the outline  */
+  /*                  and give hints to the scan-converter and hinter on   */
+  /*                  how to convert/grid-fit it.  See @FT_OUTLINE_FLAGS.  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The B/W rasterizer only checks bit~2 in the `tags' array for the   */
+  /*    first point of each contour.  The drop-out mode as given with      */
+  /*    @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, and       */
+  /*    @FT_OUTLINE_INCLUDE_STUBS in `flags' is then overridden.           */
+  /*                                                                       */
+  typedef struct  FT_Outline_
+  {
+    short       n_contours;      /* number of contours in glyph        */
+    short       n_points;        /* number of points in the glyph      */
+
+    FT_Vector*  points;          /* the outline's points               */
+    char*       tags;            /* the points flags                   */
+    short*      contours;        /* the contour end points             */
+
+    int         flags;           /* outline masks                      */
+
+  } FT_Outline;
+
+  /* Following limits must be consistent with */
+  /* FT_Outline.{n_contours,n_points}         */
+#define FT_OUTLINE_CONTOURS_MAX  SHRT_MAX
+#define FT_OUTLINE_POINTS_MAX    SHRT_MAX
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_OUTLINE_FLAGS                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of bit-field constants use for the flags in an outline's    */
+  /*    `flags' field.                                                     */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_OUTLINE_NONE ::                                                 */
+  /*      Value~0 is reserved.                                             */
+  /*                                                                       */
+  /*    FT_OUTLINE_OWNER ::                                                */
+  /*      If set, this flag indicates that the outline's field arrays      */
+  /*      (i.e., `points', `flags', and `contours') are `owned' by the     */
+  /*      outline object, and should thus be freed when it is destroyed.   */
+  /*                                                                       */
+  /*    FT_OUTLINE_EVEN_ODD_FILL ::                                        */
+  /*      By default, outlines are filled using the non-zero winding rule. */
+  /*      If set to 1, the outline will be filled using the even-odd fill  */
+  /*      rule (only works with the smooth rasterizer).                    */
+  /*                                                                       */
+  /*    FT_OUTLINE_REVERSE_FILL ::                                         */
+  /*      By default, outside contours of an outline are oriented in       */
+  /*      clock-wise direction, as defined in the TrueType specification.  */
+  /*      This flag is set if the outline uses the opposite direction      */
+  /*      (typically for Type~1 fonts).  This flag is ignored by the scan  */
+  /*      converter.                                                       */
+  /*                                                                       */
+  /*    FT_OUTLINE_IGNORE_DROPOUTS ::                                      */
+  /*      By default, the scan converter will try to detect drop-outs in   */
+  /*      an outline and correct the glyph bitmap to ensure consistent     */
+  /*      shape continuity.  If set, this flag hints the scan-line         */
+  /*      converter to ignore such cases.  See below for more information. */
+  /*                                                                       */
+  /*    FT_OUTLINE_SMART_DROPOUTS ::                                       */
+  /*      Select smart dropout control.  If unset, use simple dropout      */
+  /*      control.  Ignored if @FT_OUTLINE_IGNORE_DROPOUTS is set.  See    */
+  /*      below for more information.                                      */
+  /*                                                                       */
+  /*    FT_OUTLINE_INCLUDE_STUBS ::                                        */
+  /*      If set, turn pixels on for `stubs', otherwise exclude them.      */
+  /*      Ignored if @FT_OUTLINE_IGNORE_DROPOUTS is set.  See below for    */
+  /*      more information.                                                */
+  /*                                                                       */
+  /*    FT_OUTLINE_HIGH_PRECISION ::                                       */
+  /*      This flag indicates that the scan-line converter should try to   */
+  /*      convert this outline to bitmaps with the highest possible        */
+  /*      quality.  It is typically set for small character sizes.  Note   */
+  /*      that this is only a hint that might be completely ignored by a   */
+  /*      given scan-converter.                                            */
+  /*                                                                       */
+  /*    FT_OUTLINE_SINGLE_PASS ::                                          */
+  /*      This flag is set to force a given scan-converter to only use a   */
+  /*      single pass over the outline to render a bitmap glyph image.     */
+  /*      Normally, it is set for very large character sizes.  It is only  */
+  /*      a hint that might be completely ignored by a given               */
+  /*      scan-converter.                                                  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The flags @FT_OUTLINE_IGNORE_DROPOUTS, @FT_OUTLINE_SMART_DROPOUTS, */
+  /*    and @FT_OUTLINE_INCLUDE_STUBS are ignored by the smooth            */
+  /*    rasterizer.                                                        */
+  /*                                                                       */
+  /*    There exists a second mechanism to pass the drop-out mode to the   */
+  /*    B/W rasterizer; see the `tags' field in @FT_Outline.               */
+  /*                                                                       */
+  /*    Please refer to the description of the `SCANTYPE' instruction in   */
+  /*    the OpenType specification (in file `ttinst1.doc') how simple      */
+  /*    drop-outs, smart drop-outs, and stubs are defined.                 */
+  /*                                                                       */
+#define FT_OUTLINE_NONE             0x0
+#define FT_OUTLINE_OWNER            0x1
+#define FT_OUTLINE_EVEN_ODD_FILL    0x2
+#define FT_OUTLINE_REVERSE_FILL     0x4
+#define FT_OUTLINE_IGNORE_DROPOUTS  0x8
+#define FT_OUTLINE_SMART_DROPOUTS   0x10
+#define FT_OUTLINE_INCLUDE_STUBS    0x20
+
+#define FT_OUTLINE_HIGH_PRECISION   0x100
+#define FT_OUTLINE_SINGLE_PASS      0x200
+
+
+ /*************************************************************************
+  *
+  * @enum:
+  *   ft_outline_flags
+  *
+  * @description:
+  *   These constants are deprecated.  Please use the corresponding
+  *   @FT_OUTLINE_FLAGS values.
+  *
+  * @values:
+  *   ft_outline_none            :: See @FT_OUTLINE_NONE.
+  *   ft_outline_owner           :: See @FT_OUTLINE_OWNER.
+  *   ft_outline_even_odd_fill   :: See @FT_OUTLINE_EVEN_ODD_FILL.
+  *   ft_outline_reverse_fill    :: See @FT_OUTLINE_REVERSE_FILL.
+  *   ft_outline_ignore_dropouts :: See @FT_OUTLINE_IGNORE_DROPOUTS.
+  *   ft_outline_high_precision  :: See @FT_OUTLINE_HIGH_PRECISION.
+  *   ft_outline_single_pass     :: See @FT_OUTLINE_SINGLE_PASS.
+  */
+#define ft_outline_none             FT_OUTLINE_NONE
+#define ft_outline_owner            FT_OUTLINE_OWNER
+#define ft_outline_even_odd_fill    FT_OUTLINE_EVEN_ODD_FILL
+#define ft_outline_reverse_fill     FT_OUTLINE_REVERSE_FILL
+#define ft_outline_ignore_dropouts  FT_OUTLINE_IGNORE_DROPOUTS
+#define ft_outline_high_precision   FT_OUTLINE_HIGH_PRECISION
+#define ft_outline_single_pass      FT_OUTLINE_SINGLE_PASS
+
+  /* */
+
+#define FT_CURVE_TAG( flag )  ( flag & 3 )
+
+#define FT_CURVE_TAG_ON            1
+#define FT_CURVE_TAG_CONIC         0
+#define FT_CURVE_TAG_CUBIC         2
+
+#define FT_CURVE_TAG_HAS_SCANMODE  4
+
+#define FT_CURVE_TAG_TOUCH_X       8  /* reserved for the TrueType hinter */
+#define FT_CURVE_TAG_TOUCH_Y      16  /* reserved for the TrueType hinter */
+
+#define FT_CURVE_TAG_TOUCH_BOTH    ( FT_CURVE_TAG_TOUCH_X | \
+                                     FT_CURVE_TAG_TOUCH_Y )
+
+#define FT_Curve_Tag_On       FT_CURVE_TAG_ON
+#define FT_Curve_Tag_Conic    FT_CURVE_TAG_CONIC
+#define FT_Curve_Tag_Cubic    FT_CURVE_TAG_CUBIC
+#define FT_Curve_Tag_Touch_X  FT_CURVE_TAG_TOUCH_X
+#define FT_Curve_Tag_Touch_Y  FT_CURVE_TAG_TOUCH_Y
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Outline_MoveToFunc                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function pointer type used to describe the signature of a `move  */
+  /*    to' function during outline walking/decomposition.                 */
+  /*                                                                       */
+  /*    A `move to' is emitted to start a new contour in an outline.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    to   :: A pointer to the target point of the `move to'.            */
+  /*                                                                       */
+  /*    user :: A typeless pointer which is passed from the caller of the  */
+  /*            decomposition function.                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Error code.  0~means success.                                      */
+  /*                                                                       */
+  typedef int
+  (*FT_Outline_MoveToFunc)( const FT_Vector*  to,
+                            void*             user );
+
+#define FT_Outline_MoveTo_Func  FT_Outline_MoveToFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Outline_LineToFunc                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function pointer type used to describe the signature of a `line  */
+  /*    to' function during outline walking/decomposition.                 */
+  /*                                                                       */
+  /*    A `line to' is emitted to indicate a segment in the outline.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    to   :: A pointer to the target point of the `line to'.            */
+  /*                                                                       */
+  /*    user :: A typeless pointer which is passed from the caller of the  */
+  /*            decomposition function.                                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Error code.  0~means success.                                      */
+  /*                                                                       */
+  typedef int
+  (*FT_Outline_LineToFunc)( const FT_Vector*  to,
+                            void*             user );
+
+#define FT_Outline_LineTo_Func  FT_Outline_LineToFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Outline_ConicToFunc                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function pointer type used to describe the signature of a `conic */
+  /*    to' function during outline walking or decomposition.              */
+  /*                                                                       */
+  /*    A `conic to' is emitted to indicate a second-order Bézier arc in   */
+  /*    the outline.                                                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    control :: An intermediate control point between the last position */
+  /*               and the new target in `to'.                             */
+  /*                                                                       */
+  /*    to      :: A pointer to the target end point of the conic arc.     */
+  /*                                                                       */
+  /*    user    :: A typeless pointer which is passed from the caller of   */
+  /*               the decomposition function.                             */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Error code.  0~means success.                                      */
+  /*                                                                       */
+  typedef int
+  (*FT_Outline_ConicToFunc)( const FT_Vector*  control,
+                             const FT_Vector*  to,
+                             void*             user );
+
+#define FT_Outline_ConicTo_Func  FT_Outline_ConicToFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Outline_CubicToFunc                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function pointer type used to describe the signature of a `cubic */
+  /*    to' function during outline walking or decomposition.              */
+  /*                                                                       */
+  /*    A `cubic to' is emitted to indicate a third-order Bézier arc.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    control1 :: A pointer to the first Bézier control point.           */
+  /*                                                                       */
+  /*    control2 :: A pointer to the second Bézier control point.          */
+  /*                                                                       */
+  /*    to       :: A pointer to the target end point.                     */
+  /*                                                                       */
+  /*    user     :: A typeless pointer which is passed from the caller of  */
+  /*                the decomposition function.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Error code.  0~means success.                                      */
+  /*                                                                       */
+  typedef int
+  (*FT_Outline_CubicToFunc)( const FT_Vector*  control1,
+                             const FT_Vector*  control2,
+                             const FT_Vector*  to,
+                             void*             user );
+
+#define FT_Outline_CubicTo_Func  FT_Outline_CubicToFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Outline_Funcs                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure to hold various function pointers used during outline  */
+  /*    decomposition in order to emit segments, conic, and cubic Béziers. */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    move_to  :: The `move to' emitter.                                 */
+  /*                                                                       */
+  /*    line_to  :: The segment emitter.                                   */
+  /*                                                                       */
+  /*    conic_to :: The second-order Bézier arc emitter.                   */
+  /*                                                                       */
+  /*    cubic_to :: The third-order Bézier arc emitter.                    */
+  /*                                                                       */
+  /*    shift    :: The shift that is applied to coordinates before they   */
+  /*                are sent to the emitter.                               */
+  /*                                                                       */
+  /*    delta    :: The delta that is applied to coordinates before they   */
+  /*                are sent to the emitter, but after the shift.          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The point coordinates sent to the emitters are the transformed     */
+  /*    version of the original coordinates (this is important for high    */
+  /*    accuracy during scan-conversion).  The transformation is simple:   */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      x' = (x << shift) - delta                                        */
+  /*      y' = (x << shift) - delta                                        */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    Set the values of `shift' and `delta' to~0 to get the original     */
+  /*    point coordinates.                                                 */
+  /*                                                                       */
+  typedef struct  FT_Outline_Funcs_
+  {
+    FT_Outline_MoveToFunc   move_to;
+    FT_Outline_LineToFunc   line_to;
+    FT_Outline_ConicToFunc  conic_to;
+    FT_Outline_CubicToFunc  cubic_to;
+
+    int                     shift;
+    FT_Pos                  delta;
+
+  } FT_Outline_Funcs;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    basic_types                                                        */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_IMAGE_TAG                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This macro converts four-letter tags to an unsigned long type.     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Since many 16-bit compilers don't like 32-bit enumerations, you    */
+  /*    should redefine this macro in case of problems to something like   */
+  /*    this:                                                              */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      #define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  value         */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    to get a simple enumeration without assigning special numbers.     */
+  /*                                                                       */
+#ifndef FT_IMAGE_TAG
+#define FT_IMAGE_TAG( value, _x1, _x2, _x3, _x4 )  \
+          value = ( ( (unsigned long)_x1 << 24 ) | \
+                    ( (unsigned long)_x2 << 16 ) | \
+                    ( (unsigned long)_x3 << 8  ) | \
+                      (unsigned long)_x4         )
+#endif /* FT_IMAGE_TAG */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Glyph_Format                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration type used to describe the format of a given glyph   */
+  /*    image.  Note that this version of FreeType only supports two image */
+  /*    formats, even though future font drivers will be able to register  */
+  /*    their own format.                                                  */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_GLYPH_FORMAT_NONE ::                                            */
+  /*      The value~0 is reserved.                                         */
+  /*                                                                       */
+  /*    FT_GLYPH_FORMAT_COMPOSITE ::                                       */
+  /*      The glyph image is a composite of several other images.  This    */
+  /*      format is _only_ used with @FT_LOAD_NO_RECURSE, and is used to   */
+  /*      report compound glyphs (like accented characters).               */
+  /*                                                                       */
+  /*    FT_GLYPH_FORMAT_BITMAP ::                                          */
+  /*      The glyph image is a bitmap, and can be described as an          */
+  /*      @FT_Bitmap.  You generally need to access the `bitmap' field of  */
+  /*      the @FT_GlyphSlotRec structure to read it.                       */
+  /*                                                                       */
+  /*    FT_GLYPH_FORMAT_OUTLINE ::                                         */
+  /*      The glyph image is a vectorial outline made of line segments     */
+  /*      and Bézier arcs; it can be described as an @FT_Outline; you      */
+  /*      generally want to access the `outline' field of the              */
+  /*      @FT_GlyphSlotRec structure to read it.                           */
+  /*                                                                       */
+  /*    FT_GLYPH_FORMAT_PLOTTER ::                                         */
+  /*      The glyph image is a vectorial path with no inside and outside   */
+  /*      contours.  Some Type~1 fonts, like those in the Hershey family,  */
+  /*      contain glyphs in this format.  These are described as           */
+  /*      @FT_Outline, but FreeType isn't currently capable of rendering   */
+  /*      them correctly.                                                  */
+  /*                                                                       */
+  typedef enum  FT_Glyph_Format_
+  {
+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_NONE, 0, 0, 0, 0 ),
+
+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_COMPOSITE, 'c', 'o', 'm', 'p' ),
+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_BITMAP,    'b', 'i', 't', 's' ),
+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_OUTLINE,   'o', 'u', 't', 'l' ),
+    FT_IMAGE_TAG( FT_GLYPH_FORMAT_PLOTTER,   'p', 'l', 'o', 't' )
+
+  } FT_Glyph_Format;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    ft_glyph_format_xxx                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of deprecated constants.  Use the corresponding             */
+  /*    @FT_Glyph_Format values instead.                                   */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    ft_glyph_format_none      :: See @FT_GLYPH_FORMAT_NONE.            */
+  /*    ft_glyph_format_composite :: See @FT_GLYPH_FORMAT_COMPOSITE.       */
+  /*    ft_glyph_format_bitmap    :: See @FT_GLYPH_FORMAT_BITMAP.          */
+  /*    ft_glyph_format_outline   :: See @FT_GLYPH_FORMAT_OUTLINE.         */
+  /*    ft_glyph_format_plotter   :: See @FT_GLYPH_FORMAT_PLOTTER.         */
+  /*                                                                       */
+#define ft_glyph_format_none       FT_GLYPH_FORMAT_NONE
+#define ft_glyph_format_composite  FT_GLYPH_FORMAT_COMPOSITE
+#define ft_glyph_format_bitmap     FT_GLYPH_FORMAT_BITMAP
+#define ft_glyph_format_outline    FT_GLYPH_FORMAT_OUTLINE
+#define ft_glyph_format_plotter    FT_GLYPH_FORMAT_PLOTTER
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****            R A S T E R   D E F I N I T I O N S                *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* A raster is a scan converter, in charge of rendering an outline into  */
+  /* a a bitmap.  This section contains the public API for rasters.        */
+  /*                                                                       */
+  /* Note that in FreeType 2, all rasters are now encapsulated within      */
+  /* specific modules called `renderers'.  See `freetype/ftrender.h' for   */
+  /* more details on renderers.                                            */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    raster                                                             */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Scanline Converter                                                 */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    How vectorial outlines are converted into bitmaps and pixmaps.     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains technical definitions.                       */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Raster                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle (pointer) to a raster object.  Each object can be used    */
+  /*    independently to convert an outline into a bitmap or pixmap.       */
+  /*                                                                       */
+  typedef struct FT_RasterRec_*  FT_Raster;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Span                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a single span of gray (or black) pixels  */
+  /*    when rendering a monochrome or anti-aliased bitmap.                */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    x        :: The span's horizontal start position.                  */
+  /*                                                                       */
+  /*    len      :: The span's length in pixels.                           */
+  /*                                                                       */
+  /*    coverage :: The span color/coverage, ranging from 0 (background)   */
+  /*                to 255 (foreground).  Only used for anti-aliased       */
+  /*                rendering.                                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This structure is used by the span drawing callback type named     */
+  /*    @FT_SpanFunc which takes the y~coordinate of the span as a         */
+  /*    a parameter.                                                       */
+  /*                                                                       */
+  /*    The coverage value is always between 0 and 255.  If you want less  */
+  /*    gray values, the callback function has to reduce them.             */
+  /*                                                                       */
+  typedef struct  FT_Span_
+  {
+    short           x;
+    unsigned short  len;
+    unsigned char   coverage;
+
+  } FT_Span;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_SpanFunc                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used as a call-back by the anti-aliased renderer in     */
+  /*    order to let client applications draw themselves the gray pixel    */
+  /*    spans on each scan line.                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    y     :: The scanline's y~coordinate.                              */
+  /*                                                                       */
+  /*    count :: The number of spans to draw on this scanline.             */
+  /*                                                                       */
+  /*    spans :: A table of `count' spans to draw on the scanline.         */
+  /*                                                                       */
+  /*    user  :: User-supplied data that is passed to the callback.        */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This callback allows client applications to directly render the    */
+  /*    gray spans of the anti-aliased bitmap to any kind of surfaces.     */
+  /*                                                                       */
+  /*    This can be used to write anti-aliased outlines directly to a      */
+  /*    given background bitmap, and even perform translucency.            */
+  /*                                                                       */
+  /*    Note that the `count' field cannot be greater than a fixed value   */
+  /*    defined by the `FT_MAX_GRAY_SPANS' configuration macro in          */
+  /*    `ftoption.h'.  By default, this value is set to~32, which means    */
+  /*    that if there are more than 32~spans on a given scanline, the      */
+  /*    callback is called several times with the same `y' parameter in    */
+  /*    order to draw all callbacks.                                       */
+  /*                                                                       */
+  /*    Otherwise, the callback is only called once per scan-line, and     */
+  /*    only for those scanlines that do have `gray' pixels on them.       */
+  /*                                                                       */
+  typedef void
+  (*FT_SpanFunc)( int             y,
+                  int             count,
+                  const FT_Span*  spans,
+                  void*           user );
+
+#define FT_Raster_Span_Func  FT_SpanFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_BitTest_Func                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    THIS TYPE IS DEPRECATED.  DO NOT USE IT.                           */
+  /*                                                                       */
+  /*    A function used as a call-back by the monochrome scan-converter    */
+  /*    to test whether a given target pixel is already set to the drawing */
+  /*    `color'.  These tests are crucial to implement drop-out control    */
+  /*    per-se the TrueType spec.                                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    y     :: The pixel's y~coordinate.                                 */
+  /*                                                                       */
+  /*    x     :: The pixel's x~coordinate.                                 */
+  /*                                                                       */
+  /*    user  :: User-supplied data that is passed to the callback.        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*   1~if the pixel is `set', 0~otherwise.                               */
+  /*                                                                       */
+  typedef int
+  (*FT_Raster_BitTest_Func)( int    y,
+                             int    x,
+                             void*  user );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_BitSet_Func                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    THIS TYPE IS DEPRECATED.  DO NOT USE IT.                           */
+  /*                                                                       */
+  /*    A function used as a call-back by the monochrome scan-converter    */
+  /*    to set an individual target pixel.  This is crucial to implement   */
+  /*    drop-out control according to the TrueType specification.          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    y     :: The pixel's y~coordinate.                                 */
+  /*                                                                       */
+  /*    x     :: The pixel's x~coordinate.                                 */
+  /*                                                                       */
+  /*    user  :: User-supplied data that is passed to the callback.        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    1~if the pixel is `set', 0~otherwise.                              */
+  /*                                                                       */
+  typedef void
+  (*FT_Raster_BitSet_Func)( int    y,
+                            int    x,
+                            void*  user );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_RASTER_FLAG_XXX                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A list of bit flag constants as used in the `flags' field of a     */
+  /*    @FT_Raster_Params structure.                                       */
+  /*                                                                       */
+  /* <Values>                                                              */
+  /*    FT_RASTER_FLAG_DEFAULT :: This value is 0.                         */
+  /*                                                                       */
+  /*    FT_RASTER_FLAG_AA      :: This flag is set to indicate that an     */
+  /*                              anti-aliased glyph image should be       */
+  /*                              generated.  Otherwise, it will be        */
+  /*                              monochrome (1-bit).                      */
+  /*                                                                       */
+  /*    FT_RASTER_FLAG_DIRECT  :: This flag is set to indicate direct      */
+  /*                              rendering.  In this mode, client         */
+  /*                              applications must provide their own span */
+  /*                              callback.  This lets them directly       */
+  /*                              draw or compose over an existing bitmap. */
+  /*                              If this bit is not set, the target       */
+  /*                              pixmap's buffer _must_ be zeroed before  */
+  /*                              rendering.                               */
+  /*                                                                       */
+  /*                              Note that for now, direct rendering is   */
+  /*                              only possible with anti-aliased glyphs.  */
+  /*                                                                       */
+  /*    FT_RASTER_FLAG_CLIP    :: This flag is only used in direct         */
+  /*                              rendering mode.  If set, the output will */
+  /*                              be clipped to a box specified in the     */
+  /*                              `clip_box' field of the                  */
+  /*                              @FT_Raster_Params structure.             */
+  /*                                                                       */
+  /*                              Note that by default, the glyph bitmap   */
+  /*                              is clipped to the target pixmap, except  */
+  /*                              in direct rendering mode where all spans */
+  /*                              are generated if no clipping box is set. */
+  /*                                                                       */
+#define FT_RASTER_FLAG_DEFAULT  0x0
+#define FT_RASTER_FLAG_AA       0x1
+#define FT_RASTER_FLAG_DIRECT   0x2
+#define FT_RASTER_FLAG_CLIP     0x4
+
+  /* deprecated */
+#define ft_raster_flag_default  FT_RASTER_FLAG_DEFAULT
+#define ft_raster_flag_aa       FT_RASTER_FLAG_AA
+#define ft_raster_flag_direct   FT_RASTER_FLAG_DIRECT
+#define ft_raster_flag_clip     FT_RASTER_FLAG_CLIP
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Raster_Params                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure to hold the arguments used by a raster's render        */
+  /*    function.                                                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    target      :: The target bitmap.                                  */
+  /*                                                                       */
+  /*    source      :: A pointer to the source glyph image (e.g., an       */
+  /*                   @FT_Outline).                                       */
+  /*                                                                       */
+  /*    flags       :: The rendering flags.                                */
+  /*                                                                       */
+  /*    gray_spans  :: The gray span drawing callback.                     */
+  /*                                                                       */
+  /*    black_spans :: The black span drawing callback.  UNIMPLEMENTED!    */
+  /*                                                                       */
+  /*    bit_test    :: The bit test callback.  UNIMPLEMENTED!              */
+  /*                                                                       */
+  /*    bit_set     :: The bit set callback.  UNIMPLEMENTED!               */
+  /*                                                                       */
+  /*    user        :: User-supplied data that is passed to each drawing   */
+  /*                   callback.                                           */
+  /*                                                                       */
+  /*    clip_box    :: An optional clipping box.  It is only used in       */
+  /*                   direct rendering mode.  Note that coordinates here  */
+  /*                   should be expressed in _integer_ pixels (and not in */
+  /*                   26.6 fixed-point units).                            */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    An anti-aliased glyph bitmap is drawn if the @FT_RASTER_FLAG_AA    */
+  /*    bit flag is set in the `flags' field, otherwise a monochrome       */
+  /*    bitmap is generated.                                               */
+  /*                                                                       */
+  /*    If the @FT_RASTER_FLAG_DIRECT bit flag is set in `flags', the      */
+  /*    raster will call the `gray_spans' callback to draw gray pixel      */
+  /*    spans, in the case of an aa glyph bitmap, it will call             */
+  /*    `black_spans', and `bit_test' and `bit_set' in the case of a       */
+  /*    monochrome bitmap.  This allows direct composition over a          */
+  /*    pre-existing bitmap through user-provided callbacks to perform the */
+  /*    span drawing/composition.                                          */
+  /*                                                                       */
+  /*    Note that the `bit_test' and `bit_set' callbacks are required when */
+  /*    rendering a monochrome bitmap, as they are crucial to implement    */
+  /*    correct drop-out control as defined in the TrueType specification. */
+  /*                                                                       */
+  typedef struct  FT_Raster_Params_
+  {
+    const FT_Bitmap*        target;
+    const void*             source;
+    int                     flags;
+    FT_SpanFunc             gray_spans;
+    FT_SpanFunc             black_spans;  /* doesn't work! */
+    FT_Raster_BitTest_Func  bit_test;     /* doesn't work! */
+    FT_Raster_BitSet_Func   bit_set;      /* doesn't work! */
+    void*                   user;
+    FT_BBox                 clip_box;
+
+  } FT_Raster_Params;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_NewFunc                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to create a new raster object.                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory :: A handle to the memory allocator.                        */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    raster :: A handle to the new raster object.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Error code.  0~means success.                                      */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The `memory' parameter is a typeless pointer in order to avoid     */
+  /*    un-wanted dependencies on the rest of the FreeType code.  In       */
+  /*    practice, it is an @FT_Memory object, i.e., a handle to the        */
+  /*    standard FreeType memory allocator.  However, this field can be    */
+  /*    completely ignored by a given raster implementation.               */
+  /*                                                                       */
+  typedef int
+  (*FT_Raster_NewFunc)( void*       memory,
+                        FT_Raster*  raster );
+
+#define FT_Raster_New_Func  FT_Raster_NewFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_DoneFunc                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to destroy a given raster object.                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    raster :: A handle to the raster object.                           */
+  /*                                                                       */
+  typedef void
+  (*FT_Raster_DoneFunc)( FT_Raster  raster );
+
+#define FT_Raster_Done_Func  FT_Raster_DoneFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_ResetFunc                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    FreeType provides an area of memory called the `render pool',      */
+  /*    available to all registered rasters.  This pool can be freely used */
+  /*    during a given scan-conversion but is shared by all rasters.  Its  */
+  /*    content is thus transient.                                         */
+  /*                                                                       */
+  /*    This function is called each time the render pool changes, or just */
+  /*    after a new raster object is created.                              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    raster    :: A handle to the new raster object.                    */
+  /*                                                                       */
+  /*    pool_base :: The address in memory of the render pool.             */
+  /*                                                                       */
+  /*    pool_size :: The size in bytes of the render pool.                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Rasters can ignore the render pool and rely on dynamic memory      */
+  /*    allocation if they want to (a handle to the memory allocator is    */
+  /*    passed to the raster constructor).  However, this is not           */
+  /*    recommended for efficiency purposes.                               */
+  /*                                                                       */
+  typedef void
+  (*FT_Raster_ResetFunc)( FT_Raster       raster,
+                          unsigned char*  pool_base,
+                          unsigned long   pool_size );
+
+#define FT_Raster_Reset_Func  FT_Raster_ResetFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_SetModeFunc                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function is a generic facility to change modes or attributes  */
+  /*    in a given raster.  This can be used for debugging purposes, or    */
+  /*    simply to allow implementation-specific `features' in a given      */
+  /*    raster module.                                                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    raster :: A handle to the new raster object.                       */
+  /*                                                                       */
+  /*    mode   :: A 4-byte tag used to name the mode or property.          */
+  /*                                                                       */
+  /*    args   :: A pointer to the new mode/property to use.               */
+  /*                                                                       */
+  typedef int
+  (*FT_Raster_SetModeFunc)( FT_Raster      raster,
+                            unsigned long  mode,
+                            void*          args );
+
+#define FT_Raster_Set_Mode_Func  FT_Raster_SetModeFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Raster_RenderFunc                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Invoke a given raster to scan-convert a given glyph image into a   */
+  /*    target bitmap.                                                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    raster :: A handle to the raster object.                           */
+  /*                                                                       */
+  /*    params :: A pointer to an @FT_Raster_Params structure used to      */
+  /*              store the rendering parameters.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Error code.  0~means success.                                      */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The exact format of the source image depends on the raster's glyph */
+  /*    format defined in its @FT_Raster_Funcs structure.  It can be an    */
+  /*    @FT_Outline or anything else in order to support a large array of  */
+  /*    glyph formats.                                                     */
+  /*                                                                       */
+  /*    Note also that the render function can fail and return a           */
+  /*    `FT_Err_Unimplemented_Feature' error code if the raster used does  */
+  /*    not support direct composition.                                    */
+  /*                                                                       */
+  /*    XXX: For now, the standard raster doesn't support direct           */
+  /*         composition but this should change for the final release (see */
+  /*         the files `demos/src/ftgrays.c' and `demos/src/ftgrays2.c'    */
+  /*         for examples of distinct implementations which support direct */
+  /*         composition).                                                 */
+  /*                                                                       */
+  typedef int
+  (*FT_Raster_RenderFunc)( FT_Raster                raster,
+                           const FT_Raster_Params*  params );
+
+#define FT_Raster_Render_Func  FT_Raster_RenderFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Raster_Funcs                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*   A structure used to describe a given raster class to the library.   */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    glyph_format  :: The supported glyph format for this raster.       */
+  /*                                                                       */
+  /*    raster_new    :: The raster constructor.                           */
+  /*                                                                       */
+  /*    raster_reset  :: Used to reset the render pool within the raster.  */
+  /*                                                                       */
+  /*    raster_render :: A function to render a glyph into a given bitmap. */
+  /*                                                                       */
+  /*    raster_done   :: The raster destructor.                            */
+  /*                                                                       */
+  typedef struct  FT_Raster_Funcs_
+  {
+    FT_Glyph_Format        glyph_format;
+    FT_Raster_NewFunc      raster_new;
+    FT_Raster_ResetFunc    raster_reset;
+    FT_Raster_SetModeFunc  raster_set_mode;
+    FT_Raster_RenderFunc   raster_render;
+    FT_Raster_DoneFunc     raster_done;
+
+  } FT_Raster_Funcs;
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTIMAGE_H__ */
+
+
+/* END */
+
+
+/* Local Variables: */
+/* coding: utf-8    */
+/* End:             */
diff --git a/include/freetype/ftincrem.h b/include/freetype/ftincrem.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftincrem.h
@@ -0,0 +1,353 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftincrem.h                                                             */
+/*                                                                         */
+/*    FreeType incremental loading (specification).                        */
+/*                                                                         */
+/*  Copyright 2002, 2003, 2006, 2007, 2008, 2010 by                        */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTINCREM_H__
+#define __FTINCREM_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /***************************************************************************
+   *
+   * @section:
+   *    incremental
+   *
+   * @title:
+   *    Incremental Loading
+   *
+   * @abstract:
+   *    Custom Glyph Loading.
+   *
+   * @description:
+   *   This section contains various functions used to perform so-called
+   *   `incremental' glyph loading.  This is a mode where all glyphs loaded
+   *   from a given @FT_Face are provided by the client application,
+   *
+   *   Apart from that, all other tables are loaded normally from the font
+   *   file.  This mode is useful when FreeType is used within another
+   *   engine, e.g., a PostScript Imaging Processor.
+   *
+   *   To enable this mode, you must use @FT_Open_Face, passing an
+   *   @FT_Parameter with the @FT_PARAM_TAG_INCREMENTAL tag and an
+   *   @FT_Incremental_Interface value.  See the comments for
+   *   @FT_Incremental_InterfaceRec for an example.
+   *
+   */
+
+
+  /***************************************************************************
+   *
+   * @type:
+   *   FT_Incremental
+   *
+   * @description:
+   *   An opaque type describing a user-provided object used to implement
+   *   `incremental' glyph loading within FreeType.  This is used to support
+   *   embedded fonts in certain environments (e.g., PostScript interpreters),
+   *   where the glyph data isn't in the font file, or must be overridden by
+   *   different values.
+   *
+   * @note:
+   *   It is up to client applications to create and implement @FT_Incremental
+   *   objects, as long as they provide implementations for the methods
+   *   @FT_Incremental_GetGlyphDataFunc, @FT_Incremental_FreeGlyphDataFunc
+   *   and @FT_Incremental_GetGlyphMetricsFunc.
+   *
+   *   See the description of @FT_Incremental_InterfaceRec to understand how
+   *   to use incremental objects with FreeType.
+   *
+   */
+  typedef struct FT_IncrementalRec_*  FT_Incremental;
+
+
+  /***************************************************************************
+   *
+   * @struct:
+   *   FT_Incremental_MetricsRec
+   *
+   * @description:
+   *   A small structure used to contain the basic glyph metrics returned
+   *   by the @FT_Incremental_GetGlyphMetricsFunc method.
+   *
+   * @fields:
+   *   bearing_x ::
+   *     Left bearing, in font units.
+   *
+   *   bearing_y ::
+   *     Top bearing, in font units.
+   *
+   *   advance ::
+   *     Horizontal component of glyph advance, in font units.
+   *
+   *   advance_v ::
+   *     Vertical component of glyph advance, in font units.
+   *
+   * @note:
+   *   These correspond to horizontal or vertical metrics depending on the
+   *   value of the `vertical' argument to the function
+   *   @FT_Incremental_GetGlyphMetricsFunc.
+   *
+   */
+  typedef struct  FT_Incremental_MetricsRec_
+  {
+    FT_Long  bearing_x;
+    FT_Long  bearing_y;
+    FT_Long  advance;
+    FT_Long  advance_v;     /* since 2.3.12 */
+
+  } FT_Incremental_MetricsRec;
+
+
+  /***************************************************************************
+   *
+   * @struct:
+   *   FT_Incremental_Metrics
+   *
+   * @description:
+   *   A handle to an @FT_Incremental_MetricsRec structure.
+   *
+   */
+   typedef struct FT_Incremental_MetricsRec_*  FT_Incremental_Metrics;
+
+
+  /***************************************************************************
+   *
+   * @type:
+   *   FT_Incremental_GetGlyphDataFunc
+   *
+   * @description:
+   *   A function called by FreeType to access a given glyph's data bytes
+   *   during @FT_Load_Glyph or @FT_Load_Char if incremental loading is
+   *   enabled.
+   *
+   *   Note that the format of the glyph's data bytes depends on the font
+   *   file format.  For TrueType, it must correspond to the raw bytes within
+   *   the `glyf' table.  For PostScript formats, it must correspond to the
+   *   *unencrypted* charstring bytes, without any `lenIV' header.  It is
+   *   undefined for any other format.
+   *
+   * @input:
+   *   incremental ::
+   *     Handle to an opaque @FT_Incremental handle provided by the client
+   *     application.
+   *
+   *   glyph_index ::
+   *     Index of relevant glyph.
+   *
+   * @output:
+   *   adata ::
+   *     A structure describing the returned glyph data bytes (which will be
+   *     accessed as a read-only byte block).
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   If this function returns successfully the method
+   *   @FT_Incremental_FreeGlyphDataFunc will be called later to release
+   *   the data bytes.
+   *
+   *   Nested calls to @FT_Incremental_GetGlyphDataFunc can happen for
+   *   compound glyphs.
+   *
+   */
+  typedef FT_Error
+  (*FT_Incremental_GetGlyphDataFunc)( FT_Incremental  incremental,
+                                      FT_UInt         glyph_index,
+                                      FT_Data*        adata );
+
+
+  /***************************************************************************
+   *
+   * @type:
+   *   FT_Incremental_FreeGlyphDataFunc
+   *
+   * @description:
+   *   A function used to release the glyph data bytes returned by a
+   *   successful call to @FT_Incremental_GetGlyphDataFunc.
+   *
+   * @input:
+   *   incremental ::
+   *     A handle to an opaque @FT_Incremental handle provided by the client
+   *     application.
+   *
+   *   data ::
+   *     A structure describing the glyph data bytes (which will be accessed
+   *     as a read-only byte block).
+   *
+   */
+  typedef void
+  (*FT_Incremental_FreeGlyphDataFunc)( FT_Incremental  incremental,
+                                       FT_Data*        data );
+
+
+  /***************************************************************************
+   *
+   * @type:
+   *   FT_Incremental_GetGlyphMetricsFunc
+   *
+   * @description:
+   *   A function used to retrieve the basic metrics of a given glyph index
+   *   before accessing its data.  This is necessary because, in certain
+   *   formats like TrueType, the metrics are stored in a different place from
+   *   the glyph images proper.
+   *
+   * @input:
+   *   incremental ::
+   *     A handle to an opaque @FT_Incremental handle provided by the client
+   *     application.
+   *
+   *   glyph_index ::
+   *     Index of relevant glyph.
+   *
+   *   vertical ::
+   *     If true, return vertical metrics.
+   *
+   *   ametrics ::
+   *     This parameter is used for both input and output.
+   *     The original glyph metrics, if any, in font units.  If metrics are
+   *     not available all the values must be set to zero.
+   *
+   * @output:
+   *   ametrics ::
+   *     The replacement glyph metrics in font units.
+   *
+   */
+  typedef FT_Error
+  (*FT_Incremental_GetGlyphMetricsFunc)
+                      ( FT_Incremental              incremental,
+                        FT_UInt                     glyph_index,
+                        FT_Bool                     vertical,
+                        FT_Incremental_MetricsRec  *ametrics );
+
+
+  /**************************************************************************
+   *
+   * @struct:
+   *   FT_Incremental_FuncsRec
+   *
+   * @description:
+   *   A table of functions for accessing fonts that load data
+   *   incrementally.  Used in @FT_Incremental_InterfaceRec.
+   *
+   * @fields:
+   *   get_glyph_data ::
+   *     The function to get glyph data.  Must not be null.
+   *
+   *   free_glyph_data ::
+   *     The function to release glyph data.  Must not be null.
+   *
+   *   get_glyph_metrics ::
+   *     The function to get glyph metrics.  May be null if the font does
+   *     not provide overriding glyph metrics.
+   *
+   */
+  typedef struct  FT_Incremental_FuncsRec_
+  {
+    FT_Incremental_GetGlyphDataFunc     get_glyph_data;
+    FT_Incremental_FreeGlyphDataFunc    free_glyph_data;
+    FT_Incremental_GetGlyphMetricsFunc  get_glyph_metrics;
+
+  } FT_Incremental_FuncsRec;
+
+
+  /***************************************************************************
+   *
+   * @struct:
+   *   FT_Incremental_InterfaceRec
+   *
+   * @description:
+   *   A structure to be used with @FT_Open_Face to indicate that the user
+   *   wants to support incremental glyph loading.  You should use it with
+   *   @FT_PARAM_TAG_INCREMENTAL as in the following example:
+   *
+   *     {
+   *       FT_Incremental_InterfaceRec  inc_int;
+   *       FT_Parameter                 parameter;
+   *       FT_Open_Args                 open_args;
+   *
+   *
+   *       // set up incremental descriptor
+   *       inc_int.funcs  = my_funcs;
+   *       inc_int.object = my_object;
+   *
+   *       // set up optional parameter
+   *       parameter.tag  = FT_PARAM_TAG_INCREMENTAL;
+   *       parameter.data = &inc_int;
+   *
+   *       // set up FT_Open_Args structure
+   *       open_args.flags      = FT_OPEN_PATHNAME | FT_OPEN_PARAMS;
+   *       open_args.pathname   = my_font_pathname;
+   *       open_args.num_params = 1;
+   *       open_args.params     = &parameter; // we use one optional argument
+   *
+   *       // open the font
+   *       error = FT_Open_Face( library, &open_args, index, &face );
+   *       ...
+   *     }
+   *
+   */
+  typedef struct  FT_Incremental_InterfaceRec_
+  {
+    const FT_Incremental_FuncsRec*  funcs;
+    FT_Incremental                  object;
+
+  } FT_Incremental_InterfaceRec;
+
+
+  /***************************************************************************
+   *
+   * @type:
+   *   FT_Incremental_Interface
+   *
+   * @description:
+   *   A pointer to an @FT_Incremental_InterfaceRec structure.
+   *
+   */
+  typedef FT_Incremental_InterfaceRec*   FT_Incremental_Interface;
+
+
+  /***************************************************************************
+   *
+   * @constant:
+   *   FT_PARAM_TAG_INCREMENTAL
+   *
+   * @description:
+   *   A constant used as the tag of @FT_Parameter structures to indicate
+   *   an incremental loading object to be used by FreeType.
+   *
+   */
+#define FT_PARAM_TAG_INCREMENTAL  FT_MAKE_TAG( 'i', 'n', 'c', 'r' )
+
+  /* */
+
+FT_END_HEADER
+
+#endif /* __FTINCREM_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftlcdfil.h b/include/freetype/ftlcdfil.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftlcdfil.h
@@ -0,0 +1,213 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftlcdfil.h                                                             */
+/*                                                                         */
+/*    FreeType API for color filtering of subpixel bitmap glyphs           */
+/*    (specification).                                                     */
+/*                                                                         */
+/*  Copyright 2006, 2007, 2008, 2010 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FT_LCD_FILTER_H__
+#define __FT_LCD_FILTER_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /***************************************************************************
+   *
+   * @section:
+   *   lcd_filtering
+   *
+   * @title:
+   *   LCD Filtering
+   *
+   * @abstract:
+   *   Reduce color fringes of LCD-optimized bitmaps.
+   *
+   * @description:
+   *   The @FT_Library_SetLcdFilter API can be used to specify a low-pass
+   *   filter which is then applied to LCD-optimized bitmaps generated
+   *   through @FT_Render_Glyph.  This is useful to reduce color fringes
+   *   which would occur with unfiltered rendering.
+   *
+   *   Note that no filter is active by default, and that this function is
+   *   *not* implemented in default builds of the library.  You need to
+   *   #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING in your `ftoption.h' file
+   *   in order to activate it.
+   */
+
+
+  /****************************************************************************
+   *
+   * @enum:
+   *   FT_LcdFilter
+   *
+   * @description:
+   *   A list of values to identify various types of LCD filters.
+   *
+   * @values:
+   *   FT_LCD_FILTER_NONE ::
+   *     Do not perform filtering.  When used with subpixel rendering, this
+   *     results in sometimes severe color fringes.
+   *
+   *   FT_LCD_FILTER_DEFAULT ::
+   *     The default filter reduces color fringes considerably, at the cost
+   *     of a slight blurriness in the output.
+   *
+   *   FT_LCD_FILTER_LIGHT ::
+   *     The light filter is a variant that produces less blurriness at the
+   *     cost of slightly more color fringes than the default one.  It might
+   *     be better, depending on taste, your monitor, or your personal vision.
+   *
+   *   FT_LCD_FILTER_LEGACY ::
+   *     This filter corresponds to the original libXft color filter.  It
+   *     provides high contrast output but can exhibit really bad color
+   *     fringes if glyphs are not extremely well hinted to the pixel grid.
+   *     In other words, it only works well if the TrueType bytecode
+   *     interpreter is enabled *and* high-quality hinted fonts are used.
+   *
+   *     This filter is only provided for comparison purposes, and might be
+   *     disabled or stay unsupported in the future.
+   *
+   * @since:
+   *   2.3.0
+   */
+  typedef enum  FT_LcdFilter_
+  {
+    FT_LCD_FILTER_NONE    = 0,
+    FT_LCD_FILTER_DEFAULT = 1,
+    FT_LCD_FILTER_LIGHT   = 2,
+    FT_LCD_FILTER_LEGACY  = 16,
+
+    FT_LCD_FILTER_MAX   /* do not remove */
+
+  } FT_LcdFilter;
+
+
+  /**************************************************************************
+   *
+   * @func:
+   *   FT_Library_SetLcdFilter
+   *
+   * @description:
+   *   This function is used to apply color filtering to LCD decimated
+   *   bitmaps, like the ones used when calling @FT_Render_Glyph with
+   *   @FT_RENDER_MODE_LCD or @FT_RENDER_MODE_LCD_V.
+   *
+   * @input:
+   *   library ::
+   *     A handle to the target library instance.
+   *
+   *   filter ::
+   *     The filter type.
+   *
+   *     You can use @FT_LCD_FILTER_NONE here to disable this feature, or
+   *     @FT_LCD_FILTER_DEFAULT to use a default filter that should work
+   *     well on most LCD screens.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   This feature is always disabled by default.  Clients must make an
+   *   explicit call to this function with a `filter' value other than
+   *   @FT_LCD_FILTER_NONE in order to enable it.
+   *
+   *   Due to *PATENTS* covering subpixel rendering, this function doesn't
+   *   do anything except returning `FT_Err_Unimplemented_Feature' if the
+   *   configuration macro FT_CONFIG_OPTION_SUBPIXEL_RENDERING is not
+   *   defined in your build of the library, which should correspond to all
+   *   default builds of FreeType.
+   *
+   *   The filter affects glyph bitmaps rendered through @FT_Render_Glyph,
+   *   @FT_Outline_Get_Bitmap, @FT_Load_Glyph, and @FT_Load_Char.
+   *
+   *   It does _not_ affect the output of @FT_Outline_Render and
+   *   @FT_Outline_Get_Bitmap.
+   *
+   *   If this feature is activated, the dimensions of LCD glyph bitmaps are
+   *   either larger or taller than the dimensions of the corresponding
+   *   outline with regards to the pixel grid.  For example, for
+   *   @FT_RENDER_MODE_LCD, the filter adds up to 3~pixels to the left, and
+   *   up to 3~pixels to the right.
+   *
+   *   The bitmap offset values are adjusted correctly, so clients shouldn't
+   *   need to modify their layout and glyph positioning code when enabling
+   *   the filter.
+   *
+   * @since:
+   *   2.3.0
+   */
+  FT_EXPORT( FT_Error )
+  FT_Library_SetLcdFilter( FT_Library    library,
+                           FT_LcdFilter  filter );
+
+
+  /**************************************************************************
+   *
+   * @func:
+   *   FT_Library_SetLcdFilterWeights
+   *
+   * @description:
+   *   Use this function to override the filter weights selected by
+   *   @FT_Library_SetLcdFilter.  By default, FreeType uses the quintuple
+   *   (0x00, 0x55, 0x56, 0x55, 0x00) for FT_LCD_FILTER_LIGHT, and (0x10,
+   *   0x40, 0x70, 0x40, 0x10) for FT_LCD_FILTER_DEFAULT and
+   *   FT_LCD_FILTER_LEGACY.
+   *
+   * @input:
+   *   library ::
+   *     A handle to the target library instance.
+   *
+   *   weights ::
+   *     A pointer to an array; the function copies the first five bytes and
+   *     uses them to specify the filter weights.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   Due to *PATENTS* covering subpixel rendering, this function doesn't
+   *   do anything except returning `FT_Err_Unimplemented_Feature' if the
+   *   configuration macro FT_CONFIG_OPTION_SUBPIXEL_RENDERING is not
+   *   defined in your build of the library, which should correspond to all
+   *   default builds of FreeType.
+   *
+   *   This function must be called after @FT_Library_SetLcdFilter to have
+   *   any effect.
+   *
+   * @since:
+   *   2.4.0
+   */
+  FT_EXPORT( FT_Error )
+  FT_Library_SetLcdFilterWeights( FT_Library      library,
+                                  unsigned char  *weights );
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FT_LCD_FILTER_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftlist.h b/include/freetype/ftlist.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftlist.h
@@ -0,0 +1,277 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftlist.h                                                               */
+/*                                                                         */
+/*    Generic list support for FreeType (specification).                   */
+/*                                                                         */
+/*  Copyright 1996-2001, 2003, 2007, 2010 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*  This file implements functions relative to list processing.  Its     */
+  /*  data structures are defined in `freetype.h'.                         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTLIST_H__
+#define __FTLIST_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    list_processing                                                    */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    List Processing                                                    */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Simple management of lists.                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains various definitions related to list          */
+  /*    processing using doubly-linked nodes.                              */
+  /*                                                                       */
+  /* <Order>                                                               */
+  /*    FT_List                                                            */
+  /*    FT_ListNode                                                        */
+  /*    FT_ListRec                                                         */
+  /*    FT_ListNodeRec                                                     */
+  /*                                                                       */
+  /*    FT_List_Add                                                        */
+  /*    FT_List_Insert                                                     */
+  /*    FT_List_Find                                                       */
+  /*    FT_List_Remove                                                     */
+  /*    FT_List_Up                                                         */
+  /*    FT_List_Iterate                                                    */
+  /*    FT_List_Iterator                                                   */
+  /*    FT_List_Finalize                                                   */
+  /*    FT_List_Destructor                                                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Find                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Find the list node for a given listed object.                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    list :: A pointer to the parent list.                              */
+  /*    data :: The address of the listed object.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    List node.  NULL if it wasn't found.                               */
+  /*                                                                       */
+  FT_EXPORT( FT_ListNode )
+  FT_List_Find( FT_List  list,
+                void*    data );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Add                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Append an element to the end of a list.                            */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    list :: A pointer to the parent list.                              */
+  /*    node :: The node to append.                                        */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_List_Add( FT_List      list,
+               FT_ListNode  node );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Insert                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Insert an element at the head of a list.                           */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    list :: A pointer to parent list.                                  */
+  /*    node :: The node to insert.                                        */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_List_Insert( FT_List      list,
+                  FT_ListNode  node );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Remove                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Remove a node from a list.  This function doesn't check whether    */
+  /*    the node is in the list!                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    node :: The node to remove.                                        */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    list :: A pointer to the parent list.                              */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_List_Remove( FT_List      list,
+                  FT_ListNode  node );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Up                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Move a node to the head/top of a list.  Used to maintain LRU       */
+  /*    lists.                                                             */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    list :: A pointer to the parent list.                              */
+  /*    node :: The node to move.                                          */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_List_Up( FT_List      list,
+              FT_ListNode  node );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_List_Iterator                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An FT_List iterator function which is called during a list parse   */
+  /*    by @FT_List_Iterate.                                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    node :: The current iteration list node.                           */
+  /*                                                                       */
+  /*    user :: A typeless pointer passed to @FT_List_Iterate.             */
+  /*            Can be used to point to the iteration's state.             */
+  /*                                                                       */
+  typedef FT_Error
+  (*FT_List_Iterator)( FT_ListNode  node,
+                       void*        user );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Iterate                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Parse a list and calls a given iterator function on each element.  */
+  /*    Note that parsing is stopped as soon as one of the iterator calls  */
+  /*    returns a non-zero value.                                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    list     :: A handle to the list.                                  */
+  /*    iterator :: An iterator function, called on each node of the list. */
+  /*    user     :: A user-supplied field which is passed as the second    */
+  /*                argument to the iterator.                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result (a FreeType error code) of the last iterator call.      */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_List_Iterate( FT_List           list,
+                   FT_List_Iterator  iterator,
+                   void*             user );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_List_Destructor                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An @FT_List iterator function which is called during a list        */
+  /*    finalization by @FT_List_Finalize to destroy all elements in a     */
+  /*    given list.                                                        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    system :: The current system object.                               */
+  /*                                                                       */
+  /*    data   :: The current object to destroy.                           */
+  /*                                                                       */
+  /*    user   :: A typeless pointer passed to @FT_List_Iterate.  It can   */
+  /*              be used to point to the iteration's state.               */
+  /*                                                                       */
+  typedef void
+  (*FT_List_Destructor)( FT_Memory  memory,
+                         void*      data,
+                         void*      user );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_List_Finalize                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroy all elements in the list as well as the list itself.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    list    :: A handle to the list.                                   */
+  /*                                                                       */
+  /*    destroy :: A list destructor that will be applied to each element  */
+  /*               of the list.                                            */
+  /*                                                                       */
+  /*    memory  :: The current memory object which handles deallocation.   */
+  /*                                                                       */
+  /*    user    :: A user-supplied field which is passed as the last       */
+  /*               argument to the destructor.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function expects that all nodes added by @FT_List_Add or      */
+  /*    @FT_List_Insert have been dynamically allocated.                   */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_List_Finalize( FT_List             list,
+                    FT_List_Destructor  destroy,
+                    FT_Memory           memory,
+                    void*               user );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTLIST_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftlzw.h b/include/freetype/ftlzw.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftlzw.h
@@ -0,0 +1,99 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftlzw.h                                                                */
+/*                                                                         */
+/*    LZW-compressed stream support.                                       */
+/*                                                                         */
+/*  Copyright 2004, 2006 by                                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTLZW_H__
+#define __FTLZW_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    lzw                                                                */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    LZW Streams                                                        */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Using LZW-compressed font files.                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of LZW-specific functions.   */
+  /*                                                                       */
+  /*************************************************************************/
+
+ /************************************************************************
+  *
+  * @function:
+  *   FT_Stream_OpenLZW
+  *
+  * @description:
+  *   Open a new stream to parse LZW-compressed font files.  This is
+  *   mainly used to support the compressed `*.pcf.Z' fonts that come
+  *   with XFree86.
+  *
+  * @input:
+  *   stream :: The target embedding stream.
+  *
+  *   source :: The source stream.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   The source stream must be opened _before_ calling this function.
+  *
+  *   Calling the internal function `FT_Stream_Close' on the new stream will
+  *   *not* call `FT_Stream_Close' on the source stream.  None of the stream
+  *   objects will be released to the heap.
+  *
+  *   The stream implementation is very basic and resets the decompression
+  *   process each time seeking backwards is needed within the stream
+  *
+  *   In certain builds of the library, LZW compression recognition is
+  *   automatically handled when calling @FT_New_Face or @FT_Open_Face.
+  *   This means that if no font driver is capable of handling the raw
+  *   compressed file, the library will try to open a LZW stream from it
+  *   and re-open the face with it.
+  *
+  *   This function may return `FT_Err_Unimplemented_Feature' if your build
+  *   of FreeType was not compiled with LZW support.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Stream_OpenLZW( FT_Stream  stream,
+                     FT_Stream  source );
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTLZW_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftmac.h b/include/freetype/ftmac.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftmac.h
@@ -0,0 +1,274 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftmac.h                                                                */
+/*                                                                         */
+/*    Additional Mac-specific API.                                         */
+/*                                                                         */
+/*  Copyright 1996-2001, 2004, 2006, 2007 by                               */
+/*  Just van Rossum, David Turner, Robert Wilhelm, and Werner Lemberg.     */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/* NOTE: Include this file after <freetype/freetype.h> and after any       */
+/*       Mac-specific headers (because this header uses Mac types such as  */
+/*       Handle, FSSpec, FSRef, etc.)                                      */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTMAC_H__
+#define __FTMAC_H__
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+
+/* gcc-3.4.1 and later can warn about functions tagged as deprecated */
+#ifndef FT_DEPRECATED_ATTRIBUTE
+#if defined(__GNUC__)                                               && \
+    ((__GNUC__ >= 4) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 1)))
+#define FT_DEPRECATED_ATTRIBUTE  __attribute__((deprecated))
+#else
+#define FT_DEPRECATED_ATTRIBUTE
+#endif
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    mac_specific                                                       */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Mac Specific Interface                                             */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Only available on the Macintosh.                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The following definitions are only available if FreeType is        */
+  /*    compiled on a Macintosh.                                           */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Face_From_FOND                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new face object from a FOND resource.                     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library resource.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    fond       :: A FOND resource.                                     */
+  /*                                                                       */
+  /*    face_index :: Only supported for the -1 `sanity check' special     */
+  /*                  case.                                                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aface      :: A handle to a new face object.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Notes>                                                               */
+  /*    This function can be used to create @FT_Face objects from fonts    */
+  /*    that are installed in the system as follows.                       */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      fond = GetResource( 'FOND', fontName );                          */
+  /*      error = FT_New_Face_From_FOND( library, fond, 0, &face );        */
+  /*    }                                                                  */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Face_From_FOND( FT_Library  library,
+                         Handle      fond,
+                         FT_Long     face_index,
+                         FT_Face    *aface )
+                       FT_DEPRECATED_ATTRIBUTE;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_GetFile_From_Mac_Name                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return an FSSpec for the disk file containing the named font.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    fontName   :: Mac OS name of the font (e.g., Times New Roman       */
+  /*                  Bold).                                               */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    pathSpec   :: FSSpec to the file.  For passing to                  */
+  /*                  @FT_New_Face_From_FSSpec.                            */
+  /*                                                                       */
+  /*    face_index :: Index of the face.  For passing to                   */
+  /*                  @FT_New_Face_From_FSSpec.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_GetFile_From_Mac_Name( const char*  fontName,
+                            FSSpec*      pathSpec,
+                            FT_Long*     face_index )
+                          FT_DEPRECATED_ATTRIBUTE;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_GetFile_From_Mac_ATS_Name                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return an FSSpec for the disk file containing the named font.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    fontName   :: Mac OS name of the font in ATS framework.            */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    pathSpec   :: FSSpec to the file. For passing to                   */
+  /*                  @FT_New_Face_From_FSSpec.                            */
+  /*                                                                       */
+  /*    face_index :: Index of the face. For passing to                    */
+  /*                  @FT_New_Face_From_FSSpec.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_GetFile_From_Mac_ATS_Name( const char*  fontName,
+                                FSSpec*      pathSpec,
+                                FT_Long*     face_index )
+                              FT_DEPRECATED_ATTRIBUTE;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_GetFilePath_From_Mac_ATS_Name                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return a pathname of the disk file and face index for given font   */
+  /*    name which is handled by ATS framework.                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    fontName    :: Mac OS name of the font in ATS framework.           */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    path        :: Buffer to store pathname of the file.  For passing  */
+  /*                   to @FT_New_Face.  The client must allocate this     */
+  /*                   buffer before calling this function.                */
+  /*                                                                       */
+  /*    maxPathSize :: Lengths of the buffer `path' that client allocated. */
+  /*                                                                       */
+  /*    face_index  :: Index of the face.  For passing to @FT_New_Face.    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_GetFilePath_From_Mac_ATS_Name( const char*  fontName,
+                                    UInt8*       path,
+                                    UInt32       maxPathSize,
+                                    FT_Long*     face_index )
+                                  FT_DEPRECATED_ATTRIBUTE;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Face_From_FSSpec                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new face object from a given resource and typeface index  */
+  /*    using an FSSpec to the font file.                                  */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library resource.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    spec       :: FSSpec to the font file.                             */
+  /*                                                                       */
+  /*    face_index :: The index of the face within the resource.  The      */
+  /*                  first face has index~0.                              */
+  /* <Output>                                                              */
+  /*    aface      :: A handle to a new face object.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    @FT_New_Face_From_FSSpec is identical to @FT_New_Face except       */
+  /*    it accepts an FSSpec instead of a path.                            */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Face_From_FSSpec( FT_Library     library,
+                           const FSSpec  *spec,
+                           FT_Long        face_index,
+                           FT_Face       *aface )
+                         FT_DEPRECATED_ATTRIBUTE;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Face_From_FSRef                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new face object from a given resource and typeface index  */
+  /*    using an FSRef to the font file.                                   */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library resource.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    spec       :: FSRef to the font file.                              */
+  /*                                                                       */
+  /*    face_index :: The index of the face within the resource.  The      */
+  /*                  first face has index~0.                              */
+  /* <Output>                                                              */
+  /*    aface      :: A handle to a new face object.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    @FT_New_Face_From_FSRef is identical to @FT_New_Face except        */
+  /*    it accepts an FSRef instead of a path.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Face_From_FSRef( FT_Library    library,
+                          const FSRef  *ref,
+                          FT_Long       face_index,
+                          FT_Face      *aface )
+                        FT_DEPRECATED_ATTRIBUTE;
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __FTMAC_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftmm.h b/include/freetype/ftmm.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftmm.h
@@ -0,0 +1,378 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftmm.h                                                                 */
+/*                                                                         */
+/*    FreeType Multiple Master font interface (specification).             */
+/*                                                                         */
+/*  Copyright 1996-2001, 2003, 2004, 2006, 2009 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTMM_H__
+#define __FTMM_H__
+
+
+#include <ft2build.h>
+#include FT_TYPE1_TABLES_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    multiple_masters                                                   */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Multiple Masters                                                   */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    How to manage Multiple Masters fonts.                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The following types and functions are used to manage Multiple      */
+  /*    Master fonts, i.e., the selection of specific design instances by  */
+  /*    setting design axis coordinates.                                   */
+  /*                                                                       */
+  /*    George Williams has extended this interface to make it work with   */
+  /*    both Type~1 Multiple Masters fonts and GX distortable (var)        */
+  /*    fonts.  Some of these routines only work with MM fonts, others     */
+  /*    will work with both types.  They are similar enough that a         */
+  /*    consistent interface makes sense.                                  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_MM_Axis                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to model a given axis in design space for  */
+  /*    Multiple Masters fonts.                                            */
+  /*                                                                       */
+  /*    This structure can't be used for GX var fonts.                     */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    name    :: The axis's name.                                        */
+  /*                                                                       */
+  /*    minimum :: The axis's minimum design coordinate.                   */
+  /*                                                                       */
+  /*    maximum :: The axis's maximum design coordinate.                   */
+  /*                                                                       */
+  typedef struct  FT_MM_Axis_
+  {
+    FT_String*  name;
+    FT_Long     minimum;
+    FT_Long     maximum;
+
+  } FT_MM_Axis;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Multi_Master                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model the axes and space of a Multiple Masters */
+  /*    font.                                                              */
+  /*                                                                       */
+  /*    This structure can't be used for GX var fonts.                     */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    num_axis    :: Number of axes.  Cannot exceed~4.                   */
+  /*                                                                       */
+  /*    num_designs :: Number of designs; should be normally 2^num_axis    */
+  /*                   even though the Type~1 specification strangely      */
+  /*                   allows for intermediate designs to be present. This */
+  /*                   number cannot exceed~16.                            */
+  /*                                                                       */
+  /*    axis        :: A table of axis descriptors.                        */
+  /*                                                                       */
+  typedef struct  FT_Multi_Master_
+  {
+    FT_UInt     num_axis;
+    FT_UInt     num_designs;
+    FT_MM_Axis  axis[T1_MAX_MM_AXIS];
+
+  } FT_Multi_Master;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Var_Axis                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to model a given axis in design space for  */
+  /*    Multiple Masters and GX var fonts.                                 */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    name    :: The axis's name.                                        */
+  /*               Not always meaningful for GX.                           */
+  /*                                                                       */
+  /*    minimum :: The axis's minimum design coordinate.                   */
+  /*                                                                       */
+  /*    def     :: The axis's default design coordinate.                   */
+  /*               FreeType computes meaningful default values for MM; it  */
+  /*               is then an integer value, not in 16.16 format.          */
+  /*                                                                       */
+  /*    maximum :: The axis's maximum design coordinate.                   */
+  /*                                                                       */
+  /*    tag     :: The axis's tag (the GX equivalent to `name').           */
+  /*               FreeType provides default values for MM if possible.    */
+  /*                                                                       */
+  /*    strid   :: The entry in `name' table (another GX version of        */
+  /*               `name').                                                */
+  /*               Not meaningful for MM.                                  */
+  /*                                                                       */
+  typedef struct  FT_Var_Axis_
+  {
+    FT_String*  name;
+
+    FT_Fixed    minimum;
+    FT_Fixed    def;
+    FT_Fixed    maximum;
+
+    FT_ULong    tag;
+    FT_UInt     strid;
+
+  } FT_Var_Axis;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Var_Named_Style                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to model a named style in a GX var font.   */
+  /*                                                                       */
+  /*    This structure can't be used for MM fonts.                         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    coords :: The design coordinates for this style.                   */
+  /*              This is an array with one entry for each axis.           */
+  /*                                                                       */
+  /*    strid  :: The entry in `name' table identifying this style.        */
+  /*                                                                       */
+  typedef struct  FT_Var_Named_Style_
+  {
+    FT_Fixed*  coords;
+    FT_UInt    strid;
+
+  } FT_Var_Named_Style;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_MM_Var                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model the axes and space of a Multiple Masters */
+  /*    or GX var distortable font.                                        */
+  /*                                                                       */
+  /*    Some fields are specific to one format and not to the other.       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    num_axis        :: The number of axes.  The maximum value is~4 for */
+  /*                       MM; no limit in GX.                             */
+  /*                                                                       */
+  /*    num_designs     :: The number of designs; should be normally       */
+  /*                       2^num_axis for MM fonts.  Not meaningful for GX */
+  /*                       (where every glyph could have a different       */
+  /*                       number of designs).                             */
+  /*                                                                       */
+  /*    num_namedstyles :: The number of named styles; only meaningful for */
+  /*                       GX which allows certain design coordinates to   */
+  /*                       have a string ID (in the `name' table)          */
+  /*                       associated with them.  The font can tell the    */
+  /*                       user that, for example, Weight=1.5 is `Bold'.   */
+  /*                                                                       */
+  /*    axis            :: A table of axis descriptors.                    */
+  /*                       GX fonts contain slightly more data than MM.    */
+  /*                                                                       */
+  /*    namedstyles     :: A table of named styles.                        */
+  /*                       Only meaningful with GX.                        */
+  /*                                                                       */
+  typedef struct  FT_MM_Var_
+  {
+    FT_UInt              num_axis;
+    FT_UInt              num_designs;
+    FT_UInt              num_namedstyles;
+    FT_Var_Axis*         axis;
+    FT_Var_Named_Style*  namedstyle;
+
+  } FT_MM_Var;
+
+
+  /* */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Multi_Master                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the Multiple Master descriptor of a given font.           */
+  /*                                                                       */
+  /*    This function can't be used with GX fonts.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face    :: A handle to the source face.                            */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    amaster :: The Multiple Masters descriptor.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Multi_Master( FT_Face           face,
+                       FT_Multi_Master  *amaster );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_MM_Var                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the Multiple Master/GX var descriptor of a given font.    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face    :: A handle to the source face.                            */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    amaster :: The Multiple Masters/GX var descriptor.                 */
+  /*               Allocates a data structure, which the user must free    */
+  /*               (a single call to FT_FREE will do it).                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_MM_Var( FT_Face      face,
+                 FT_MM_Var*  *amaster );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_MM_Design_Coordinates                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    For Multiple Masters fonts, choose an interpolated font design     */
+  /*    through design coordinates.                                        */
+  /*                                                                       */
+  /*    This function can't be used with GX fonts.                         */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face       :: A handle to the source face.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    num_coords :: The number of design coordinates (must be equal to   */
+  /*                  the number of axes in the font).                     */
+  /*                                                                       */
+  /*    coords     :: An array of design coordinates.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_MM_Design_Coordinates( FT_Face   face,
+                                FT_UInt   num_coords,
+                                FT_Long*  coords );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Var_Design_Coordinates                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    For Multiple Master or GX Var fonts, choose an interpolated font   */
+  /*    design through design coordinates.                                 */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face       :: A handle to the source face.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    num_coords :: The number of design coordinates (must be equal to   */
+  /*                  the number of axes in the font).                     */
+  /*                                                                       */
+  /*    coords     :: An array of design coordinates.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_Var_Design_Coordinates( FT_Face    face,
+                                 FT_UInt    num_coords,
+                                 FT_Fixed*  coords );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_MM_Blend_Coordinates                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    For Multiple Masters and GX var fonts, choose an interpolated font */
+  /*    design through normalized blend coordinates.                       */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    face       :: A handle to the source face.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    num_coords :: The number of design coordinates (must be equal to   */
+  /*                  the number of axes in the font).                     */
+  /*                                                                       */
+  /*    coords     :: The design coordinates array (each element must be   */
+  /*                  between 0 and 1.0).                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_MM_Blend_Coordinates( FT_Face    face,
+                               FT_UInt    num_coords,
+                               FT_Fixed*  coords );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Var_Blend_Coordinates                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This is another name of @FT_Set_MM_Blend_Coordinates.              */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_Var_Blend_Coordinates( FT_Face    face,
+                                FT_UInt    num_coords,
+                                FT_Fixed*  coords );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTMM_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftmodapi.h b/include/freetype/ftmodapi.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftmodapi.h
@@ -0,0 +1,634 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftmodapi.h                                                             */
+/*                                                                         */
+/*    FreeType modules public interface (specification).                   */
+/*                                                                         */
+/*  Copyright 1996-2003, 2006, 2008-2010, 2012 by                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTMODAPI_H__
+#define __FTMODAPI_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    module_management                                                  */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Module Management                                                  */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    How to add, upgrade, remove, and control modules from FreeType.    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The definitions below are used to manage modules within FreeType.  */
+  /*    Modules can be added, upgraded, and removed at runtime.            */
+  /*    Additionally, some module properties can be controlled also.       */
+  /*                                                                       */
+  /*    Here is a list of possible values of the `module_name' field in    */
+  /*    the @FT_Module_Class structure.                                    */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      autofitter                                                       */
+  /*      bdf                                                              */
+  /*      cff                                                              */
+  /*      gxvalid                                                          */
+  /*      otvalid                                                          */
+  /*      pcf                                                              */
+  /*      pfr                                                              */
+  /*      psaux                                                            */
+  /*      pshinter                                                         */
+  /*      psnames                                                          */
+  /*      raster1, raster5                                                 */
+  /*      sfnt                                                             */
+  /*      smooth, smooth-lcd, smooth-lcdv                                  */
+  /*      truetype                                                         */
+  /*      type1                                                            */
+  /*      type42                                                           */
+  /*      t1cid                                                            */
+  /*      winfonts                                                         */
+  /*    }                                                                  */
+  /*                                                                       */
+  /*    Note that the FreeType Cache sub-system is not a FreeType module.  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* module bit flags */
+#define FT_MODULE_FONT_DRIVER         1  /* this module is a font driver  */
+#define FT_MODULE_RENDERER            2  /* this module is a renderer     */
+#define FT_MODULE_HINTER              4  /* this module is a glyph hinter */
+#define FT_MODULE_STYLER              8  /* this module is a styler       */
+
+#define FT_MODULE_DRIVER_SCALABLE     0x100   /* the driver supports      */
+                                              /* scalable fonts           */
+#define FT_MODULE_DRIVER_NO_OUTLINES  0x200   /* the driver does not      */
+                                              /* support vector outlines  */
+#define FT_MODULE_DRIVER_HAS_HINTER   0x400   /* the driver provides its  */
+                                              /* own hinter               */
+
+
+  /* deprecated values */
+#define ft_module_font_driver         FT_MODULE_FONT_DRIVER
+#define ft_module_renderer            FT_MODULE_RENDERER
+#define ft_module_hinter              FT_MODULE_HINTER
+#define ft_module_styler              FT_MODULE_STYLER
+
+#define ft_module_driver_scalable     FT_MODULE_DRIVER_SCALABLE
+#define ft_module_driver_no_outlines  FT_MODULE_DRIVER_NO_OUTLINES
+#define ft_module_driver_has_hinter   FT_MODULE_DRIVER_HAS_HINTER
+
+
+  typedef FT_Pointer  FT_Module_Interface;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Module_Constructor                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to initialize (not create) a new module object.    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    module :: The module to initialize.                                */
+  /*                                                                       */
+  typedef FT_Error
+  (*FT_Module_Constructor)( FT_Module  module );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Module_Destructor                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to finalize (not destroy) a given module object.   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    module :: The module to finalize.                                  */
+  /*                                                                       */
+  typedef void
+  (*FT_Module_Destructor)( FT_Module  module );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Module_Requester                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to query a given module for a specific interface.  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    module :: The module to be searched.                               */
+  /*                                                                       */
+  /*    name ::   The name of the interface in the module.                 */
+  /*                                                                       */
+  typedef FT_Module_Interface
+  (*FT_Module_Requester)( FT_Module    module,
+                          const char*  name );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Module_Class                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The module class descriptor.                                       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    module_flags    :: Bit flags describing the module.                */
+  /*                                                                       */
+  /*    module_size     :: The size of one module object/instance in       */
+  /*                       bytes.                                          */
+  /*                                                                       */
+  /*    module_name     :: The name of the module.                         */
+  /*                                                                       */
+  /*    module_version  :: The version, as a 16.16 fixed number            */
+  /*                       (major.minor).                                  */
+  /*                                                                       */
+  /*    module_requires :: The version of FreeType this module requires,   */
+  /*                       as a 16.16 fixed number (major.minor).  Starts  */
+  /*                       at version 2.0, i.e., 0x20000.                  */
+  /*                                                                       */
+  /*    module_init     :: The initializing function.                      */
+  /*                                                                       */
+  /*    module_done     :: The finalizing function.                        */
+  /*                                                                       */
+  /*    get_interface   :: The interface requesting function.              */
+  /*                                                                       */
+  typedef struct  FT_Module_Class_
+  {
+    FT_ULong               module_flags;
+    FT_Long                module_size;
+    const FT_String*       module_name;
+    FT_Fixed               module_version;
+    FT_Fixed               module_requires;
+
+    const void*            module_interface;
+
+    FT_Module_Constructor  module_init;
+    FT_Module_Destructor   module_done;
+    FT_Module_Requester    get_interface;
+
+  } FT_Module_Class;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Add_Module                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Add a new module to a given library instance.                      */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library :: A handle to the library object.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    clazz   :: A pointer to class descriptor for the module.           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    An error will be returned if a module already exists by that name, */
+  /*    or if the module requires a version of FreeType that is too great. */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Add_Module( FT_Library              library,
+                 const FT_Module_Class*  clazz );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Module                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Find a module by its name.                                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library     :: A handle to the library object.                     */
+  /*                                                                       */
+  /*    module_name :: The module's name (as an ASCII string).             */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A module handle.  0~if none was found.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    FreeType's internal modules aren't documented very well, and you   */
+  /*    should look up the source code for details.                        */
+  /*                                                                       */
+  FT_EXPORT( FT_Module )
+  FT_Get_Module( FT_Library   library,
+                 const char*  module_name );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Remove_Module                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Remove a given module from a library instance.                     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library :: A handle to a library object.                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    module  :: A handle to a module object.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The module object is destroyed by the function in case of success. */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Remove_Module( FT_Library  library,
+                    FT_Module   module );
+
+
+  /**********************************************************************
+   *
+   * @function:
+   *    FT_Property_Set
+   *
+   * @description:
+   *    Set a property for a given module.
+   *
+   * @input:
+   *    library ::
+   *       A handle to the library the module is part of.
+   *
+   *    module_name ::
+   *       The module name.
+   *
+   *    property_name ::
+   *       The property name.  Properties are described in the `Synopsis'
+   *       subsection of the module's documentation.
+   *
+   *       Note that only a few modules have properties.
+   *
+   *    value ::
+   *       A generic pointer to a variable or structure which gives the new
+   *       value of the property.  The exact definition of `value' is
+   *       dependent on the property; see the `Synopsis' subsection of the
+   *       module's documentation.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *    If `module_name' isn't a valid module name, or `property_name'
+   *    doesn't specify a valid property, or if `value' doesn't represent a
+   *    valid value for the given property, an error is returned.
+   *
+   *    The following example sets property `bar' (a simple integer) in
+   *    module `foo' to value~1.
+   *
+   *    {
+   *      FT_UInt  bar;
+   *
+   *
+   *      bar = 1;
+   *      FT_Property_Set( library, "foo", "bar", &bar );
+   *    }
+   *
+   *    It is not possible to set properties of the FreeType Cache
+   *    sub-system with FT_Property_Set; use @FTC_Property_Set instead.
+   *
+   *  @since:
+   *    2.4.11
+   *
+   */
+  FT_Error
+  FT_Property_Set( FT_Library        library,
+                   const FT_String*  module_name,
+                   const FT_String*  property_name,
+                   const void*       value );
+
+
+  /**********************************************************************
+   *
+   * @function:
+   *    FT_Property_Get
+   *
+   * @description:
+   *    Get a module's property value.
+   *
+   * @input:
+   *    library ::
+   *       A handle to the library the module is part of.
+   *
+   *    module_name ::
+   *       The module name.
+   *
+   *    property_name ::
+   *       The property name.  Properties are described in the `Synopsis'
+   *       subsection of the module's documentation.
+   *
+   * @inout:
+   *    value ::
+   *       A generic pointer to a variable or structure which gives the
+   *       value of the property.  The exact definition of `value' is
+   *       dependent on the property; see the `Synopsis' subsection of the
+   *       module's documentation.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *    If `module_name' isn't a valid module name, or `property_name'
+   *    doesn't specify a valid property, or if `value' doesn't represent a
+   *    valid value for the given property, an error is returned.
+   *
+   *    The following example gets property `baz' (a range) in module `foo'.
+   *
+   *    {
+   *      typedef  range_
+   *      {
+   *        FT_Int32  min;
+   *        FT_Int32  max;
+   *
+   *      } range;
+   *
+   *      range  baz;
+   *
+   *
+   *      FT_Property_Get( library, "foo", "baz", &baz );
+   *    }
+   *
+   *    It is not possible to retrieve properties of the FreeType Cache
+   *    sub-system with FT_Property_Get; use @FTC_Property_Get instead.
+   *
+   *  @since:
+   *    2.4.11
+   *
+   */
+  FT_Error
+  FT_Property_Get( FT_Library        library,
+                   const FT_String*  module_name,
+                   const FT_String*  property_name,
+                   void*             value );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Reference_Library                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A counter gets initialized to~1 at the time an @FT_Library         */
+  /*    structure is created.  This function increments the counter.       */
+  /*    @FT_Done_Library then only destroys a library if the counter is~1, */
+  /*    otherwise it simply decrements the counter.                        */
+  /*                                                                       */
+  /*    This function helps in managing life-cycles of structures which    */
+  /*    reference @FT_Library objects.                                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to a target library object.                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Since>                                                               */
+  /*    2.4.2                                                              */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Reference_Library( FT_Library  library );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Library                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function is used to create a new FreeType library instance    */
+  /*    from a given memory object.  It is thus possible to use libraries  */
+  /*    with distinct memory allocators within the same program.           */
+  /*                                                                       */
+  /*    Normally, you would call this function (followed by a call to      */
+  /*    @FT_Add_Default_Modules or a series of calls to @FT_Add_Module)    */
+  /*    instead of @FT_Init_FreeType to initialize the FreeType library.   */
+  /*                                                                       */
+  /*    Don't use @FT_Done_FreeType but @FT_Done_Library to destroy a      */
+  /*    library instance.                                                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory   :: A handle to the original memory object.                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    alibrary :: A pointer to handle of a new library object.           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    See the discussion of reference counters in the description of     */
+  /*    @FT_Reference_Library.                                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Library( FT_Memory    memory,
+                  FT_Library  *alibrary );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_Library                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Discard a given library object.  This closes all drivers and       */
+  /*    discards all resource objects.                                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to the target library.                         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    See the discussion of reference counters in the description of     */
+  /*    @FT_Reference_Library.                                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Done_Library( FT_Library  library );
+
+/* */
+
+  typedef void
+  (*FT_DebugHook_Func)( void*  arg );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Debug_Hook                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Set a debug hook function for debugging the interpreter of a font  */
+  /*    format.                                                            */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library object.                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    hook_index :: The index of the debug hook.  You should use the     */
+  /*                  values defined in `ftobjs.h', e.g.,                  */
+  /*                  `FT_DEBUG_HOOK_TRUETYPE'.                            */
+  /*                                                                       */
+  /*    debug_hook :: The function used to debug the interpreter.          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Currently, four debug hook slots are available, but only two (for  */
+  /*    the TrueType and the Type~1 interpreter) are defined.              */
+  /*                                                                       */
+  /*    Since the internal headers of FreeType are no longer installed,    */
+  /*    the symbol `FT_DEBUG_HOOK_TRUETYPE' isn't available publicly.      */
+  /*    This is a bug and will be fixed in a forthcoming release.          */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Set_Debug_Hook( FT_Library         library,
+                     FT_UInt            hook_index,
+                     FT_DebugHook_Func  debug_hook );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Add_Default_Modules                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Add the set of default drivers to a given library object.          */
+  /*    This is only useful when you create a library object with          */
+  /*    @FT_New_Library (usually to plug a custom memory manager).         */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library :: A handle to a new library object.                       */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Add_Default_Modules( FT_Library  library );
+
+
+
+  /**************************************************************************
+   *
+   * @section:
+   *   truetype_engine
+   *
+   * @title:
+   *   The TrueType Engine
+   *
+   * @abstract:
+   *   TrueType bytecode support.
+   *
+   * @description:
+   *   This section contains a function used to query the level of TrueType
+   *   bytecode support compiled in this version of the library.
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   *  @enum:
+   *     FT_TrueTypeEngineType
+   *
+   *  @description:
+   *     A list of values describing which kind of TrueType bytecode
+   *     engine is implemented in a given FT_Library instance.  It is used
+   *     by the @FT_Get_TrueType_Engine_Type function.
+   *
+   *  @values:
+   *     FT_TRUETYPE_ENGINE_TYPE_NONE ::
+   *       The library doesn't implement any kind of bytecode interpreter.
+   *
+   *     FT_TRUETYPE_ENGINE_TYPE_UNPATENTED ::
+   *       The library implements a bytecode interpreter that doesn't
+   *       support the patented operations of the TrueType virtual machine.
+   *
+   *       Its main use is to load certain Asian fonts which position and
+   *       scale glyph components with bytecode instructions.  It produces
+   *       bad output for most other fonts.
+   *
+   *     FT_TRUETYPE_ENGINE_TYPE_PATENTED ::
+   *       The library implements a bytecode interpreter that covers
+   *       the full instruction set of the TrueType virtual machine (this
+   *       was governed by patents until May 2010, hence the name).
+   *
+   *  @since:
+   *     2.2
+   *
+   */
+  typedef enum  FT_TrueTypeEngineType_
+  {
+    FT_TRUETYPE_ENGINE_TYPE_NONE = 0,
+    FT_TRUETYPE_ENGINE_TYPE_UNPATENTED,
+    FT_TRUETYPE_ENGINE_TYPE_PATENTED
+
+  } FT_TrueTypeEngineType;
+
+
+  /**************************************************************************
+   *
+   *  @func:
+   *     FT_Get_TrueType_Engine_Type
+   *
+   *  @description:
+   *     Return an @FT_TrueTypeEngineType value to indicate which level of
+   *     the TrueType virtual machine a given library instance supports.
+   *
+   *  @input:
+   *     library ::
+   *       A library instance.
+   *
+   *  @return:
+   *     A value indicating which level is supported.
+   *
+   *  @since:
+   *     2.2
+   *
+   */
+  FT_EXPORT( FT_TrueTypeEngineType )
+  FT_Get_TrueType_Engine_Type( FT_Library  library );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTMODAPI_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftmoderr.h b/include/freetype/ftmoderr.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftmoderr.h
@@ -0,0 +1,156 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftmoderr.h                                                             */
+/*                                                                         */
+/*    FreeType module error offsets (specification).                       */
+/*                                                                         */
+/*  Copyright 2001, 2002, 2003, 2004, 2005, 2010 by                        */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This file is used to define the FreeType module error offsets.        */
+  /*                                                                       */
+  /* The lower byte gives the error code, the higher byte gives the        */
+  /* module.  The base module has error offset 0.  For example, the error  */
+  /* `FT_Err_Invalid_File_Format' has value 0x003, the error               */
+  /* `TT_Err_Invalid_File_Format' has value 0x1103, the error              */
+  /* `T1_Err_Invalid_File_Format' has value 0x1203, etc.                   */
+  /*                                                                       */
+  /* Undefine the macro FT_CONFIG_OPTION_USE_MODULE_ERRORS in ftoption.h   */
+  /* to make the higher byte always zero (disabling the module error       */
+  /* mechanism).                                                           */
+  /*                                                                       */
+  /* It can also be used to create a module error message table easily     */
+  /* with something like                                                   */
+  /*                                                                       */
+  /*   {                                                                   */
+  /*     #undef __FTMODERR_H__                                             */
+  /*     #define FT_MODERRDEF( e, v, s )  { FT_Mod_Err_ ## e, s },         */
+  /*     #define FT_MODERR_START_LIST     {                                */
+  /*     #define FT_MODERR_END_LIST       { 0, 0 } };                      */
+  /*                                                                       */
+  /*     const struct                                                      */
+  /*     {                                                                 */
+  /*       int          mod_err_offset;                                    */
+  /*       const char*  mod_err_msg                                        */
+  /*     } ft_mod_errors[] =                                               */
+  /*                                                                       */
+  /*     #include FT_MODULE_ERRORS_H                                       */
+  /*   }                                                                   */
+  /*                                                                       */
+  /* To use such a table, all errors must be ANDed with 0xFF00 to remove   */
+  /* the error code.                                                       */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTMODERR_H__
+#define __FTMODERR_H__
+
+
+  /*******************************************************************/
+  /*******************************************************************/
+  /*****                                                         *****/
+  /*****                       SETUP MACROS                      *****/
+  /*****                                                         *****/
+  /*******************************************************************/
+  /*******************************************************************/
+
+
+#undef  FT_NEED_EXTERN_C
+
+#ifndef FT_MODERRDEF
+
+#ifdef FT_CONFIG_OPTION_USE_MODULE_ERRORS
+#define FT_MODERRDEF( e, v, s )  FT_Mod_Err_ ## e = v,
+#else
+#define FT_MODERRDEF( e, v, s )  FT_Mod_Err_ ## e = 0,
+#endif
+
+#define FT_MODERR_START_LIST  enum {
+#define FT_MODERR_END_LIST    FT_Mod_Err_Max };
+
+#ifdef __cplusplus
+#define FT_NEED_EXTERN_C
+  extern "C" {
+#endif
+
+#endif /* !FT_MODERRDEF */
+
+
+  /*******************************************************************/
+  /*******************************************************************/
+  /*****                                                         *****/
+  /*****               LIST MODULE ERROR BASES                   *****/
+  /*****                                                         *****/
+  /*******************************************************************/
+  /*******************************************************************/
+
+
+#ifdef FT_MODERR_START_LIST
+  FT_MODERR_START_LIST
+#endif
+
+
+  FT_MODERRDEF( Base,      0x000, "base module" )
+  FT_MODERRDEF( Autofit,   0x100, "autofitter module" )
+  FT_MODERRDEF( BDF,       0x200, "BDF module" )
+  FT_MODERRDEF( Bzip2,     0x300, "Bzip2 module" )
+  FT_MODERRDEF( Cache,     0x400, "cache module" )
+  FT_MODERRDEF( CFF,       0x500, "CFF module" )
+  FT_MODERRDEF( CID,       0x600, "CID module" )
+  FT_MODERRDEF( Gzip,      0x700, "Gzip module" )
+  FT_MODERRDEF( LZW,       0x800, "LZW module" )
+  FT_MODERRDEF( OTvalid,   0x900, "OpenType validation module" )
+  FT_MODERRDEF( PCF,       0xA00, "PCF module" )
+  FT_MODERRDEF( PFR,       0xB00, "PFR module" )
+  FT_MODERRDEF( PSaux,     0xC00, "PS auxiliary module" )
+  FT_MODERRDEF( PShinter,  0xD00, "PS hinter module" )
+  FT_MODERRDEF( PSnames,   0xE00, "PS names module" )
+  FT_MODERRDEF( Raster,    0xF00, "raster module" )
+  FT_MODERRDEF( SFNT,     0x1000, "SFNT module" )
+  FT_MODERRDEF( Smooth,   0x1100, "smooth raster module" )
+  FT_MODERRDEF( TrueType, 0x1200, "TrueType module" )
+  FT_MODERRDEF( Type1,    0x1300, "Type 1 module" )
+  FT_MODERRDEF( Type42,   0x1400, "Type 42 module" )
+  FT_MODERRDEF( Winfonts, 0x1500, "Windows FON/FNT module" )
+
+
+#ifdef FT_MODERR_END_LIST
+  FT_MODERR_END_LIST
+#endif
+
+
+  /*******************************************************************/
+  /*******************************************************************/
+  /*****                                                         *****/
+  /*****                      CLEANUP                            *****/
+  /*****                                                         *****/
+  /*******************************************************************/
+  /*******************************************************************/
+
+
+#ifdef FT_NEED_EXTERN_C
+  }
+#endif
+
+#undef FT_MODERR_START_LIST
+#undef FT_MODERR_END_LIST
+#undef FT_MODERRDEF
+#undef FT_NEED_EXTERN_C
+
+
+#endif /* __FTMODERR_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftotval.h b/include/freetype/ftotval.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftotval.h
@@ -0,0 +1,203 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftotval.h                                                              */
+/*                                                                         */
+/*    FreeType API for validating OpenType tables (specification).         */
+/*                                                                         */
+/*  Copyright 2004, 2005, 2006, 2007 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+/***************************************************************************/
+/*                                                                         */
+/*                                                                         */
+/* Warning: This module might be moved to a different library in the       */
+/*          future to avoid a tight dependency between FreeType and the    */
+/*          OpenType specification.                                        */
+/*                                                                         */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTOTVAL_H__
+#define __FTOTVAL_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    ot_validation                                                      */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    OpenType Validation                                                */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    An API to validate OpenType tables.                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of functions to validate     */
+  /*    some OpenType tables (BASE, GDEF, GPOS, GSUB, JSTF, MATH).         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+ /**********************************************************************
+  *
+  * @enum:
+  *    FT_VALIDATE_OTXXX
+  *
+  * @description:
+  *    A list of bit-field constants used with @FT_OpenType_Validate to
+  *    indicate which OpenType tables should be validated.
+  *
+  * @values:
+  *    FT_VALIDATE_BASE ::
+  *      Validate BASE table.
+  *
+  *    FT_VALIDATE_GDEF ::
+  *      Validate GDEF table.
+  *
+  *    FT_VALIDATE_GPOS ::
+  *      Validate GPOS table.
+  *
+  *    FT_VALIDATE_GSUB ::
+  *      Validate GSUB table.
+  *
+  *    FT_VALIDATE_JSTF ::
+  *      Validate JSTF table.
+  *
+  *    FT_VALIDATE_MATH ::
+  *      Validate MATH table.
+  *
+  *    FT_VALIDATE_OT ::
+  *      Validate all OpenType tables (BASE, GDEF, GPOS, GSUB, JSTF, MATH).
+  *
+  */
+#define FT_VALIDATE_BASE  0x0100
+#define FT_VALIDATE_GDEF  0x0200
+#define FT_VALIDATE_GPOS  0x0400
+#define FT_VALIDATE_GSUB  0x0800
+#define FT_VALIDATE_JSTF  0x1000
+#define FT_VALIDATE_MATH  0x2000
+
+#define FT_VALIDATE_OT  FT_VALIDATE_BASE | \
+                        FT_VALIDATE_GDEF | \
+                        FT_VALIDATE_GPOS | \
+                        FT_VALIDATE_GSUB | \
+                        FT_VALIDATE_JSTF | \
+                        FT_VALIDATE_MATH
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_OpenType_Validate
+  *
+  * @description:
+  *    Validate various OpenType tables to assure that all offsets and
+  *    indices are valid.  The idea is that a higher-level library which
+  *    actually does the text layout can access those tables without
+  *    error checking (which can be quite time consuming).
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  *    validation_flags ::
+  *       A bit field which specifies the tables to be validated.  See
+  *       @FT_VALIDATE_OTXXX for possible values.
+  *
+  * @output:
+  *    BASE_table ::
+  *       A pointer to the BASE table.
+  *
+  *    GDEF_table ::
+  *       A pointer to the GDEF table.
+  *
+  *    GPOS_table ::
+  *       A pointer to the GPOS table.
+  *
+  *    GSUB_table ::
+  *       A pointer to the GSUB table.
+  *
+  *    JSTF_table ::
+  *       A pointer to the JSTF table.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   This function only works with OpenType fonts, returning an error
+  *   otherwise.
+  *
+  *   After use, the application should deallocate the five tables with
+  *   @FT_OpenType_Free.  A NULL value indicates that the table either
+  *   doesn't exist in the font, or the application hasn't asked for
+  *   validation.
+  */
+  FT_EXPORT( FT_Error )
+  FT_OpenType_Validate( FT_Face    face,
+                        FT_UInt    validation_flags,
+                        FT_Bytes  *BASE_table,
+                        FT_Bytes  *GDEF_table,
+                        FT_Bytes  *GPOS_table,
+                        FT_Bytes  *GSUB_table,
+                        FT_Bytes  *JSTF_table );
+
+  /* */
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_OpenType_Free
+  *
+  * @description:
+  *    Free the buffer allocated by OpenType validator.
+  *
+  * @input:
+  *    face ::
+  *       A handle to the input face.
+  *
+  *    table ::
+  *       The pointer to the buffer that is allocated by
+  *       @FT_OpenType_Validate.
+  *
+  * @note:
+  *   This function must be used to free the buffer allocated by
+  *   @FT_OpenType_Validate only.
+  */
+  FT_EXPORT( void )
+  FT_OpenType_Free( FT_Face   face,
+                    FT_Bytes  table );
+
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTOTVAL_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftoutln.h b/include/freetype/ftoutln.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftoutln.h
@@ -0,0 +1,558 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftoutln.h                                                              */
+/*                                                                         */
+/*    Support for the FT_Outline type used to store glyph shapes of        */
+/*    most scalable font formats (specification).                          */
+/*                                                                         */
+/*  Copyright 1996-2003, 2005-2012 by                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTOUTLN_H__
+#define __FTOUTLN_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    outline_processing                                                 */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Outline Processing                                                 */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Functions to create, transform, and render vectorial glyph images. */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains routines used to create and destroy scalable */
+  /*    glyph images known as `outlines'.  These can also be measured,     */
+  /*    transformed, and converted into bitmaps and pixmaps.               */
+  /*                                                                       */
+  /* <Order>                                                               */
+  /*    FT_Outline                                                         */
+  /*    FT_OUTLINE_FLAGS                                                   */
+  /*    FT_Outline_New                                                     */
+  /*    FT_Outline_Done                                                    */
+  /*    FT_Outline_Copy                                                    */
+  /*    FT_Outline_Translate                                               */
+  /*    FT_Outline_Transform                                               */
+  /*    FT_Outline_Embolden                                                */
+  /*    FT_Outline_EmboldenXY                                              */
+  /*    FT_Outline_Reverse                                                 */
+  /*    FT_Outline_Check                                                   */
+  /*                                                                       */
+  /*    FT_Outline_Get_CBox                                                */
+  /*    FT_Outline_Get_BBox                                                */
+  /*                                                                       */
+  /*    FT_Outline_Get_Bitmap                                              */
+  /*    FT_Outline_Render                                                  */
+  /*                                                                       */
+  /*    FT_Outline_Decompose                                               */
+  /*    FT_Outline_Funcs                                                   */
+  /*    FT_Outline_MoveTo_Func                                             */
+  /*    FT_Outline_LineTo_Func                                             */
+  /*    FT_Outline_ConicTo_Func                                            */
+  /*    FT_Outline_CubicTo_Func                                            */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Decompose                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Walk over an outline's structure to decompose it into individual   */
+  /*    segments and Bézier arcs.  This function also emits `move to'      */
+  /*    operations to indicate the start of new contours in the outline.   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    outline        :: A pointer to the source target.                  */
+  /*                                                                       */
+  /*    func_interface :: A table of `emitters', i.e., function pointers   */
+  /*                      called during decomposition to indicate path     */
+  /*                      operations.                                      */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    user           :: A typeless pointer which is passed to each       */
+  /*                      emitter during the decomposition.  It can be     */
+  /*                      used to store the state during the               */
+  /*                      decomposition.                                   */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Decompose( FT_Outline*              outline,
+                        const FT_Outline_Funcs*  func_interface,
+                        void*                    user );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_New                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new outline of a given size.                              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library     :: A handle to the library object from where the       */
+  /*                   outline is allocated.  Note however that the new    */
+  /*                   outline will *not* necessarily be *freed*, when     */
+  /*                   destroying the library, by @FT_Done_FreeType.       */
+  /*                                                                       */
+  /*    numPoints   :: The maximum number of points within the outline.    */
+  /*                                                                       */
+  /*    numContours :: The maximum number of contours within the outline.  */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    anoutline   :: A handle to the new outline.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The reason why this function takes a `library' parameter is simply */
+  /*    to use the library's memory allocator.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_New( FT_Library   library,
+                  FT_UInt      numPoints,
+                  FT_Int       numContours,
+                  FT_Outline  *anoutline );
+
+
+  FT_EXPORT( FT_Error )
+  FT_Outline_New_Internal( FT_Memory    memory,
+                           FT_UInt      numPoints,
+                           FT_Int       numContours,
+                           FT_Outline  *anoutline );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Done                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroy an outline created with @FT_Outline_New.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle of the library object used to allocate the     */
+  /*               outline.                                                */
+  /*                                                                       */
+  /*    outline :: A pointer to the outline object to be discarded.        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If the outline's `owner' field is not set, only the outline        */
+  /*    descriptor will be released.                                       */
+  /*                                                                       */
+  /*    The reason why this function takes an `library' parameter is       */
+  /*    simply to use ft_mem_free().                                       */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Done( FT_Library   library,
+                   FT_Outline*  outline );
+
+
+  FT_EXPORT( FT_Error )
+  FT_Outline_Done_Internal( FT_Memory    memory,
+                            FT_Outline*  outline );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Check                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Check the contents of an outline descriptor.                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    outline :: A handle to a source outline.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Check( FT_Outline*  outline );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Get_CBox                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return an outline's `control box'.  The control box encloses all   */
+  /*    the outline's points, including Bézier control points.  Though it  */
+  /*    coincides with the exact bounding box for most glyphs, it can be   */
+  /*    slightly larger in some situations (like when rotating an outline  */
+  /*    which contains Bézier outside arcs).                               */
+  /*                                                                       */
+  /*    Computing the control box is very fast, while getting the bounding */
+  /*    box can take much more time as it needs to walk over all segments  */
+  /*    and arcs in the outline.  To get the latter, you can use the       */
+  /*    `ftbbox' component which is dedicated to this single task.         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    outline :: A pointer to the source outline descriptor.             */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    acbox   :: The outline's control box.                              */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    See @FT_Glyph_Get_CBox for a discussion of tricky fonts.           */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Outline_Get_CBox( const FT_Outline*  outline,
+                       FT_BBox           *acbox );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Translate                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Apply a simple translation to the points of an outline.            */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    outline :: A pointer to the target outline descriptor.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    xOffset :: The horizontal offset.                                  */
+  /*                                                                       */
+  /*    yOffset :: The vertical offset.                                    */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Outline_Translate( const FT_Outline*  outline,
+                        FT_Pos             xOffset,
+                        FT_Pos             yOffset );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Copy                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Copy an outline into another one.  Both objects must have the      */
+  /*    same sizes (number of points & number of contours) when this       */
+  /*    function is called.                                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    source :: A handle to the source outline.                          */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    target :: A handle to the target outline.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Copy( const FT_Outline*  source,
+                   FT_Outline        *target );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Transform                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Apply a simple 2x2 matrix to all of an outline's points.  Useful   */
+  /*    for applying rotations, slanting, flipping, etc.                   */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    outline :: A pointer to the target outline descriptor.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    matrix  :: A pointer to the transformation matrix.                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You can use @FT_Outline_Translate if you need to translate the     */
+  /*    outline's points.                                                  */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Outline_Transform( const FT_Outline*  outline,
+                        const FT_Matrix*   matrix );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Embolden                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Embolden an outline.  The new outline will be at most 4~times      */
+  /*    `strength' pixels wider and higher.  You may think of the left and */
+  /*    bottom borders as unchanged.                                       */
+  /*                                                                       */
+  /*    Negative `strength' values to reduce the outline thickness are     */
+  /*    possible also.                                                     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    outline  :: A handle to the target outline.                        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    strength :: How strong the glyph is emboldened.  Expressed in      */
+  /*                26.6 pixel format.                                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The used algorithm to increase or decrease the thickness of the    */
+  /*    glyph doesn't change the number of points; this means that certain */
+  /*    situations like acute angles or intersections are sometimes        */
+  /*    handled incorrectly.                                               */
+  /*                                                                       */
+  /*    If you need `better' metrics values you should call                */
+  /*    @FT_Outline_Get_CBox or @FT_Outline_Get_BBox.                      */
+  /*                                                                       */
+  /*    Example call:                                                      */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      FT_Load_Glyph( face, index, FT_LOAD_DEFAULT );                   */
+  /*      if ( face->slot->format == FT_GLYPH_FORMAT_OUTLINE )             */
+  /*        FT_Outline_Embolden( &face->slot->outline, strength );         */
+  /*    }                                                                  */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Embolden( FT_Outline*  outline,
+                       FT_Pos       strength );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_EmboldenXY                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Embolden an outline.  The new outline will be `xstrength' pixels   */
+  /*    wider and `ystrength' pixels higher.  Otherwise, it is similar to  */
+  /*    @FT_Outline_Embolden, which uses the same strength in both         */
+  /*    directions.                                                        */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_EmboldenXY( FT_Outline*  outline,
+                         FT_Pos       xstrength,
+                         FT_Pos       ystrength );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Reverse                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Reverse the drawing direction of an outline.  This is used to      */
+  /*    ensure consistent fill conventions for mirrored glyphs.            */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    outline :: A pointer to the target outline descriptor.             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function toggles the bit flag @FT_OUTLINE_REVERSE_FILL in     */
+  /*    the outline's `flags' field.                                       */
+  /*                                                                       */
+  /*    It shouldn't be used by a normal client application, unless it     */
+  /*    knows what it is doing.                                            */
+  /*                                                                       */
+  FT_EXPORT( void )
+  FT_Outline_Reverse( FT_Outline*  outline );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Get_Bitmap                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Render an outline within a bitmap.  The outline's image is simply  */
+  /*    OR-ed to the target bitmap.                                        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to a FreeType library object.                  */
+  /*                                                                       */
+  /*    outline :: A pointer to the source outline descriptor.             */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    abitmap :: A pointer to the target bitmap descriptor.              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function does NOT CREATE the bitmap, it only renders an       */
+  /*    outline image within the one you pass to it!  Consequently, the    */
+  /*    various fields in `abitmap' should be set accordingly.             */
+  /*                                                                       */
+  /*    It will use the raster corresponding to the default glyph format.  */
+  /*                                                                       */
+  /*    The value of the `num_grays' field in `abitmap' is ignored.  If    */
+  /*    you select the gray-level rasterizer, and you want less than 256   */
+  /*    gray levels, you have to use @FT_Outline_Render directly.          */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Get_Bitmap( FT_Library        library,
+                         FT_Outline*       outline,
+                         const FT_Bitmap  *abitmap );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Outline_Render                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Render an outline within a bitmap using the current scan-convert.  */
+  /*    This function uses an @FT_Raster_Params structure as an argument,  */
+  /*    allowing advanced features like direct composition, translucency,  */
+  /*    etc.                                                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to a FreeType library object.                  */
+  /*                                                                       */
+  /*    outline :: A pointer to the source outline descriptor.             */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    params  :: A pointer to an @FT_Raster_Params structure used to     */
+  /*               describe the rendering operation.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You should know what you are doing and how @FT_Raster_Params works */
+  /*    to use this function.                                              */
+  /*                                                                       */
+  /*    The field `params.source' will be set to `outline' before the scan */
+  /*    converter is called, which means that the value you give to it is  */
+  /*    actually ignored.                                                  */
+  /*                                                                       */
+  /*    The gray-level rasterizer always uses 256 gray levels.  If you     */
+  /*    want less gray levels, you have to provide your own span callback. */
+  /*    See the @FT_RASTER_FLAG_DIRECT value of the `flags' field in the   */
+  /*    @FT_Raster_Params structure for more details.                      */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Outline_Render( FT_Library         library,
+                     FT_Outline*        outline,
+                     FT_Raster_Params*  params );
+
+
+ /**************************************************************************
+  *
+  * @enum:
+  *   FT_Orientation
+  *
+  * @description:
+  *   A list of values used to describe an outline's contour orientation.
+  *
+  *   The TrueType and PostScript specifications use different conventions
+  *   to determine whether outline contours should be filled or unfilled.
+  *
+  * @values:
+  *   FT_ORIENTATION_TRUETYPE ::
+  *     According to the TrueType specification, clockwise contours must
+  *     be filled, and counter-clockwise ones must be unfilled.
+  *
+  *   FT_ORIENTATION_POSTSCRIPT ::
+  *     According to the PostScript specification, counter-clockwise contours
+  *     must be filled, and clockwise ones must be unfilled.
+  *
+  *   FT_ORIENTATION_FILL_RIGHT ::
+  *     This is identical to @FT_ORIENTATION_TRUETYPE, but is used to
+  *     remember that in TrueType, everything that is to the right of
+  *     the drawing direction of a contour must be filled.
+  *
+  *   FT_ORIENTATION_FILL_LEFT ::
+  *     This is identical to @FT_ORIENTATION_POSTSCRIPT, but is used to
+  *     remember that in PostScript, everything that is to the left of
+  *     the drawing direction of a contour must be filled.
+  *
+  *   FT_ORIENTATION_NONE ::
+  *     The orientation cannot be determined.  That is, different parts of
+  *     the glyph have different orientation.
+  *
+  */
+  typedef enum  FT_Orientation_
+  {
+    FT_ORIENTATION_TRUETYPE   = 0,
+    FT_ORIENTATION_POSTSCRIPT = 1,
+    FT_ORIENTATION_FILL_RIGHT = FT_ORIENTATION_TRUETYPE,
+    FT_ORIENTATION_FILL_LEFT  = FT_ORIENTATION_POSTSCRIPT,
+    FT_ORIENTATION_NONE
+
+  } FT_Orientation;
+
+
+ /**************************************************************************
+  *
+  * @function:
+  *   FT_Outline_Get_Orientation
+  *
+  * @description:
+  *   This function analyzes a glyph outline and tries to compute its
+  *   fill orientation (see @FT_Orientation).  This is done by computing
+  *   the direction of each global horizontal and/or vertical extrema
+  *   within the outline.
+  *
+  *   Note that this will return @FT_ORIENTATION_TRUETYPE for empty
+  *   outlines.
+  *
+  * @input:
+  *   outline ::
+  *     A handle to the source outline.
+  *
+  * @return:
+  *   The orientation.
+  *
+  */
+  FT_EXPORT( FT_Orientation )
+  FT_Outline_Get_Orientation( FT_Outline*  outline );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTOUTLN_H__ */
+
+
+/* END */
+
+
+/* Local Variables: */
+/* coding: utf-8    */
+/* End:             */
diff --git a/include/freetype/ftpfr.h b/include/freetype/ftpfr.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftpfr.h
@@ -0,0 +1,172 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftpfr.h                                                                */
+/*                                                                         */
+/*    FreeType API for accessing PFR-specific data (specification only).   */
+/*                                                                         */
+/*  Copyright 2002, 2003, 2004, 2006, 2008, 2009 by                        */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTPFR_H__
+#define __FTPFR_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    pfr_fonts                                                          */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    PFR Fonts                                                          */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    PFR/TrueDoc specific API.                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of PFR-specific functions.   */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_Get_PFR_Metrics
+  *
+  * @description:
+  *    Return the outline and metrics resolutions of a given PFR face.
+  *
+  * @input:
+  *    face :: Handle to the input face.  It can be a non-PFR face.
+  *
+  * @output:
+  *    aoutline_resolution ::
+  *      Outline resolution.  This is equivalent to `face->units_per_EM'
+  *      for non-PFR fonts.  Optional (parameter can be NULL).
+  *
+  *    ametrics_resolution ::
+  *      Metrics resolution.  This is equivalent to `outline_resolution'
+  *      for non-PFR fonts.  Optional (parameter can be NULL).
+  *
+  *    ametrics_x_scale ::
+  *      A 16.16 fixed-point number used to scale distance expressed
+  *      in metrics units to device sub-pixels.  This is equivalent to
+  *      `face->size->x_scale', but for metrics only.  Optional (parameter
+  *      can be NULL).
+  *
+  *    ametrics_y_scale ::
+  *      Same as `ametrics_x_scale' but for the vertical direction.
+  *      optional (parameter can be NULL).
+  *
+  * @return:
+  *    FreeType error code.  0~means success.
+  *
+  * @note:
+  *   If the input face is not a PFR, this function will return an error.
+  *   However, in all cases, it will return valid values.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Get_PFR_Metrics( FT_Face    face,
+                      FT_UInt   *aoutline_resolution,
+                      FT_UInt   *ametrics_resolution,
+                      FT_Fixed  *ametrics_x_scale,
+                      FT_Fixed  *ametrics_y_scale );
+
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_Get_PFR_Kerning
+  *
+  * @description:
+  *    Return the kerning pair corresponding to two glyphs in a PFR face.
+  *    The distance is expressed in metrics units, unlike the result of
+  *    @FT_Get_Kerning.
+  *
+  * @input:
+  *    face  :: A handle to the input face.
+  *
+  *    left  :: Index of the left glyph.
+  *
+  *    right :: Index of the right glyph.
+  *
+  * @output:
+  *    avector :: A kerning vector.
+  *
+  * @return:
+  *    FreeType error code.  0~means success.
+  *
+  * @note:
+  *    This function always return distances in original PFR metrics
+  *    units.  This is unlike @FT_Get_Kerning with the @FT_KERNING_UNSCALED
+  *    mode, which always returns distances converted to outline units.
+  *
+  *    You can use the value of the `x_scale' and `y_scale' parameters
+  *    returned by @FT_Get_PFR_Metrics to scale these to device sub-pixels.
+  */
+  FT_EXPORT( FT_Error )
+  FT_Get_PFR_Kerning( FT_Face     face,
+                      FT_UInt     left,
+                      FT_UInt     right,
+                      FT_Vector  *avector );
+
+
+ /**********************************************************************
+  *
+  * @function:
+  *    FT_Get_PFR_Advance
+  *
+  * @description:
+  *    Return a given glyph advance, expressed in original metrics units,
+  *    from a PFR font.
+  *
+  * @input:
+  *    face   :: A handle to the input face.
+  *
+  *    gindex :: The glyph index.
+  *
+  * @output:
+  *    aadvance :: The glyph advance in metrics units.
+  *
+  * @return:
+  *    FreeType error code.  0~means success.
+  *
+  * @note:
+  *    You can use the `x_scale' or `y_scale' results of @FT_Get_PFR_Metrics
+  *    to convert the advance to device sub-pixels (i.e., 1/64th of pixels).
+  */
+  FT_EXPORT( FT_Error )
+  FT_Get_PFR_Advance( FT_Face   face,
+                      FT_UInt   gindex,
+                      FT_Pos   *aadvance );
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTPFR_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftrender.h b/include/freetype/ftrender.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftrender.h
@@ -0,0 +1,238 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftrender.h                                                             */
+/*                                                                         */
+/*    FreeType renderer modules public interface (specification).          */
+/*                                                                         */
+/*  Copyright 1996-2001, 2005, 2006, 2010 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTRENDER_H__
+#define __FTRENDER_H__
+
+
+#include <ft2build.h>
+#include FT_MODULE_H
+#include FT_GLYPH_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    module_management                                                  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* create a new glyph object */
+  typedef FT_Error
+  (*FT_Glyph_InitFunc)( FT_Glyph      glyph,
+                        FT_GlyphSlot  slot );
+
+  /* destroys a given glyph object */
+  typedef void
+  (*FT_Glyph_DoneFunc)( FT_Glyph  glyph );
+
+  typedef void
+  (*FT_Glyph_TransformFunc)( FT_Glyph          glyph,
+                             const FT_Matrix*  matrix,
+                             const FT_Vector*  delta );
+
+  typedef void
+  (*FT_Glyph_GetBBoxFunc)( FT_Glyph  glyph,
+                           FT_BBox*  abbox );
+
+  typedef FT_Error
+  (*FT_Glyph_CopyFunc)( FT_Glyph   source,
+                        FT_Glyph   target );
+
+  typedef FT_Error
+  (*FT_Glyph_PrepareFunc)( FT_Glyph      glyph,
+                           FT_GlyphSlot  slot );
+
+/* deprecated */
+#define FT_Glyph_Init_Func       FT_Glyph_InitFunc
+#define FT_Glyph_Done_Func       FT_Glyph_DoneFunc
+#define FT_Glyph_Transform_Func  FT_Glyph_TransformFunc
+#define FT_Glyph_BBox_Func       FT_Glyph_GetBBoxFunc
+#define FT_Glyph_Copy_Func       FT_Glyph_CopyFunc
+#define FT_Glyph_Prepare_Func    FT_Glyph_PrepareFunc
+
+
+  struct  FT_Glyph_Class_
+  {
+    FT_Long                 glyph_size;
+    FT_Glyph_Format         glyph_format;
+    FT_Glyph_InitFunc       glyph_init;
+    FT_Glyph_DoneFunc       glyph_done;
+    FT_Glyph_CopyFunc       glyph_copy;
+    FT_Glyph_TransformFunc  glyph_transform;
+    FT_Glyph_GetBBoxFunc    glyph_bbox;
+    FT_Glyph_PrepareFunc    glyph_prepare;
+  };
+
+
+  typedef FT_Error
+  (*FT_Renderer_RenderFunc)( FT_Renderer       renderer,
+                             FT_GlyphSlot      slot,
+                             FT_UInt           mode,
+                             const FT_Vector*  origin );
+
+  typedef FT_Error
+  (*FT_Renderer_TransformFunc)( FT_Renderer       renderer,
+                                FT_GlyphSlot      slot,
+                                const FT_Matrix*  matrix,
+                                const FT_Vector*  delta );
+
+
+  typedef void
+  (*FT_Renderer_GetCBoxFunc)( FT_Renderer   renderer,
+                              FT_GlyphSlot  slot,
+                              FT_BBox*      cbox );
+
+
+  typedef FT_Error
+  (*FT_Renderer_SetModeFunc)( FT_Renderer  renderer,
+                              FT_ULong     mode_tag,
+                              FT_Pointer   mode_ptr );
+
+/* deprecated identifiers */
+#define FTRenderer_render  FT_Renderer_RenderFunc
+#define FTRenderer_transform  FT_Renderer_TransformFunc
+#define FTRenderer_getCBox  FT_Renderer_GetCBoxFunc
+#define FTRenderer_setMode  FT_Renderer_SetModeFunc
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Renderer_Class                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The renderer module class descriptor.                              */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    root            :: The root @FT_Module_Class fields.               */
+  /*                                                                       */
+  /*    glyph_format    :: The glyph image format this renderer handles.   */
+  /*                                                                       */
+  /*    render_glyph    :: A method used to render the image that is in a  */
+  /*                       given glyph slot into a bitmap.                 */
+  /*                                                                       */
+  /*    transform_glyph :: A method used to transform the image that is in */
+  /*                       a given glyph slot.                             */
+  /*                                                                       */
+  /*    get_glyph_cbox  :: A method used to access the glyph's cbox.       */
+  /*                                                                       */
+  /*    set_mode        :: A method used to pass additional parameters.    */
+  /*                                                                       */
+  /*    raster_class    :: For @FT_GLYPH_FORMAT_OUTLINE renderers only.    */
+  /*                       This is a pointer to its raster's class.        */
+  /*                                                                       */
+  typedef struct  FT_Renderer_Class_
+  {
+    FT_Module_Class            root;
+
+    FT_Glyph_Format            glyph_format;
+
+    FT_Renderer_RenderFunc     render_glyph;
+    FT_Renderer_TransformFunc  transform_glyph;
+    FT_Renderer_GetCBoxFunc    get_glyph_cbox;
+    FT_Renderer_SetModeFunc    set_mode;
+
+    FT_Raster_Funcs*           raster_class;
+
+  } FT_Renderer_Class;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Renderer                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the current renderer for a given glyph format.            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library :: A handle to the library object.                         */
+  /*                                                                       */
+  /*    format  :: The glyph format.                                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A renderer handle.  0~if none found.                               */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    An error will be returned if a module already exists by that name, */
+  /*    or if the module requires a version of FreeType that is too great. */
+  /*                                                                       */
+  /*    To add a new renderer, simply use @FT_Add_Module.  To retrieve a   */
+  /*    renderer by its name, use @FT_Get_Module.                          */
+  /*                                                                       */
+  FT_EXPORT( FT_Renderer )
+  FT_Get_Renderer( FT_Library       library,
+                   FT_Glyph_Format  format );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Set_Renderer                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Set the current renderer to use, and set additional mode.          */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    library    :: A handle to the library object.                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    renderer   :: A handle to the renderer object.                     */
+  /*                                                                       */
+  /*    num_params :: The number of additional parameters.                 */
+  /*                                                                       */
+  /*    parameters :: Additional parameters.                               */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    In case of success, the renderer will be used to convert glyph     */
+  /*    images in the renderer's known format into bitmaps.                */
+  /*                                                                       */
+  /*    This doesn't change the current renderer for other formats.        */
+  /*                                                                       */
+  /*    Currently, only the B/W renderer, if compiled with                 */
+  /*    FT_RASTER_OPTION_ANTI_ALIASING (providing a 5-levels               */
+  /*    anti-aliasing mode; this option must be set directly in            */
+  /*    `ftraster.c' and is undefined by default) accepts a single tag     */
+  /*    `pal5' to set its gray palette as a character string with          */
+  /*    5~elements.  Consequently, the third and fourth argument are zero  */
+  /*    normally.                                                          */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Set_Renderer( FT_Library     library,
+                   FT_Renderer    renderer,
+                   FT_UInt        num_params,
+                   FT_Parameter*  parameters );
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTRENDER_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftsizes.h b/include/freetype/ftsizes.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftsizes.h
@@ -0,0 +1,159 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftsizes.h                                                              */
+/*                                                                         */
+/*    FreeType size objects management (specification).                    */
+/*                                                                         */
+/*  Copyright 1996-2001, 2003, 2004, 2006, 2009 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Typical application would normally not need to use these functions.   */
+  /* However, they have been placed in a public API for the rare cases     */
+  /* where they are needed.                                                */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTSIZES_H__
+#define __FTSIZES_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    sizes_management                                                   */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Size Management                                                    */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Managing multiple sizes per face.                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    When creating a new face object (e.g., with @FT_New_Face), an      */
+  /*    @FT_Size object is automatically created and used to store all     */
+  /*    pixel-size dependent information, available in the `face->size'    */
+  /*    field.                                                             */
+  /*                                                                       */
+  /*    It is however possible to create more sizes for a given face,      */
+  /*    mostly in order to manage several character pixel sizes of the     */
+  /*    same font family and style.  See @FT_New_Size and @FT_Done_Size.   */
+  /*                                                                       */
+  /*    Note that @FT_Set_Pixel_Sizes and @FT_Set_Char_Size only           */
+  /*    modify the contents of the current `active' size; you thus need    */
+  /*    to use @FT_Activate_Size to change it.                             */
+  /*                                                                       */
+  /*    99% of applications won't need the functions provided here,        */
+  /*    especially if they use the caching sub-system, so be cautious      */
+  /*    when using these.                                                  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Size                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Create a new size object from a given face object.                 */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to a parent face object.                          */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    asize :: A handle to a new size object.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You need to call @FT_Activate_Size in order to select the new size */
+  /*    for upcoming calls to @FT_Set_Pixel_Sizes, @FT_Set_Char_Size,      */
+  /*    @FT_Load_Glyph, @FT_Load_Char, etc.                                */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_New_Size( FT_Face   face,
+               FT_Size*  size );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_Size                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Discard a given size object.  Note that @FT_Done_Face              */
+  /*    automatically discards all size objects allocated with             */
+  /*    @FT_New_Size.                                                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    size :: A handle to a target size object.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Done_Size( FT_Size  size );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Activate_Size                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Even though it is possible to create several size objects for a    */
+  /*    given face (see @FT_New_Size for details), functions like          */
+  /*    @FT_Load_Glyph or @FT_Load_Char only use the one which has been    */
+  /*    activated last to determine the `current character pixel size'.    */
+  /*                                                                       */
+  /*    This function can be used to `activate' a previously created size  */
+  /*    object.                                                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    size :: A handle to a target size object.                          */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    If `face' is the size's parent face object, this function changes  */
+  /*    the value of `face->size' to the input size handle.                */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Activate_Size( FT_Size  size );
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTSIZES_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftsnames.h b/include/freetype/ftsnames.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftsnames.h
@@ -0,0 +1,200 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftsnames.h                                                             */
+/*                                                                         */
+/*    Simple interface to access SFNT name tables (which are used          */
+/*    to hold font names, copyright info, notices, etc.) (specification).  */
+/*                                                                         */
+/*    This is _not_ used to retrieve glyph names!                          */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2003, 2006, 2009, 2010 by                   */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FT_SFNT_NAMES_H__
+#define __FT_SFNT_NAMES_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    sfnt_names                                                         */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    SFNT Names                                                         */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Access the names embedded in TrueType and OpenType files.          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The TrueType and OpenType specifications allow the inclusion of    */
+  /*    a special `names table' in font files.  This table contains        */
+  /*    textual (and internationalized) information regarding the font,    */
+  /*    like family name, copyright, version, etc.                         */
+  /*                                                                       */
+  /*    The definitions below are used to access them if available.        */
+  /*                                                                       */
+  /*    Note that this has nothing to do with glyph names!                 */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_SfntName                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model an SFNT `name' table entry.              */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    platform_id :: The platform ID for `string'.                       */
+  /*                                                                       */
+  /*    encoding_id :: The encoding ID for `string'.                       */
+  /*                                                                       */
+  /*    language_id :: The language ID for `string'.                       */
+  /*                                                                       */
+  /*    name_id     :: An identifier for `string'.                         */
+  /*                                                                       */
+  /*    string      :: The `name' string.  Note that its format differs    */
+  /*                   depending on the (platform,encoding) pair.  It can  */
+  /*                   be a Pascal String, a UTF-16 one, etc.              */
+  /*                                                                       */
+  /*                   Generally speaking, the string is not               */
+  /*                   zero-terminated.  Please refer to the TrueType      */
+  /*                   specification for details.                          */
+  /*                                                                       */
+  /*    string_len  :: The length of `string' in bytes.                    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Possible values for `platform_id', `encoding_id', `language_id',   */
+  /*    and `name_id' are given in the file `ttnameid.h'.  For details     */
+  /*    please refer to the TrueType or OpenType specification.            */
+  /*                                                                       */
+  /*    See also @TT_PLATFORM_XXX, @TT_APPLE_ID_XXX, @TT_MAC_ID_XXX,       */
+  /*    @TT_ISO_ID_XXX, and @TT_MS_ID_XXX.                                 */
+  /*                                                                       */
+  typedef struct  FT_SfntName_
+  {
+    FT_UShort  platform_id;
+    FT_UShort  encoding_id;
+    FT_UShort  language_id;
+    FT_UShort  name_id;
+
+    FT_Byte*   string;      /* this string is *not* null-terminated! */
+    FT_UInt    string_len;  /* in bytes */
+
+  } FT_SfntName;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Sfnt_Name_Count                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the number of name strings in the SFNT `name' table.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the source face.                               */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The number of strings in the `name' table.                         */
+  /*                                                                       */
+  FT_EXPORT( FT_UInt )
+  FT_Get_Sfnt_Name_Count( FT_Face  face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Sfnt_Name                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve a string of the SFNT `name' table for a given index.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face  :: A handle to the source face.                              */
+  /*                                                                       */
+  /*    idx   :: The index of the `name' string.                           */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aname :: The indexed @FT_SfntName structure.                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0~means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The `string' array returned in the `aname' structure is not        */
+  /*    null-terminated.  The application should deallocate it if it is no */
+  /*    longer in use.                                                     */
+  /*                                                                       */
+  /*    Use @FT_Get_Sfnt_Name_Count to get the total number of available   */
+  /*    `name' table entries, then do a loop until you get the right       */
+  /*    platform, encoding, and name ID.                                   */
+  /*                                                                       */
+  FT_EXPORT( FT_Error )
+  FT_Get_Sfnt_Name( FT_Face       face,
+                    FT_UInt       idx,
+                    FT_SfntName  *aname );
+
+
+  /***************************************************************************
+   *
+   * @constant:
+   *   FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY
+   *
+   * @description:
+   *   A constant used as the tag of @FT_Parameter structures to make
+   *   FT_Open_Face() ignore preferred family subfamily names in `name'
+   *   table since OpenType version 1.4.  For backwards compatibility with
+   *   legacy systems which has 4-face-per-family restriction.
+   *
+   */
+#define FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY  FT_MAKE_TAG( 'i', 'g', 'p', 'f' )
+
+
+  /***************************************************************************
+   *
+   * @constant:
+   *   FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY
+   *
+   * @description:
+   *   A constant used as the tag of @FT_Parameter structures to make
+   *   FT_Open_Face() ignore preferred subfamily names in `name' table since
+   *   OpenType version 1.4.  For backwards compatibility with legacy
+   *   systems which has 4-face-per-family restriction.
+   *
+   */
+#define FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY  FT_MAKE_TAG( 'i', 'g', 'p', 's' )
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FT_SFNT_NAMES_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftstroke.h b/include/freetype/ftstroke.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftstroke.h
@@ -0,0 +1,751 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftstroke.h                                                             */
+/*                                                                         */
+/*    FreeType path stroker (specification).                               */
+/*                                                                         */
+/*  Copyright 2002-2006, 2008, 2009, 2011-2012 by                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FT_STROKE_H__
+#define __FT_STROKE_H__
+
+#include <ft2build.h>
+#include FT_OUTLINE_H
+#include FT_GLYPH_H
+
+
+FT_BEGIN_HEADER
+
+
+ /************************************************************************
+  *
+  * @section:
+  *    glyph_stroker
+  *
+  * @title:
+  *    Glyph Stroker
+  *
+  * @abstract:
+  *    Generating bordered and stroked glyphs.
+  *
+  * @description:
+  *    This component generates stroked outlines of a given vectorial
+  *    glyph.  It also allows you to retrieve the `outside' and/or the
+  *    `inside' borders of the stroke.
+  *
+  *    This can be useful to generate `bordered' glyph, i.e., glyphs
+  *    displayed with a coloured (and anti-aliased) border around their
+  *    shape.
+  */
+
+
+ /**************************************************************
+  *
+  * @type:
+  *   FT_Stroker
+  *
+  * @description:
+  *   Opaque handler to a path stroker object.
+  */
+  typedef struct FT_StrokerRec_*  FT_Stroker;
+
+
+  /**************************************************************
+   *
+   * @enum:
+   *   FT_Stroker_LineJoin
+   *
+   * @description:
+   *   These values determine how two joining lines are rendered
+   *   in a stroker.
+   *
+   * @values:
+   *   FT_STROKER_LINEJOIN_ROUND ::
+   *     Used to render rounded line joins.  Circular arcs are used
+   *     to join two lines smoothly.
+   *
+   *   FT_STROKER_LINEJOIN_BEVEL ::
+   *     Used to render beveled line joins.  The outer corner of
+   *     the joined lines is filled by enclosing the triangular
+   *     region of the corner with a straight line between the
+   *     outer corners of each stroke.
+   *
+   *   FT_STROKER_LINEJOIN_MITER_FIXED ::
+   *     Used to render mitered line joins, with fixed bevels if the
+   *     miter limit is exceeded.  The outer edges of the strokes
+   *     for the two segments are extended until they meet at an
+   *     angle.  If the segments meet at too sharp an angle (such
+   *     that the miter would extend from the intersection of the
+   *     segments a distance greater than the product of the miter
+   *     limit value and the border radius), then a bevel join (see
+   *     above) is used instead.  This prevents long spikes being
+   *     created.  FT_STROKER_LINEJOIN_MITER_FIXED generates a miter
+   *     line join as used in PostScript and PDF.
+   *
+   *   FT_STROKER_LINEJOIN_MITER_VARIABLE ::
+   *   FT_STROKER_LINEJOIN_MITER ::
+   *     Used to render mitered line joins, with variable bevels if
+   *     the miter limit is exceeded.  The intersection of the
+   *     strokes is clipped at a line perpendicular to the bisector
+   *     of the angle between the strokes, at the distance from the
+   *     intersection of the segments equal to the product of the
+   *     miter limit value and the border radius.  This prevents
+   *     long spikes being created.
+   *     FT_STROKER_LINEJOIN_MITER_VARIABLE generates a mitered line
+   *     join as used in XPS.  FT_STROKER_LINEJOIN_MITER is an alias
+   *     for FT_STROKER_LINEJOIN_MITER_VARIABLE, retained for
+   *     backwards compatibility.
+   */
+  typedef enum  FT_Stroker_LineJoin_
+  {
+    FT_STROKER_LINEJOIN_ROUND          = 0,
+    FT_STROKER_LINEJOIN_BEVEL          = 1,
+    FT_STROKER_LINEJOIN_MITER_VARIABLE = 2,
+    FT_STROKER_LINEJOIN_MITER          = FT_STROKER_LINEJOIN_MITER_VARIABLE,
+    FT_STROKER_LINEJOIN_MITER_FIXED    = 3
+
+  } FT_Stroker_LineJoin;
+
+
+  /**************************************************************
+   *
+   * @enum:
+   *   FT_Stroker_LineCap
+   *
+   * @description:
+   *   These values determine how the end of opened sub-paths are
+   *   rendered in a stroke.
+   *
+   * @values:
+   *   FT_STROKER_LINECAP_BUTT ::
+   *     The end of lines is rendered as a full stop on the last
+   *     point itself.
+   *
+   *   FT_STROKER_LINECAP_ROUND ::
+   *     The end of lines is rendered as a half-circle around the
+   *     last point.
+   *
+   *   FT_STROKER_LINECAP_SQUARE ::
+   *     The end of lines is rendered as a square around the
+   *     last point.
+   */
+  typedef enum  FT_Stroker_LineCap_
+  {
+    FT_STROKER_LINECAP_BUTT = 0,
+    FT_STROKER_LINECAP_ROUND,
+    FT_STROKER_LINECAP_SQUARE
+
+  } FT_Stroker_LineCap;
+
+
+  /**************************************************************
+   *
+   * @enum:
+   *   FT_StrokerBorder
+   *
+   * @description:
+   *   These values are used to select a given stroke border
+   *   in @FT_Stroker_GetBorderCounts and @FT_Stroker_ExportBorder.
+   *
+   * @values:
+   *   FT_STROKER_BORDER_LEFT ::
+   *     Select the left border, relative to the drawing direction.
+   *
+   *   FT_STROKER_BORDER_RIGHT ::
+   *     Select the right border, relative to the drawing direction.
+   *
+   * @note:
+   *   Applications are generally interested in the `inside' and `outside'
+   *   borders.  However, there is no direct mapping between these and the
+   *   `left' and `right' ones, since this really depends on the glyph's
+   *   drawing orientation, which varies between font formats.
+   *
+   *   You can however use @FT_Outline_GetInsideBorder and
+   *   @FT_Outline_GetOutsideBorder to get these.
+   */
+  typedef enum  FT_StrokerBorder_
+  {
+    FT_STROKER_BORDER_LEFT = 0,
+    FT_STROKER_BORDER_RIGHT
+
+  } FT_StrokerBorder;
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Outline_GetInsideBorder
+   *
+   * @description:
+   *   Retrieve the @FT_StrokerBorder value corresponding to the
+   *   `inside' borders of a given outline.
+   *
+   * @input:
+   *   outline ::
+   *     The source outline handle.
+   *
+   * @return:
+   *   The border index.  @FT_STROKER_BORDER_RIGHT for empty or invalid
+   *   outlines.
+   */
+  FT_EXPORT( FT_StrokerBorder )
+  FT_Outline_GetInsideBorder( FT_Outline*  outline );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Outline_GetOutsideBorder
+   *
+   * @description:
+   *   Retrieve the @FT_StrokerBorder value corresponding to the
+   *   `outside' borders of a given outline.
+   *
+   * @input:
+   *   outline ::
+   *     The source outline handle.
+   *
+   * @return:
+   *   The border index.  @FT_STROKER_BORDER_LEFT for empty or invalid
+   *   outlines.
+   */
+  FT_EXPORT( FT_StrokerBorder )
+  FT_Outline_GetOutsideBorder( FT_Outline*  outline );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_New
+   *
+   * @description:
+   *   Create a new stroker object.
+   *
+   * @input:
+   *   library ::
+   *     FreeType library handle.
+   *
+   * @output:
+   *   astroker ::
+   *     A new stroker object handle.  NULL in case of error.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_New( FT_Library   library,
+                  FT_Stroker  *astroker );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_Set
+   *
+   * @description:
+   *   Reset a stroker object's attributes.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   radius ::
+   *     The border radius.
+   *
+   *   line_cap ::
+   *     The line cap style.
+   *
+   *   line_join ::
+   *     The line join style.
+   *
+   *   miter_limit ::
+   *     The miter limit for the FT_STROKER_LINEJOIN_MITER_FIXED and
+   *     FT_STROKER_LINEJOIN_MITER_VARIABLE line join styles,
+   *     expressed as 16.16 fixed point value.
+   *
+   * @note:
+   *   The radius is expressed in the same units as the outline
+   *   coordinates.
+   */
+  FT_EXPORT( void )
+  FT_Stroker_Set( FT_Stroker           stroker,
+                  FT_Fixed             radius,
+                  FT_Stroker_LineCap   line_cap,
+                  FT_Stroker_LineJoin  line_join,
+                  FT_Fixed             miter_limit );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_Rewind
+   *
+   * @description:
+   *   Reset a stroker object without changing its attributes.
+   *   You should call this function before beginning a new
+   *   series of calls to @FT_Stroker_BeginSubPath or
+   *   @FT_Stroker_EndSubPath.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   */
+  FT_EXPORT( void )
+  FT_Stroker_Rewind( FT_Stroker  stroker );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_ParseOutline
+   *
+   * @description:
+   *   A convenience function used to parse a whole outline with
+   *   the stroker.  The resulting outline(s) can be retrieved
+   *   later by functions like @FT_Stroker_GetCounts and @FT_Stroker_Export.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   outline ::
+   *     The source outline.
+   *
+   *   opened ::
+   *     A boolean.  If~1, the outline is treated as an open path instead
+   *     of a closed one.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   If `opened' is~0 (the default), the outline is treated as a closed
+   *   path, and the stroker generates two distinct `border' outlines.
+   *
+   *   If `opened' is~1, the outline is processed as an open path, and the
+   *   stroker generates a single `stroke' outline.
+   *
+   *   This function calls @FT_Stroker_Rewind automatically.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_ParseOutline( FT_Stroker   stroker,
+                           FT_Outline*  outline,
+                           FT_Bool      opened );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_BeginSubPath
+   *
+   * @description:
+   *   Start a new sub-path in the stroker.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   to ::
+   *     A pointer to the start vector.
+   *
+   *   open ::
+   *     A boolean.  If~1, the sub-path is treated as an open one.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   This function is useful when you need to stroke a path that is
+   *   not stored as an @FT_Outline object.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_BeginSubPath( FT_Stroker  stroker,
+                           FT_Vector*  to,
+                           FT_Bool     open );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_EndSubPath
+   *
+   * @description:
+   *   Close the current sub-path in the stroker.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   You should call this function after @FT_Stroker_BeginSubPath.
+   *   If the subpath was not `opened', this function `draws' a
+   *   single line segment to the start position when needed.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_EndSubPath( FT_Stroker  stroker );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_LineTo
+   *
+   * @description:
+   *   `Draw' a single line segment in the stroker's current sub-path,
+   *   from the last position.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   to ::
+   *     A pointer to the destination point.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   You should call this function between @FT_Stroker_BeginSubPath and
+   *   @FT_Stroker_EndSubPath.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_LineTo( FT_Stroker  stroker,
+                     FT_Vector*  to );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_ConicTo
+   *
+   * @description:
+   *   `Draw' a single quadratic Bézier in the stroker's current sub-path,
+   *   from the last position.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   control ::
+   *     A pointer to a Bézier control point.
+   *
+   *   to ::
+   *     A pointer to the destination point.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   You should call this function between @FT_Stroker_BeginSubPath and
+   *   @FT_Stroker_EndSubPath.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_ConicTo( FT_Stroker  stroker,
+                      FT_Vector*  control,
+                      FT_Vector*  to );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_CubicTo
+   *
+   * @description:
+   *   `Draw' a single cubic Bézier in the stroker's current sub-path,
+   *   from the last position.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   control1 ::
+   *     A pointer to the first Bézier control point.
+   *
+   *   control2 ::
+   *     A pointer to second Bézier control point.
+   *
+   *   to ::
+   *     A pointer to the destination point.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   You should call this function between @FT_Stroker_BeginSubPath and
+   *   @FT_Stroker_EndSubPath.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_CubicTo( FT_Stroker  stroker,
+                      FT_Vector*  control1,
+                      FT_Vector*  control2,
+                      FT_Vector*  to );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_GetBorderCounts
+   *
+   * @description:
+   *   Call this function once you have finished parsing your paths
+   *   with the stroker.  It returns the number of points and
+   *   contours necessary to export one of the `border' or `stroke'
+   *   outlines generated by the stroker.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   border ::
+   *     The border index.
+   *
+   * @output:
+   *   anum_points ::
+   *     The number of points.
+   *
+   *   anum_contours ::
+   *     The number of contours.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   When an outline, or a sub-path, is `closed', the stroker generates
+   *   two independent `border' outlines, named `left' and `right'.
+   *
+   *   When the outline, or a sub-path, is `opened', the stroker merges
+   *   the `border' outlines with caps.  The `left' border receives all
+   *   points, while the `right' border becomes empty.
+   *
+   *   Use the function @FT_Stroker_GetCounts instead if you want to
+   *   retrieve the counts associated to both borders.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_GetBorderCounts( FT_Stroker        stroker,
+                              FT_StrokerBorder  border,
+                              FT_UInt          *anum_points,
+                              FT_UInt          *anum_contours );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_ExportBorder
+   *
+   * @description:
+   *   Call this function after @FT_Stroker_GetBorderCounts to
+   *   export the corresponding border to your own @FT_Outline
+   *   structure.
+   *
+   *   Note that this function appends the border points and
+   *   contours to your outline, but does not try to resize its
+   *   arrays.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   border ::
+   *     The border index.
+   *
+   *   outline ::
+   *     The target outline handle.
+   *
+   * @note:
+   *   Always call this function after @FT_Stroker_GetBorderCounts to
+   *   get sure that there is enough room in your @FT_Outline object to
+   *   receive all new data.
+   *
+   *   When an outline, or a sub-path, is `closed', the stroker generates
+   *   two independent `border' outlines, named `left' and `right'
+   *
+   *   When the outline, or a sub-path, is `opened', the stroker merges
+   *   the `border' outlines with caps. The `left' border receives all
+   *   points, while the `right' border becomes empty.
+   *
+   *   Use the function @FT_Stroker_Export instead if you want to
+   *   retrieve all borders at once.
+   */
+  FT_EXPORT( void )
+  FT_Stroker_ExportBorder( FT_Stroker        stroker,
+                           FT_StrokerBorder  border,
+                           FT_Outline*       outline );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_GetCounts
+   *
+   * @description:
+   *   Call this function once you have finished parsing your paths
+   *   with the stroker.  It returns the number of points and
+   *   contours necessary to export all points/borders from the stroked
+   *   outline/path.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   * @output:
+   *   anum_points ::
+   *     The number of points.
+   *
+   *   anum_contours ::
+   *     The number of contours.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Stroker_GetCounts( FT_Stroker  stroker,
+                        FT_UInt    *anum_points,
+                        FT_UInt    *anum_contours );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_Export
+   *
+   * @description:
+   *   Call this function after @FT_Stroker_GetBorderCounts to
+   *   export all borders to your own @FT_Outline structure.
+   *
+   *   Note that this function appends the border points and
+   *   contours to your outline, but does not try to resize its
+   *   arrays.
+   *
+   * @input:
+   *   stroker ::
+   *     The target stroker handle.
+   *
+   *   outline ::
+   *     The target outline handle.
+   */
+  FT_EXPORT( void )
+  FT_Stroker_Export( FT_Stroker   stroker,
+                     FT_Outline*  outline );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Stroker_Done
+   *
+   * @description:
+   *   Destroy a stroker object.
+   *
+   * @input:
+   *   stroker ::
+   *     A stroker handle.  Can be NULL.
+   */
+  FT_EXPORT( void )
+  FT_Stroker_Done( FT_Stroker  stroker );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Glyph_Stroke
+   *
+   * @description:
+   *   Stroke a given outline glyph object with a given stroker.
+   *
+   * @inout:
+   *   pglyph ::
+   *     Source glyph handle on input, new glyph handle on output.
+   *
+   * @input:
+   *   stroker ::
+   *     A stroker handle.
+   *
+   *   destroy ::
+   *     A Boolean.  If~1, the source glyph object is destroyed
+   *     on success.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *   The source glyph is untouched in case of error.
+   *
+   *   Adding stroke may yield a significantly wider and taller glyph
+   *   depending on how large of a radius was used to stroke the glyph.  You
+   *   may need to manually adjust horizontal and vertical advance amounts
+   *   to account for this added size.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Glyph_Stroke( FT_Glyph    *pglyph,
+                   FT_Stroker   stroker,
+                   FT_Bool      destroy );
+
+
+  /**************************************************************
+   *
+   * @function:
+   *   FT_Glyph_StrokeBorder
+   *
+   * @description:
+   *   Stroke a given outline glyph object with a given stroker, but
+   *   only return either its inside or outside border.
+   *
+   * @inout:
+   *   pglyph ::
+   *     Source glyph handle on input, new glyph handle on output.
+   *
+   * @input:
+   *   stroker ::
+   *     A stroker handle.
+   *
+   *   inside ::
+   *     A Boolean.  If~1, return the inside border, otherwise
+   *     the outside border.
+   *
+   *   destroy ::
+   *     A Boolean.  If~1, the source glyph object is destroyed
+   *     on success.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *   The source glyph is untouched in case of error.
+   *
+   *   Adding stroke may yield a significantly wider and taller glyph
+   *   depending on how large of a radius was used to stroke the glyph.  You
+   *   may need to manually adjust horizontal and vertical advance amounts
+   *   to account for this added size.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Glyph_StrokeBorder( FT_Glyph    *pglyph,
+                         FT_Stroker   stroker,
+                         FT_Bool      inside,
+                         FT_Bool      destroy );
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FT_STROKE_H__ */
+
+
+/* END */
+
+
+/* Local Variables: */
+/* coding: utf-8    */
+/* End:             */
diff --git a/include/freetype/ftsynth.h b/include/freetype/ftsynth.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftsynth.h
@@ -0,0 +1,81 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftsynth.h                                                              */
+/*                                                                         */
+/*    FreeType synthesizing code for emboldening and slanting              */
+/*    (specification).                                                     */
+/*                                                                         */
+/*  Copyright 2000-2001, 2003, 2006, 2008, 2012 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*********                                                       *********/
+  /*********        WARNING, THIS IS ALPHA CODE!  THIS API         *********/
+  /*********    IS DUE TO CHANGE UNTIL STRICTLY NOTIFIED BY THE    *********/
+  /*********            FREETYPE DEVELOPMENT TEAM                  *********/
+  /*********                                                       *********/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* Main reason for not lifting the functions in this module to a  */
+  /* `standard' API is that the used parameters for emboldening and */
+  /* slanting are not configurable.  Consider the functions as a    */
+  /* code resource which should be copied into the application and  */
+  /* adapted to the particular needs.                               */
+
+
+#ifndef __FTSYNTH_H__
+#define __FTSYNTH_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /* Embolden a glyph by a `reasonable' value (which is highly a matter of */
+  /* taste).  This function is actually a convenience function, providing  */
+  /* a wrapper for @FT_Outline_Embolden and @FT_Bitmap_Embolden.           */
+  /*                                                                       */
+  /* For emboldened outlines the height, width, and advance metrics are    */
+  /* increased by the strength of the emboldening.  You can also call      */
+  /* @FT_Outline_Get_CBox to get precise values.                           */
+  FT_EXPORT( void )
+  FT_GlyphSlot_Embolden( FT_GlyphSlot  slot );
+
+  /* Slant an outline glyph to the right by about 12 degrees. */
+  FT_EXPORT( void )
+  FT_GlyphSlot_Oblique( FT_GlyphSlot  slot );
+
+  /* */
+
+FT_END_HEADER
+
+#endif /* __FTSYNTH_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftsystem.h b/include/freetype/ftsystem.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftsystem.h
@@ -0,0 +1,347 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftsystem.h                                                             */
+/*                                                                         */
+/*    FreeType low-level system interface definition (specification).      */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2005, 2010 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTSYSTEM_H__
+#define __FTSYSTEM_H__
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*   system_interface                                                    */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*   System Interface                                                    */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*   How FreeType manages memory and i/o.                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*   This section contains various definitions related to memory         */
+  /*   management and i/o access.  You need to understand this             */
+  /*   information if you want to use a custom memory manager or you own   */
+  /*   i/o streams.                                                        */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                  M E M O R Y   M A N A G E M E N T                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @type:
+   *   FT_Memory
+   *
+   * @description:
+   *   A handle to a given memory manager object, defined with an
+   *   @FT_MemoryRec structure.
+   *
+   */
+  typedef struct FT_MemoryRec_*  FT_Memory;
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   FT_Alloc_Func
+   *
+   * @description:
+   *   A function used to allocate `size' bytes from `memory'.
+   *
+   * @input:
+   *   memory ::
+   *     A handle to the source memory manager.
+   *
+   *   size ::
+   *     The size in bytes to allocate.
+   *
+   * @return:
+   *   Address of new memory block.  0~in case of failure.
+   *
+   */
+  typedef void*
+  (*FT_Alloc_Func)( FT_Memory  memory,
+                    long       size );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   FT_Free_Func
+   *
+   * @description:
+   *   A function used to release a given block of memory.
+   *
+   * @input:
+   *   memory ::
+   *     A handle to the source memory manager.
+   *
+   *   block ::
+   *     The address of the target memory block.
+   *
+   */
+  typedef void
+  (*FT_Free_Func)( FT_Memory  memory,
+                   void*      block );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   FT_Realloc_Func
+   *
+   * @description:
+   *   A function used to re-allocate a given block of memory.
+   *
+   * @input:
+   *   memory ::
+   *     A handle to the source memory manager.
+   *
+   *   cur_size ::
+   *     The block's current size in bytes.
+   *
+   *   new_size ::
+   *     The block's requested new size.
+   *
+   *   block ::
+   *     The block's current address.
+   *
+   * @return:
+   *   New block address.  0~in case of memory shortage.
+   *
+   * @note:
+   *   In case of error, the old block must still be available.
+   *
+   */
+  typedef void*
+  (*FT_Realloc_Func)( FT_Memory  memory,
+                      long       cur_size,
+                      long       new_size,
+                      void*      block );
+
+
+  /*************************************************************************
+   *
+   * @struct:
+   *   FT_MemoryRec
+   *
+   * @description:
+   *   A structure used to describe a given memory manager to FreeType~2.
+   *
+   * @fields:
+   *   user ::
+   *     A generic typeless pointer for user data.
+   *
+   *   alloc ::
+   *     A pointer type to an allocation function.
+   *
+   *   free ::
+   *     A pointer type to an memory freeing function.
+   *
+   *   realloc ::
+   *     A pointer type to a reallocation function.
+   *
+   */
+  struct  FT_MemoryRec_
+  {
+    void*            user;
+    FT_Alloc_Func    alloc;
+    FT_Free_Func     free;
+    FT_Realloc_Func  realloc;
+  };
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                       I / O   M A N A G E M E N T                     */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @type:
+   *   FT_Stream
+   *
+   * @description:
+   *   A handle to an input stream.
+   *
+   */
+  typedef struct FT_StreamRec_*  FT_Stream;
+
+
+  /*************************************************************************
+   *
+   * @struct:
+   *   FT_StreamDesc
+   *
+   * @description:
+   *   A union type used to store either a long or a pointer.  This is used
+   *   to store a file descriptor or a `FILE*' in an input stream.
+   *
+   */
+  typedef union  FT_StreamDesc_
+  {
+    long   value;
+    void*  pointer;
+
+  } FT_StreamDesc;
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   FT_Stream_IoFunc
+   *
+   * @description:
+   *   A function used to seek and read data from a given input stream.
+   *
+   * @input:
+   *   stream ::
+   *     A handle to the source stream.
+   *
+   *   offset ::
+   *     The offset of read in stream (always from start).
+   *
+   *   buffer ::
+   *     The address of the read buffer.
+   *
+   *   count ::
+   *     The number of bytes to read from the stream.
+   *
+   * @return:
+   *   The number of bytes effectively read by the stream.
+   *
+   * @note:
+   *   This function might be called to perform a seek or skip operation
+   *   with a `count' of~0.  A non-zero return value then indicates an
+   *   error.
+   *
+   */
+  typedef unsigned long
+  (*FT_Stream_IoFunc)( FT_Stream       stream,
+                       unsigned long   offset,
+                       unsigned char*  buffer,
+                       unsigned long   count );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   FT_Stream_CloseFunc
+   *
+   * @description:
+   *   A function used to close a given input stream.
+   *
+   * @input:
+   *  stream ::
+   *     A handle to the target stream.
+   *
+   */
+  typedef void
+  (*FT_Stream_CloseFunc)( FT_Stream  stream );
+
+
+  /*************************************************************************
+   *
+   * @struct:
+   *   FT_StreamRec
+   *
+   * @description:
+   *   A structure used to describe an input stream.
+   *
+   * @input:
+   *   base ::
+   *     For memory-based streams, this is the address of the first stream
+   *     byte in memory.  This field should always be set to NULL for
+   *     disk-based streams.
+   *
+   *   size ::
+   *     The stream size in bytes.
+   *
+   *   pos ::
+   *     The current position within the stream.
+   *
+   *   descriptor ::
+   *     This field is a union that can hold an integer or a pointer.  It is
+   *     used by stream implementations to store file descriptors or `FILE*'
+   *     pointers.
+   *
+   *   pathname ::
+   *     This field is completely ignored by FreeType.  However, it is often
+   *     useful during debugging to use it to store the stream's filename
+   *     (where available).
+   *
+   *   read ::
+   *     The stream's input function.
+   *
+   *   close ::
+   *     The stream's close function.
+   *
+   *   memory ::
+   *     The memory manager to use to preload frames.  This is set
+   *     internally by FreeType and shouldn't be touched by stream
+   *     implementations.
+   *
+   *   cursor ::
+   *     This field is set and used internally by FreeType when parsing
+   *     frames.
+   *
+   *   limit ::
+   *     This field is set and used internally by FreeType when parsing
+   *     frames.
+   *
+   */
+  typedef struct  FT_StreamRec_
+  {
+    unsigned char*       base;
+    unsigned long        size;
+    unsigned long        pos;
+
+    FT_StreamDesc        descriptor;
+    FT_StreamDesc        pathname;
+    FT_Stream_IoFunc     read;
+    FT_Stream_CloseFunc  close;
+
+    FT_Memory            memory;
+    unsigned char*       cursor;
+    unsigned char*       limit;
+
+  } FT_StreamRec;
+
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTSYSTEM_H__ */
+
+
+/* END */
diff --git a/include/freetype/fttrigon.h b/include/freetype/fttrigon.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/fttrigon.h
@@ -0,0 +1,350 @@
+/***************************************************************************/
+/*                                                                         */
+/*  fttrigon.h                                                             */
+/*                                                                         */
+/*    FreeType trigonometric functions (specification).                    */
+/*                                                                         */
+/*  Copyright 2001, 2003, 2005, 2007 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTTRIGON_H__
+#define __FTTRIGON_H__
+
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*   computations                                                        */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @type:
+   *   FT_Angle
+   *
+   * @description:
+   *   This type is used to model angle values in FreeType.  Note that the
+   *   angle is a 16.16 fixed float value expressed in degrees.
+   *
+   */
+  typedef FT_Fixed  FT_Angle;
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_ANGLE_PI
+   *
+   * @description:
+   *   The angle pi expressed in @FT_Angle units.
+   *
+   */
+#define FT_ANGLE_PI  ( 180L << 16 )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_ANGLE_2PI
+   *
+   * @description:
+   *   The angle 2*pi expressed in @FT_Angle units.
+   *
+   */
+#define FT_ANGLE_2PI  ( FT_ANGLE_PI * 2 )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_ANGLE_PI2
+   *
+   * @description:
+   *   The angle pi/2 expressed in @FT_Angle units.
+   *
+   */
+#define FT_ANGLE_PI2  ( FT_ANGLE_PI / 2 )
+
+
+  /*************************************************************************
+   *
+   * @macro:
+   *   FT_ANGLE_PI4
+   *
+   * @description:
+   *   The angle pi/4 expressed in @FT_Angle units.
+   *
+   */
+#define FT_ANGLE_PI4  ( FT_ANGLE_PI / 4 )
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Sin
+   *
+   * @description:
+   *   Return the sinus of a given angle in fixed point format.
+   *
+   * @input:
+   *   angle ::
+   *     The input angle.
+   *
+   * @return:
+   *   The sinus value.
+   *
+   * @note:
+   *   If you need both the sinus and cosinus for a given angle, use the
+   *   function @FT_Vector_Unit.
+   *
+   */
+  FT_EXPORT( FT_Fixed )
+  FT_Sin( FT_Angle  angle );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Cos
+   *
+   * @description:
+   *   Return the cosinus of a given angle in fixed point format.
+   *
+   * @input:
+   *   angle ::
+   *     The input angle.
+   *
+   * @return:
+   *   The cosinus value.
+   *
+   * @note:
+   *   If you need both the sinus and cosinus for a given angle, use the
+   *   function @FT_Vector_Unit.
+   *
+   */
+  FT_EXPORT( FT_Fixed )
+  FT_Cos( FT_Angle  angle );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Tan
+   *
+   * @description:
+   *   Return the tangent of a given angle in fixed point format.
+   *
+   * @input:
+   *   angle ::
+   *     The input angle.
+   *
+   * @return:
+   *   The tangent value.
+   *
+   */
+  FT_EXPORT( FT_Fixed )
+  FT_Tan( FT_Angle  angle );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Atan2
+   *
+   * @description:
+   *   Return the arc-tangent corresponding to a given vector (x,y) in
+   *   the 2d plane.
+   *
+   * @input:
+   *   x ::
+   *     The horizontal vector coordinate.
+   *
+   *   y ::
+   *     The vertical vector coordinate.
+   *
+   * @return:
+   *   The arc-tangent value (i.e. angle).
+   *
+   */
+  FT_EXPORT( FT_Angle )
+  FT_Atan2( FT_Fixed  x,
+            FT_Fixed  y );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Angle_Diff
+   *
+   * @description:
+   *   Return the difference between two angles.  The result is always
+   *   constrained to the ]-PI..PI] interval.
+   *
+   * @input:
+   *   angle1 ::
+   *     First angle.
+   *
+   *   angle2 ::
+   *     Second angle.
+   *
+   * @return:
+   *   Constrained value of `value2-value1'.
+   *
+   */
+  FT_EXPORT( FT_Angle )
+  FT_Angle_Diff( FT_Angle  angle1,
+                 FT_Angle  angle2 );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Vector_Unit
+   *
+   * @description:
+   *   Return the unit vector corresponding to a given angle.  After the
+   *   call, the value of `vec.x' will be `sin(angle)', and the value of
+   *   `vec.y' will be `cos(angle)'.
+   *
+   *   This function is useful to retrieve both the sinus and cosinus of a
+   *   given angle quickly.
+   *
+   * @output:
+   *   vec ::
+   *     The address of target vector.
+   *
+   * @input:
+   *   angle ::
+   *     The address of angle.
+   *
+   */
+  FT_EXPORT( void )
+  FT_Vector_Unit( FT_Vector*  vec,
+                  FT_Angle    angle );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Vector_Rotate
+   *
+   * @description:
+   *   Rotate a vector by a given angle.
+   *
+   * @inout:
+   *   vec ::
+   *     The address of target vector.
+   *
+   * @input:
+   *   angle ::
+   *     The address of angle.
+   *
+   */
+  FT_EXPORT( void )
+  FT_Vector_Rotate( FT_Vector*  vec,
+                    FT_Angle    angle );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Vector_Length
+   *
+   * @description:
+   *   Return the length of a given vector.
+   *
+   * @input:
+   *   vec ::
+   *     The address of target vector.
+   *
+   * @return:
+   *   The vector length, expressed in the same units that the original
+   *   vector coordinates.
+   *
+   */
+  FT_EXPORT( FT_Fixed )
+  FT_Vector_Length( FT_Vector*  vec );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Vector_Polarize
+   *
+   * @description:
+   *   Compute both the length and angle of a given vector.
+   *
+   * @input:
+   *   vec ::
+   *     The address of source vector.
+   *
+   * @output:
+   *   length ::
+   *     The vector length.
+   *
+   *   angle ::
+   *     The vector angle.
+   *
+   */
+  FT_EXPORT( void )
+  FT_Vector_Polarize( FT_Vector*  vec,
+                      FT_Fixed   *length,
+                      FT_Angle   *angle );
+
+
+  /*************************************************************************
+   *
+   * @function:
+   *   FT_Vector_From_Polar
+   *
+   * @description:
+   *   Compute vector coordinates from a length and angle.
+   *
+   * @output:
+   *   vec ::
+   *     The address of source vector.
+   *
+   * @input:
+   *   length ::
+   *     The vector length.
+   *
+   *   angle ::
+   *     The vector angle.
+   *
+   */
+  FT_EXPORT( void )
+  FT_Vector_From_Polar( FT_Vector*  vec,
+                        FT_Fixed    length,
+                        FT_Angle    angle );
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTTRIGON_H__ */
+
+
+/* END */
diff --git a/include/freetype/fttypes.h b/include/freetype/fttypes.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/fttypes.h
@@ -0,0 +1,588 @@
+/***************************************************************************/
+/*                                                                         */
+/*  fttypes.h                                                              */
+/*                                                                         */
+/*    FreeType simple types definitions (specification only).              */
+/*                                                                         */
+/*  Copyright 1996-2002, 2004, 2006-2009, 2012 by                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTTYPES_H__
+#define __FTTYPES_H__
+
+
+#include <ft2build.h>
+#include FT_CONFIG_CONFIG_H
+#include FT_SYSTEM_H
+#include FT_IMAGE_H
+
+#include <stddef.h>
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    basic_types                                                        */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Basic Data Types                                                   */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    The basic data types defined by the library.                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the basic data types defined by FreeType~2,  */
+  /*    ranging from simple scalar types to bitmap descriptors.  More      */
+  /*    font-specific structures are defined in a different section.       */
+  /*                                                                       */
+  /* <Order>                                                               */
+  /*    FT_Byte                                                            */
+  /*    FT_Bytes                                                           */
+  /*    FT_Char                                                            */
+  /*    FT_Int                                                             */
+  /*    FT_UInt                                                            */
+  /*    FT_Int16                                                           */
+  /*    FT_UInt16                                                          */
+  /*    FT_Int32                                                           */
+  /*    FT_UInt32                                                          */
+  /*    FT_Short                                                           */
+  /*    FT_UShort                                                          */
+  /*    FT_Long                                                            */
+  /*    FT_ULong                                                           */
+  /*    FT_Bool                                                            */
+  /*    FT_Offset                                                          */
+  /*    FT_PtrDist                                                         */
+  /*    FT_String                                                          */
+  /*    FT_Tag                                                             */
+  /*    FT_Error                                                           */
+  /*    FT_Fixed                                                           */
+  /*    FT_Pointer                                                         */
+  /*    FT_Pos                                                             */
+  /*    FT_Vector                                                          */
+  /*    FT_BBox                                                            */
+  /*    FT_Matrix                                                          */
+  /*    FT_FWord                                                           */
+  /*    FT_UFWord                                                          */
+  /*    FT_F2Dot14                                                         */
+  /*    FT_UnitVector                                                      */
+  /*    FT_F26Dot6                                                         */
+  /*                                                                       */
+  /*                                                                       */
+  /*    FT_Generic                                                         */
+  /*    FT_Generic_Finalizer                                               */
+  /*                                                                       */
+  /*    FT_Bitmap                                                          */
+  /*    FT_Pixel_Mode                                                      */
+  /*    FT_Palette_Mode                                                    */
+  /*    FT_Glyph_Format                                                    */
+  /*    FT_IMAGE_TAG                                                       */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Bool                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef of unsigned char, used for simple booleans.  As usual,   */
+  /*    values 1 and~0 represent true and false, respectively.             */
+  /*                                                                       */
+  typedef unsigned char  FT_Bool;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_FWord                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A signed 16-bit integer used to store a distance in original font  */
+  /*    units.                                                             */
+  /*                                                                       */
+  typedef signed short  FT_FWord;   /* distance in FUnits */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_UFWord                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An unsigned 16-bit integer used to store a distance in original    */
+  /*    font units.                                                        */
+  /*                                                                       */
+  typedef unsigned short  FT_UFWord;  /* unsigned distance */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Char                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple typedef for the _signed_ char type.                       */
+  /*                                                                       */
+  typedef signed char  FT_Char;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Byte                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple typedef for the _unsigned_ char type.                     */
+  /*                                                                       */
+  typedef unsigned char  FT_Byte;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Bytes                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for constant memory areas.                               */
+  /*                                                                       */
+  typedef const FT_Byte*  FT_Bytes;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Tag                                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for 32-bit tags (as used in the SFNT format).            */
+  /*                                                                       */
+  typedef FT_UInt32  FT_Tag;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_String                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple typedef for the char type, usually used for strings.      */
+  /*                                                                       */
+  typedef char  FT_String;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Short                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for signed short.                                        */
+  /*                                                                       */
+  typedef signed short  FT_Short;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_UShort                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for unsigned short.                                      */
+  /*                                                                       */
+  typedef unsigned short  FT_UShort;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Int                                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for the int type.                                        */
+  /*                                                                       */
+  typedef signed int  FT_Int;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_UInt                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for the unsigned int type.                               */
+  /*                                                                       */
+  typedef unsigned int  FT_UInt;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Long                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for signed long.                                         */
+  /*                                                                       */
+  typedef signed long  FT_Long;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_ULong                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A typedef for unsigned long.                                       */
+  /*                                                                       */
+  typedef unsigned long  FT_ULong;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_F2Dot14                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A signed 2.14 fixed float type used for unit vectors.              */
+  /*                                                                       */
+  typedef signed short  FT_F2Dot14;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_F26Dot6                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A signed 26.6 fixed float type used for vectorial pixel            */
+  /*    coordinates.                                                       */
+  /*                                                                       */
+  typedef signed long  FT_F26Dot6;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Fixed                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This type is used to store 16.16 fixed float values, like scaling  */
+  /*    values or matrix coefficients.                                     */
+  /*                                                                       */
+  typedef signed long  FT_Fixed;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Error                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The FreeType error code type.  A value of~0 is always interpreted  */
+  /*    as a successful operation.                                         */
+  /*                                                                       */
+  typedef int  FT_Error;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Pointer                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple typedef for a typeless pointer.                           */
+  /*                                                                       */
+  typedef void*  FT_Pointer;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_Offset                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This is equivalent to the ANSI~C `size_t' type, i.e., the largest  */
+  /*    _unsigned_ integer type used to express a file size or position,   */
+  /*    or a memory block size.                                            */
+  /*                                                                       */
+  typedef size_t  FT_Offset;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_PtrDist                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This is equivalent to the ANSI~C `ptrdiff_t' type, i.e., the       */
+  /*    largest _signed_ integer type used to express the distance         */
+  /*    between two pointers.                                              */
+  /*                                                                       */
+  typedef ft_ptrdiff_t  FT_PtrDist;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_UnitVector                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to store a 2D vector unit vector.  Uses    */
+  /*    FT_F2Dot14 types.                                                  */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    x :: Horizontal coordinate.                                        */
+  /*                                                                       */
+  /*    y :: Vertical coordinate.                                          */
+  /*                                                                       */
+  typedef struct  FT_UnitVector_
+  {
+    FT_F2Dot14  x;
+    FT_F2Dot14  y;
+
+  } FT_UnitVector;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Matrix                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure used to store a 2x2 matrix.  Coefficients are   */
+  /*    in 16.16 fixed float format.  The computation performed is:        */
+  /*                                                                       */
+  /*       {                                                               */
+  /*          x' = x*xx + y*xy                                             */
+  /*          y' = x*yx + y*yy                                             */
+  /*       }                                                               */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    xx :: Matrix coefficient.                                          */
+  /*                                                                       */
+  /*    xy :: Matrix coefficient.                                          */
+  /*                                                                       */
+  /*    yx :: Matrix coefficient.                                          */
+  /*                                                                       */
+  /*    yy :: Matrix coefficient.                                          */
+  /*                                                                       */
+  typedef struct  FT_Matrix_
+  {
+    FT_Fixed  xx, xy;
+    FT_Fixed  yx, yy;
+
+  } FT_Matrix;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Data                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Read-only binary data represented as a pointer and a length.       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    pointer :: The data.                                               */
+  /*                                                                       */
+  /*    length  :: The length of the data in bytes.                        */
+  /*                                                                       */
+  typedef struct  FT_Data_
+  {
+    const FT_Byte*  pointer;
+    FT_Int          length;
+
+  } FT_Data;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Generic_Finalizer                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Describe a function used to destroy the `client' data of any       */
+  /*    FreeType object.  See the description of the @FT_Generic type for  */
+  /*    details of usage.                                                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    The address of the FreeType object which is under finalization.    */
+  /*    Its client data is accessed through its `generic' field.           */
+  /*                                                                       */
+  typedef void  (*FT_Generic_Finalizer)(void*  object);
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Generic                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Client applications often need to associate their own data to a    */
+  /*    variety of FreeType core objects.  For example, a text layout API  */
+  /*    might want to associate a glyph cache to a given size object.      */
+  /*                                                                       */
+  /*    Some FreeType object contains a `generic' field, of type           */
+  /*    FT_Generic, which usage is left to client applications and font    */
+  /*    servers.                                                           */
+  /*                                                                       */
+  /*    It can be used to store a pointer to client-specific data, as well */
+  /*    as the address of a `finalizer' function, which will be called by  */
+  /*    FreeType when the object is destroyed (for example, the previous   */
+  /*    client example would put the address of the glyph cache destructor */
+  /*    in the `finalizer' field).                                         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    data      :: A typeless pointer to any client-specified data. This */
+  /*                 field is completely ignored by the FreeType library.  */
+  /*                                                                       */
+  /*    finalizer :: A pointer to a `generic finalizer' function, which    */
+  /*                 will be called when the object is destroyed.  If this */
+  /*                 field is set to NULL, no code will be called.         */
+  /*                                                                       */
+  typedef struct  FT_Generic_
+  {
+    void*                 data;
+    FT_Generic_Finalizer  finalizer;
+
+  } FT_Generic;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_MAKE_TAG                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This macro converts four-letter tags which are used to label       */
+  /*    TrueType tables into an unsigned long to be used within FreeType.  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The produced values *must* be 32-bit integers.  Don't redefine     */
+  /*    this macro.                                                        */
+  /*                                                                       */
+#define FT_MAKE_TAG( _x1, _x2, _x3, _x4 ) \
+          (FT_Tag)                        \
+          ( ( (FT_ULong)_x1 << 24 ) |     \
+            ( (FT_ULong)_x2 << 16 ) |     \
+            ( (FT_ULong)_x3 <<  8 ) |     \
+              (FT_ULong)_x4         )
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*                                                                       */
+  /*                    L I S T   M A N A G E M E N T                      */
+  /*                                                                       */
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    list_processing                                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_ListNode                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*     Many elements and objects in FreeType are listed through an       */
+  /*     @FT_List record (see @FT_ListRec).  As its name suggests, an      */
+  /*     FT_ListNode is a handle to a single list element.                 */
+  /*                                                                       */
+  typedef struct FT_ListNodeRec_*  FT_ListNode;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    FT_List                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a list record (see @FT_ListRec).                       */
+  /*                                                                       */
+  typedef struct FT_ListRec_*  FT_List;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_ListNodeRec                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to hold a single list element.                    */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    prev :: The previous element in the list.  NULL if first.          */
+  /*                                                                       */
+  /*    next :: The next element in the list.  NULL if last.               */
+  /*                                                                       */
+  /*    data :: A typeless pointer to the listed object.                   */
+  /*                                                                       */
+  typedef struct  FT_ListNodeRec_
+  {
+    FT_ListNode  prev;
+    FT_ListNode  next;
+    void*        data;
+
+  } FT_ListNodeRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_ListRec                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to hold a simple doubly-linked list.  These are   */
+  /*    used in many parts of FreeType.                                    */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    head :: The head (first element) of doubly-linked list.            */
+  /*                                                                       */
+  /*    tail :: The tail (last element) of doubly-linked list.             */
+  /*                                                                       */
+  typedef struct  FT_ListRec_
+  {
+    FT_ListNode  head;
+    FT_ListNode  tail;
+
+  } FT_ListRec;
+
+
+  /* */
+
+#define FT_IS_EMPTY( list )  ( (list).head == 0 )
+
+  /* return base error code (without module-specific prefix) */
+#define FT_ERROR_BASE( x )    ( (x) & 0xFF )
+
+  /* return module error code */
+#define FT_ERROR_MODULE( x )  ( (x) & 0xFF00U )
+
+#define FT_BOOL( x )  ( (FT_Bool)( x ) )
+
+FT_END_HEADER
+
+#endif /* __FTTYPES_H__ */
+
+
+/* END */
diff --git a/include/freetype/ftwinfnt.h b/include/freetype/ftwinfnt.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftwinfnt.h
@@ -0,0 +1,274 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftwinfnt.h                                                             */
+/*                                                                         */
+/*    FreeType API for accessing Windows fnt-specific data.                */
+/*                                                                         */
+/*  Copyright 2003, 2004, 2008 by                                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTWINFNT_H__
+#define __FTWINFNT_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    winfnt_fonts                                                       */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Window FNT Files                                                   */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Windows FNT specific API.                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the declaration of Windows FNT specific      */
+  /*    functions.                                                         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************
+   *
+   * @enum:
+   *   FT_WinFNT_ID_XXX
+   *
+   * @description:
+   *   A list of valid values for the `charset' byte in
+   *   @FT_WinFNT_HeaderRec.  Exact mapping tables for the various cpXXXX
+   *   encodings (except for cp1361) can be found at ftp://ftp.unicode.org
+   *   in the MAPPINGS/VENDORS/MICSFT/WINDOWS subdirectory.  cp1361 is
+   *   roughly a superset of MAPPINGS/OBSOLETE/EASTASIA/KSC/JOHAB.TXT.
+   *
+   * @values:
+   *   FT_WinFNT_ID_DEFAULT ::
+   *     This is used for font enumeration and font creation as a
+   *     `don't care' value.  Valid font files don't contain this value.
+   *     When querying for information about the character set of the font
+   *     that is currently selected into a specified device context, this
+   *     return value (of the related Windows API) simply denotes failure.
+   *
+   *   FT_WinFNT_ID_SYMBOL ::
+   *     There is no known mapping table available.
+   *
+   *   FT_WinFNT_ID_MAC ::
+   *     Mac Roman encoding.
+   *
+   *   FT_WinFNT_ID_OEM ::
+   *     From Michael Pöttgen <michael@poettgen.de>:
+   *
+   *       The `Windows Font Mapping' article says that FT_WinFNT_ID_OEM
+   *       is used for the charset of vector fonts, like `modern.fon',
+   *       `roman.fon', and `script.fon' on Windows.
+   *
+   *       The `CreateFont' documentation says: The FT_WinFNT_ID_OEM value
+   *       specifies a character set that is operating-system dependent.
+   *
+   *       The `IFIMETRICS' documentation from the `Windows Driver
+   *       Development Kit' says: This font supports an OEM-specific
+   *       character set.  The OEM character set is system dependent.
+   *
+   *       In general OEM, as opposed to ANSI (i.e., cp1252), denotes the
+   *       second default codepage that most international versions of
+   *       Windows have.  It is one of the OEM codepages from
+   *
+   *         http://www.microsoft.com/globaldev/reference/cphome.mspx,
+   *
+   *       and is used for the `DOS boxes', to support legacy applications.
+   *       A German Windows version for example usually uses ANSI codepage
+   *       1252 and OEM codepage 850.
+   *
+   *   FT_WinFNT_ID_CP874 ::
+   *     A superset of Thai TIS 620 and ISO 8859-11.
+   *
+   *   FT_WinFNT_ID_CP932 ::
+   *     A superset of Japanese Shift-JIS (with minor deviations).
+   *
+   *   FT_WinFNT_ID_CP936 ::
+   *     A superset of simplified Chinese GB 2312-1980 (with different
+   *     ordering and minor deviations).
+   *
+   *   FT_WinFNT_ID_CP949 ::
+   *     A superset of Korean Hangul KS~C 5601-1987 (with different
+   *     ordering and minor deviations).
+   *
+   *   FT_WinFNT_ID_CP950 ::
+   *     A superset of traditional Chinese Big~5 ETen (with different
+   *     ordering and minor deviations).
+   *
+   *   FT_WinFNT_ID_CP1250 ::
+   *     A superset of East European ISO 8859-2 (with slightly different
+   *     ordering).
+   *
+   *   FT_WinFNT_ID_CP1251 ::
+   *     A superset of Russian ISO 8859-5 (with different ordering).
+   *
+   *   FT_WinFNT_ID_CP1252 ::
+   *     ANSI encoding.  A superset of ISO 8859-1.
+   *
+   *   FT_WinFNT_ID_CP1253 ::
+   *     A superset of Greek ISO 8859-7 (with minor modifications).
+   *
+   *   FT_WinFNT_ID_CP1254 ::
+   *     A superset of Turkish ISO 8859-9.
+   *
+   *   FT_WinFNT_ID_CP1255 ::
+   *     A superset of Hebrew ISO 8859-8 (with some modifications).
+   *
+   *   FT_WinFNT_ID_CP1256 ::
+   *     A superset of Arabic ISO 8859-6 (with different ordering).
+   *
+   *   FT_WinFNT_ID_CP1257 ::
+   *     A superset of Baltic ISO 8859-13 (with some deviations).
+   *
+   *   FT_WinFNT_ID_CP1258 ::
+   *     For Vietnamese.  This encoding doesn't cover all necessary
+   *     characters.
+   *
+   *   FT_WinFNT_ID_CP1361 ::
+   *     Korean (Johab).
+   */
+
+#define FT_WinFNT_ID_CP1252    0
+#define FT_WinFNT_ID_DEFAULT   1
+#define FT_WinFNT_ID_SYMBOL    2
+#define FT_WinFNT_ID_MAC      77
+#define FT_WinFNT_ID_CP932   128
+#define FT_WinFNT_ID_CP949   129
+#define FT_WinFNT_ID_CP1361  130
+#define FT_WinFNT_ID_CP936   134
+#define FT_WinFNT_ID_CP950   136
+#define FT_WinFNT_ID_CP1253  161
+#define FT_WinFNT_ID_CP1254  162
+#define FT_WinFNT_ID_CP1258  163
+#define FT_WinFNT_ID_CP1255  177
+#define FT_WinFNT_ID_CP1256  178
+#define FT_WinFNT_ID_CP1257  186
+#define FT_WinFNT_ID_CP1251  204
+#define FT_WinFNT_ID_CP874   222
+#define FT_WinFNT_ID_CP1250  238
+#define FT_WinFNT_ID_OEM     255
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_WinFNT_HeaderRec                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Windows FNT Header info.                                           */
+  /*                                                                       */
+  typedef struct  FT_WinFNT_HeaderRec_
+  {
+    FT_UShort  version;
+    FT_ULong   file_size;
+    FT_Byte    copyright[60];
+    FT_UShort  file_type;
+    FT_UShort  nominal_point_size;
+    FT_UShort  vertical_resolution;
+    FT_UShort  horizontal_resolution;
+    FT_UShort  ascent;
+    FT_UShort  internal_leading;
+    FT_UShort  external_leading;
+    FT_Byte    italic;
+    FT_Byte    underline;
+    FT_Byte    strike_out;
+    FT_UShort  weight;
+    FT_Byte    charset;
+    FT_UShort  pixel_width;
+    FT_UShort  pixel_height;
+    FT_Byte    pitch_and_family;
+    FT_UShort  avg_width;
+    FT_UShort  max_width;
+    FT_Byte    first_char;
+    FT_Byte    last_char;
+    FT_Byte    default_char;
+    FT_Byte    break_char;
+    FT_UShort  bytes_per_row;
+    FT_ULong   device_offset;
+    FT_ULong   face_name_offset;
+    FT_ULong   bits_pointer;
+    FT_ULong   bits_offset;
+    FT_Byte    reserved;
+    FT_ULong   flags;
+    FT_UShort  A_space;
+    FT_UShort  B_space;
+    FT_UShort  C_space;
+    FT_UShort  color_table_offset;
+    FT_ULong   reserved1[4];
+
+  } FT_WinFNT_HeaderRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_WinFNT_Header                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to an @FT_WinFNT_HeaderRec structure.                     */
+  /*                                                                       */
+  typedef struct FT_WinFNT_HeaderRec_*  FT_WinFNT_Header;
+
+
+  /**********************************************************************
+   *
+   * @function:
+   *    FT_Get_WinFNT_Header
+   *
+   * @description:
+   *    Retrieve a Windows FNT font info header.
+   *
+   * @input:
+   *    face    :: A handle to the input face.
+   *
+   * @output:
+   *    aheader :: The WinFNT header.
+   *
+   * @return:
+   *   FreeType error code.  0~means success.
+   *
+   * @note:
+   *   This function only works with Windows FNT faces, returning an error
+   *   otherwise.
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_WinFNT_Header( FT_Face               face,
+                        FT_WinFNT_HeaderRec  *aheader );
+
+
+  /* */
+
+FT_END_HEADER
+
+#endif /* __FTWINFNT_H__ */
+
+
+/* END */
+
+
+/* Local Variables: */
+/* coding: utf-8    */
+/* End:             */
diff --git a/include/freetype/ftxf86.h b/include/freetype/ftxf86.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ftxf86.h
@@ -0,0 +1,83 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftxf86.h                                                               */
+/*                                                                         */
+/*    Support functions for X11.                                           */
+/*                                                                         */
+/*  Copyright 2002, 2003, 2004, 2006, 2007 by                              */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTXF86_H__
+#define __FTXF86_H__
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*   font_formats                                                        */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*   Font Formats                                                        */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*   Getting the font format.                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*   The single function in this section can be used to get the font     */
+  /*   format.  Note that this information is not needed normally;         */
+  /*   however, there are special cases (like in PDF devices) where it is  */
+  /*   important to differentiate, in spite of FreeType's uniform API.     */
+  /*                                                                       */
+  /*   This function is in the X11/xf86 namespace for historical reasons   */
+  /*   and in no way depends on that windowing system.                     */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*   FT_Get_X11_Font_Format                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*   Return a string describing the format of a given face, using values */
+  /*   which can be used as an X11 FONT_PROPERTY.  Possible values are     */
+  /*   `TrueType', `Type~1', `BDF', `PCF', `Type~42', `CID~Type~1', `CFF', */
+  /*   `PFR', and `Windows~FNT'.                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*   face ::                                                             */
+  /*     Input face handle.                                                */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*   Font format string.  NULL in case of error.                         */
+  /*                                                                       */
+  FT_EXPORT( const char* )
+  FT_Get_X11_Font_Format( FT_Face  face );
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTXF86_H__ */
diff --git a/include/freetype/internal/autohint.h b/include/freetype/internal/autohint.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/autohint.h
@@ -0,0 +1,244 @@
+/***************************************************************************/
+/*                                                                         */
+/*  autohint.h                                                             */
+/*                                                                         */
+/*    High-level `autohint' module-specific interface (specification).     */
+/*                                                                         */
+/*  Copyright 1996-2002, 2007, 2009, 2012 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The auto-hinter is used to load and automatically hint glyphs if a    */
+  /* format-specific hinter isn't available.                               */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __AUTOHINT_H__
+#define __AUTOHINT_H__
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* A small technical note regarding automatic hinting in order to        */
+  /* clarify this module interface.                                        */
+  /*                                                                       */
+  /* An automatic hinter might compute two kinds of data for a given face: */
+  /*                                                                       */
+  /* - global hints: Usually some metrics that describe global properties  */
+  /*                 of the face.  It is computed by scanning more or less */
+  /*                 aggressively the glyphs in the face, and thus can be  */
+  /*                 very slow to compute (even if the size of global      */
+  /*                 hints is really small).                               */
+  /*                                                                       */
+  /* - glyph hints:  These describe some important features of the glyph   */
+  /*                 outline, as well as how to align them.  They are      */
+  /*                 generally much faster to compute than global hints.   */
+  /*                                                                       */
+  /* The current FreeType auto-hinter does a pretty good job while         */
+  /* performing fast computations for both global and glyph hints.         */
+  /* However, we might be interested in introducing more complex and       */
+  /* powerful algorithms in the future, like the one described in the John */
+  /* D. Hobby paper, which unfortunately requires a lot more horsepower.   */
+  /*                                                                       */
+  /* Because a sufficiently sophisticated font management system would     */
+  /* typically implement an LRU cache of opened face objects to reduce     */
+  /* memory usage, it is a good idea to be able to avoid recomputing       */
+  /* global hints every time the same face is re-opened.                   */
+  /*                                                                       */
+  /* We thus provide the ability to cache global hints outside of the face */
+  /* object, in order to speed up font re-opening time.  Of course, this   */
+  /* feature is purely optional, so most client programs won't even notice */
+  /* it.                                                                   */
+  /*                                                                       */
+  /* I initially thought that it would be a good idea to cache the glyph   */
+  /* hints too.  However, my general idea now is that if you really need   */
+  /* to cache these too, you are simply in need of a new font format,      */
+  /* where all this information could be stored within the font file and   */
+  /* decoded on the fly.                                                   */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+
+FT_BEGIN_HEADER
+
+
+  typedef struct FT_AutoHinterRec_  *FT_AutoHinter;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_AutoHinter_GlobalGetFunc                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Retrieve the global hints computed for a given face object.  The   */
+  /*    resulting data is dissociated from the face and will survive a     */
+  /*    call to FT_Done_Face().  It must be discarded through the API      */
+  /*    FT_AutoHinter_GlobalDoneFunc().                                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    hinter       :: A handle to the source auto-hinter.                */
+  /*                                                                       */
+  /*    face         :: A handle to the source face object.                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    global_hints :: A typeless pointer to the global hints.            */
+  /*                                                                       */
+  /*    global_len   :: The size in bytes of the global hints.             */
+  /*                                                                       */
+  typedef void
+  (*FT_AutoHinter_GlobalGetFunc)( FT_AutoHinter  hinter,
+                                  FT_Face        face,
+                                  void**         global_hints,
+                                  long*          global_len );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_AutoHinter_GlobalDoneFunc                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Discard the global hints retrieved through                         */
+  /*    FT_AutoHinter_GlobalGetFunc().  This is the only way these hints   */
+  /*    are freed from memory.                                             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    hinter :: A handle to the auto-hinter module.                      */
+  /*                                                                       */
+  /*    global :: A pointer to retrieved global hints to discard.          */
+  /*                                                                       */
+  typedef void
+  (*FT_AutoHinter_GlobalDoneFunc)( FT_AutoHinter  hinter,
+                                   void*          global );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_AutoHinter_GlobalResetFunc                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function is used to recompute the global metrics in a given   */
+  /*    font.  This is useful when global font data changes (e.g. Multiple */
+  /*    Masters fonts where blend coordinates change).                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    hinter :: A handle to the source auto-hinter.                      */
+  /*                                                                       */
+  /*    face   :: A handle to the face.                                    */
+  /*                                                                       */
+  typedef void
+  (*FT_AutoHinter_GlobalResetFunc)( FT_AutoHinter  hinter,
+                                    FT_Face        face );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_AutoHinter_GlyphLoadFunc                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function is used to load, scale, and automatically hint a     */
+  /*    glyph from a given face.                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face        :: A handle to the face.                               */
+  /*                                                                       */
+  /*    glyph_index :: The glyph index.                                    */
+  /*                                                                       */
+  /*    load_flags  :: The load flags.                                     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function is capable of loading composite glyphs by hinting    */
+  /*    each sub-glyph independently (which improves quality).             */
+  /*                                                                       */
+  /*    It will call the font driver with @FT_Load_Glyph, with             */
+  /*    @FT_LOAD_NO_SCALE set.                                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*FT_AutoHinter_GlyphLoadFunc)( FT_AutoHinter  hinter,
+                                  FT_GlyphSlot   slot,
+                                  FT_Size        size,
+                                  FT_UInt        glyph_index,
+                                  FT_Int32       load_flags );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_AutoHinter_InterfaceRec                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The auto-hinter module's interface.                                */
+  /*                                                                       */
+  typedef struct  FT_AutoHinter_InterfaceRec_
+  {
+    FT_AutoHinter_GlobalResetFunc  reset_face;
+    FT_AutoHinter_GlobalGetFunc    get_global_hints;
+    FT_AutoHinter_GlobalDoneFunc   done_global_hints;
+    FT_AutoHinter_GlyphLoadFunc    load_glyph;
+
+  } FT_AutoHinter_InterfaceRec, *FT_AutoHinter_Interface;
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_AUTOHINTER_INTERFACE(       \
+          class_,                             \
+          reset_face_,                        \
+          get_global_hints_,                  \
+          done_global_hints_,                 \
+          load_glyph_ )                       \
+  FT_CALLBACK_TABLE_DEF                       \
+  const FT_AutoHinter_InterfaceRec  class_ =  \
+  {                                           \
+    reset_face_,                              \
+    get_global_hints_,                        \
+    done_global_hints_,                       \
+    load_glyph_                               \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_AUTOHINTER_INTERFACE(                            \
+          class_,                                                  \
+          reset_face_,                                             \
+          get_global_hints_,                                       \
+          done_global_hints_,                                      \
+          load_glyph_ )                                            \
+  void                                                             \
+  FT_Init_Class_ ## class_( FT_Library                   library,  \
+                            FT_AutoHinter_InterfaceRec*  clazz )   \
+  {                                                                \
+    FT_UNUSED( library );                                          \
+                                                                   \
+    clazz->reset_face        = reset_face_;                        \
+    clazz->get_global_hints  = get_global_hints_;                  \
+    clazz->done_global_hints = done_global_hints_;                 \
+    clazz->load_glyph        = load_glyph_;                        \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+FT_END_HEADER
+
+#endif /* __AUTOHINT_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftcalc.h b/include/freetype/internal/ftcalc.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftcalc.h
@@ -0,0 +1,175 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftcalc.h                                                               */
+/*                                                                         */
+/*    Arithmetic computations (specification).                             */
+/*                                                                         */
+/*  Copyright 1996-2006, 2008, 2009, 2012 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTCALC_H__
+#define __FTCALC_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_FixedSqrt                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the square root of a 16.16 fixed point value.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    x :: The value to compute the root for.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `sqrt(x)'.                                           */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function is not very fast.                                    */
+  /*                                                                       */
+  FT_BASE( FT_Int32 )
+  FT_SqrtFixed( FT_Int32  x );
+
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Sqrt32                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the square root of an Int32 integer (which will be        */
+  /*    handled as an unsigned long value).                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    x :: The value to compute the root for.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `sqrt(x)'.                                           */
+  /*                                                                       */
+  FT_EXPORT( FT_Int32 )
+  FT_Sqrt32( FT_Int32  x );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FT_MulDiv() and FT_MulFix() are declared in freetype.h.               */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_MulDiv_No_Round                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A very simple function used to perform the computation `(a*b)/c'   */
+  /*    (without rounding) with maximum accuracy (it uses a 64-bit         */
+  /*    intermediate integer whenever necessary).                          */
+  /*                                                                       */
+  /*    This function isn't necessarily as fast as some processor specific */
+  /*    operations, but is at least completely portable.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    a :: The first multiplier.                                         */
+  /*    b :: The second multiplier.                                        */
+  /*    c :: The divisor.                                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The result of `(a*b)/c'.  This function never traps when trying to */
+  /*    divide by zero; it simply returns `MaxInt' or `MinInt' depending   */
+  /*    on the signs of `a' and `b'.                                       */
+  /*                                                                       */
+  FT_BASE( FT_Long )
+  FT_MulDiv_No_Round( FT_Long  a,
+                      FT_Long  b,
+                      FT_Long  c );
+
+
+  /*
+   *  A variant of FT_Matrix_Multiply which scales its result afterwards.
+   *  The idea is that both `a' and `b' are scaled by factors of 10 so that
+   *  the values are as precise as possible to get a correct result during
+   *  the 64bit multiplication.  Let `sa' and `sb' be the scaling factors of
+   *  `a' and `b', respectively, then the scaling factor of the result is
+   *  `sa*sb'.
+   */
+  FT_BASE( void )
+  FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
+                             FT_Matrix        *b,
+                             FT_Long           scaling );
+
+
+  /*
+   *  A variant of FT_Vector_Transform.  See comments for
+   *  FT_Matrix_Multiply_Scaled.
+   */
+
+  FT_BASE( void )
+  FT_Vector_Transform_Scaled( FT_Vector*        vector,
+                              const FT_Matrix*  matrix,
+                              FT_Long           scaling );
+
+
+  /*
+   *  Return -1, 0, or +1, depending on the orientation of a given corner.
+   *  We use the Cartesian coordinate system, with positive vertical values
+   *  going upwards.  The function returns +1 if the corner turns to the
+   *  left, -1 to the right, and 0 for undecidable cases.
+   */
+  FT_BASE( FT_Int )
+  ft_corner_orientation( FT_Pos  in_x,
+                         FT_Pos  in_y,
+                         FT_Pos  out_x,
+                         FT_Pos  out_y );
+
+  /*
+   *  Return TRUE if a corner is flat or nearly flat.  This is equivalent to
+   *  saying that the angle difference between the `in' and `out' vectors is
+   *  very small.
+   */
+  FT_BASE( FT_Int )
+  ft_corner_is_flat( FT_Pos  in_x,
+                     FT_Pos  in_y,
+                     FT_Pos  out_x,
+                     FT_Pos  out_y );
+
+
+#define INT_TO_F26DOT6( x )    ( (FT_Long)(x) << 6  )
+#define INT_TO_F2DOT14( x )    ( (FT_Long)(x) << 14 )
+#define INT_TO_FIXED( x )      ( (FT_Long)(x) << 16 )
+#define F2DOT14_TO_FIXED( x )  ( (FT_Long)(x) << 2  )
+#define FLOAT_TO_FIXED( x )    ( (FT_Long)( x * 65536.0 ) )
+#define FIXED_TO_INT( x )      ( FT_RoundFix( x ) >> 16 )
+
+#define ROUND_F26DOT6( x )     ( x >= 0 ? (    ( (x) + 32 ) & -64 )     \
+                                        : ( -( ( 32 - (x) ) & -64 ) ) )
+
+
+FT_END_HEADER
+
+#endif /* __FTCALC_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftdebug.h b/include/freetype/internal/ftdebug.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftdebug.h
@@ -0,0 +1,250 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftdebug.h                                                              */
+/*                                                                         */
+/*    Debugging and logging component (specification).                     */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2004, 2006, 2007, 2008, 2009 by             */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/*                                                                         */
+/*  IMPORTANT: A description of FreeType's debugging support can be        */
+/*             found in `docs/DEBUG.TXT'.  Read it if you need to use or   */
+/*             understand this code.                                       */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTDEBUG_H__
+#define __FTDEBUG_H__
+
+
+#include <ft2build.h>
+#include FT_CONFIG_CONFIG_H
+#include FT_FREETYPE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /* force the definition of FT_DEBUG_LEVEL_ERROR if FT_DEBUG_LEVEL_TRACE */
+  /* is already defined; this simplifies the following #ifdefs            */
+  /*                                                                      */
+#ifdef FT_DEBUG_LEVEL_TRACE
+#undef  FT_DEBUG_LEVEL_ERROR
+#define FT_DEBUG_LEVEL_ERROR
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define the trace enums as well as the trace levels array when they    */
+  /* are needed.                                                           */
+  /*                                                                       */
+  /*************************************************************************/
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+
+#define FT_TRACE_DEF( x )  trace_ ## x ,
+
+  /* defining the enumeration */
+  typedef enum  FT_Trace_
+  {
+#include FT_INTERNAL_TRACE_H
+    trace_count
+
+  } FT_Trace;
+
+
+  /* defining the array of trace levels, provided by `src/base/ftdebug.c' */
+  extern int  ft_trace_levels[trace_count];
+
+#undef FT_TRACE_DEF
+
+#endif /* FT_DEBUG_LEVEL_TRACE */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define the FT_TRACE macro                                             */
+  /*                                                                       */
+  /* IMPORTANT!                                                            */
+  /*                                                                       */
+  /* Each component must define the macro FT_COMPONENT to a valid FT_Trace */
+  /* value before using any TRACE macro.                                   */
+  /*                                                                       */
+  /*************************************************************************/
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+
+#define FT_TRACE( level, varformat )                      \
+          do                                              \
+          {                                               \
+            if ( ft_trace_levels[FT_COMPONENT] >= level ) \
+              FT_Message varformat;                       \
+          } while ( 0 )
+
+#else /* !FT_DEBUG_LEVEL_TRACE */
+
+#define FT_TRACE( level, varformat )  do { } while ( 0 )      /* nothing */
+
+#endif /* !FT_DEBUG_LEVEL_TRACE */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Trace_Get_Count                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the number of available trace components.                   */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The number of trace components.  0 if FreeType 2 is not built with */
+  /*    FT_DEBUG_LEVEL_TRACE definition.                                   */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function may be useful if you want to access elements of      */
+  /*    the internal `ft_trace_levels' array by an index.                  */
+  /*                                                                       */
+  FT_BASE( FT_Int )
+  FT_Trace_Get_Count( void );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Trace_Get_Name                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return the name of a trace component.                              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    The index of the trace component.                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The name of the trace component.  This is a statically allocated   */
+  /*    C string, so do not free it after use.  NULL if FreeType 2 is not  */
+  /*    built with FT_DEBUG_LEVEL_TRACE definition.                        */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Use @FT_Trace_Get_Count to get the number of available trace       */
+  /*    components.                                                        */
+  /*                                                                       */
+  /*    This function may be useful if you want to control FreeType 2's    */
+  /*    debug level in your application.                                   */
+  /*                                                                       */
+  FT_BASE( const char * )
+  FT_Trace_Get_Name( FT_Int  idx );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* You need two opening and closing parentheses!                         */
+  /*                                                                       */
+  /* Example: FT_TRACE0(( "Value is %i", foo ))                            */
+  /*                                                                       */
+  /* Output of the FT_TRACEX macros is sent to stderr.                     */
+  /*                                                                       */
+  /*************************************************************************/
+
+#define FT_TRACE0( varformat )  FT_TRACE( 0, varformat )
+#define FT_TRACE1( varformat )  FT_TRACE( 1, varformat )
+#define FT_TRACE2( varformat )  FT_TRACE( 2, varformat )
+#define FT_TRACE3( varformat )  FT_TRACE( 3, varformat )
+#define FT_TRACE4( varformat )  FT_TRACE( 4, varformat )
+#define FT_TRACE5( varformat )  FT_TRACE( 5, varformat )
+#define FT_TRACE6( varformat )  FT_TRACE( 6, varformat )
+#define FT_TRACE7( varformat )  FT_TRACE( 7, varformat )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define the FT_ERROR macro.                                            */
+  /*                                                                       */
+  /* Output of this macro is sent to stderr.                               */
+  /*                                                                       */
+  /*************************************************************************/
+
+#ifdef FT_DEBUG_LEVEL_ERROR
+
+#define FT_ERROR( varformat )  FT_Message  varformat
+
+#else  /* !FT_DEBUG_LEVEL_ERROR */
+
+#define FT_ERROR( varformat )  do { } while ( 0 )      /* nothing */
+
+#endif /* !FT_DEBUG_LEVEL_ERROR */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define the FT_ASSERT macro.                                           */
+  /*                                                                       */
+  /*************************************************************************/
+
+#ifdef FT_DEBUG_LEVEL_ERROR
+
+#define FT_ASSERT( condition )                                      \
+          do                                                        \
+          {                                                         \
+            if ( !( condition ) )                                   \
+              FT_Panic( "assertion failed on line %d of file %s\n", \
+                        __LINE__, __FILE__ );                       \
+          } while ( 0 )
+
+#else /* !FT_DEBUG_LEVEL_ERROR */
+
+#define FT_ASSERT( condition )  do { } while ( 0 )
+
+#endif /* !FT_DEBUG_LEVEL_ERROR */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define `FT_Message' and `FT_Panic' when needed.                       */
+  /*                                                                       */
+  /*************************************************************************/
+
+#ifdef FT_DEBUG_LEVEL_ERROR
+
+#include "stdio.h"  /* for vfprintf() */
+
+  /* print a message */
+  FT_BASE( void )
+  FT_Message( const char*  fmt,
+              ... );
+
+  /* print a message and exit */
+  FT_BASE( void )
+  FT_Panic( const char*  fmt,
+            ... );
+
+#endif /* FT_DEBUG_LEVEL_ERROR */
+
+
+  FT_BASE( void )
+  ft_debug_init( void );
+
+
+#if defined( _MSC_VER )      /* Visual C++ (and Intel C++) */
+
+  /* We disable the warning `conditional expression is constant' here */
+  /* in order to compile cleanly with the maximum level of warnings.  */
+#pragma warning( disable : 4127 )
+
+#endif /* _MSC_VER */
+
+
+FT_END_HEADER
+
+#endif /* __FTDEBUG_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftdriver.h b/include/freetype/internal/ftdriver.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftdriver.h
@@ -0,0 +1,481 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftdriver.h                                                             */
+/*                                                                         */
+/*    FreeType font driver interface (specification).                      */
+/*                                                                         */
+/*  Copyright 1996-2003, 2006, 2008, 2011-2012 by                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTDRIVER_H__
+#define __FTDRIVER_H__
+
+
+#include <ft2build.h>
+#include FT_MODULE_H
+
+
+FT_BEGIN_HEADER
+
+
+  typedef FT_Error
+  (*FT_Face_InitFunc)( FT_Stream      stream,
+                       FT_Face        face,
+                       FT_Int         typeface_index,
+                       FT_Int         num_params,
+                       FT_Parameter*  parameters );
+
+  typedef void
+  (*FT_Face_DoneFunc)( FT_Face  face );
+
+
+  typedef FT_Error
+  (*FT_Size_InitFunc)( FT_Size  size );
+
+  typedef void
+  (*FT_Size_DoneFunc)( FT_Size  size );
+
+
+  typedef FT_Error
+  (*FT_Slot_InitFunc)( FT_GlyphSlot  slot );
+
+  typedef void
+  (*FT_Slot_DoneFunc)( FT_GlyphSlot  slot );
+
+
+  typedef FT_Error
+  (*FT_Size_RequestFunc)( FT_Size          size,
+                          FT_Size_Request  req );
+
+  typedef FT_Error
+  (*FT_Size_SelectFunc)( FT_Size   size,
+                         FT_ULong  size_index );
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  typedef FT_Error
+  (*FT_Size_ResetPointsFunc)( FT_Size     size,
+                              FT_F26Dot6  char_width,
+                              FT_F26Dot6  char_height,
+                              FT_UInt     horz_resolution,
+                              FT_UInt     vert_resolution );
+
+  typedef FT_Error
+  (*FT_Size_ResetPixelsFunc)( FT_Size  size,
+                              FT_UInt  pixel_width,
+                              FT_UInt  pixel_height );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+  typedef FT_Error
+  (*FT_Slot_LoadFunc)( FT_GlyphSlot  slot,
+                       FT_Size       size,
+                       FT_UInt       glyph_index,
+                       FT_Int32      load_flags );
+
+
+  typedef FT_UInt
+  (*FT_CharMap_CharIndexFunc)( FT_CharMap  charmap,
+                               FT_Long     charcode );
+
+  typedef FT_Long
+  (*FT_CharMap_CharNextFunc)( FT_CharMap  charmap,
+                              FT_Long     charcode );
+
+
+  typedef FT_Error
+  (*FT_Face_GetKerningFunc)( FT_Face     face,
+                             FT_UInt     left_glyph,
+                             FT_UInt     right_glyph,
+                             FT_Vector*  kerning );
+
+
+  typedef FT_Error
+  (*FT_Face_AttachFunc)( FT_Face    face,
+                         FT_Stream  stream );
+
+
+  typedef FT_Error
+  (*FT_Face_GetAdvancesFunc)( FT_Face    face,
+                              FT_UInt    first,
+                              FT_UInt    count,
+                              FT_Int32   flags,
+                              FT_Fixed*  advances );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Driver_ClassRec                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The font driver class.  This structure mostly contains pointers to */
+  /*    driver methods.                                                    */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    root             :: The parent module.                             */
+  /*                                                                       */
+  /*    face_object_size :: The size of a face object in bytes.            */
+  /*                                                                       */
+  /*    size_object_size :: The size of a size object in bytes.            */
+  /*                                                                       */
+  /*    slot_object_size :: The size of a glyph object in bytes.           */
+  /*                                                                       */
+  /*    init_face        :: The format-specific face constructor.          */
+  /*                                                                       */
+  /*    done_face        :: The format-specific face destructor.           */
+  /*                                                                       */
+  /*    init_size        :: The format-specific size constructor.          */
+  /*                                                                       */
+  /*    done_size        :: The format-specific size destructor.           */
+  /*                                                                       */
+  /*    init_slot        :: The format-specific slot constructor.          */
+  /*                                                                       */
+  /*    done_slot        :: The format-specific slot destructor.           */
+  /*                                                                       */
+  /*                                                                       */
+  /*    load_glyph       :: A function handle to load a glyph to a slot.   */
+  /*                        This field is mandatory!                       */
+  /*                                                                       */
+  /*    get_kerning      :: A function handle to return the unscaled       */
+  /*                        kerning for a given pair of glyphs.  Can be    */
+  /*                        set to 0 if the format doesn't support         */
+  /*                        kerning.                                       */
+  /*                                                                       */
+  /*    attach_file      :: This function handle is used to read           */
+  /*                        additional data for a face from another        */
+  /*                        file/stream.  For example, this can be used to */
+  /*                        add data from AFM or PFM files on a Type 1     */
+  /*                        face, or a CIDMap on a CID-keyed face.         */
+  /*                                                                       */
+  /*    get_advances     :: A function handle used to return advance       */
+  /*                        widths of `count' glyphs (in font units),      */
+  /*                        starting at `first'.  The `vertical' flag must */
+  /*                        be set to get vertical advance heights.  The   */
+  /*                        `advances' buffer is caller-allocated.         */
+  /*                        The idea of this function is to be able to     */
+  /*                        perform device-independent text layout without */
+  /*                        loading a single glyph image.                  */
+  /*                                                                       */
+  /*    request_size     :: A handle to a function used to request the new */
+  /*                        character size.  Can be set to 0 if the        */
+  /*                        scaling done in the base layer suffices.       */
+  /*                                                                       */
+  /*    select_size      :: A handle to a function used to select a new    */
+  /*                        fixed size.  It is used only if                */
+  /*                        @FT_FACE_FLAG_FIXED_SIZES is set.  Can be set  */
+  /*                        to 0 if the scaling done in the base layer     */
+  /*                        suffices.                                      */
+  /* <Note>                                                                */
+  /*    Most function pointers, with the exception of `load_glyph', can be */
+  /*    set to 0 to indicate a default behaviour.                          */
+  /*                                                                       */
+  typedef struct  FT_Driver_ClassRec_
+  {
+    FT_Module_Class          root;
+
+    FT_Long                  face_object_size;
+    FT_Long                  size_object_size;
+    FT_Long                  slot_object_size;
+
+    FT_Face_InitFunc         init_face;
+    FT_Face_DoneFunc         done_face;
+
+    FT_Size_InitFunc         init_size;
+    FT_Size_DoneFunc         done_size;
+
+    FT_Slot_InitFunc         init_slot;
+    FT_Slot_DoneFunc         done_slot;
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+    FT_Size_ResetPointsFunc  set_char_sizes;
+    FT_Size_ResetPixelsFunc  set_pixel_sizes;
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+    FT_Slot_LoadFunc         load_glyph;
+
+    FT_Face_GetKerningFunc   get_kerning;
+    FT_Face_AttachFunc       attach_file;
+    FT_Face_GetAdvancesFunc  get_advances;
+
+    /* since version 2.2 */
+    FT_Size_RequestFunc      request_size;
+    FT_Size_SelectFunc       select_size;
+
+  } FT_Driver_ClassRec, *FT_Driver_Class;
+
+
+  /*
+   *  The following functions are used as stubs for `set_char_sizes' and
+   *  `set_pixel_sizes'; the code uses `request_size' and `select_size'
+   *  functions instead.
+   *
+   *  Implementation is in `src/base/ftobjs.c'.
+   */
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  FT_BASE( FT_Error )
+  ft_stub_set_char_sizes( FT_Size     size,
+                          FT_F26Dot6  width,
+                          FT_F26Dot6  height,
+                          FT_UInt     horz_res,
+                          FT_UInt     vert_res );
+
+  FT_BASE( FT_Error )
+  ft_stub_set_pixel_sizes( FT_Size  size,
+                           FT_UInt  width,
+                           FT_UInt  height );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DECLARE_DRIVER                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to create a forward declaration of an FT_Driver_ClassRec      */
+  /*    struct instance.                                                   */
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_DRIVER                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of FT_Driver_ClassRec struct.       */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is defined a `create' function has to be */
+  /*    called with a pointer where the allocated structure is returned.   */
+  /*    And when it is no longer needed a `destroy' function needs to be   */
+  /*    called to release that allocation.                                 */
+  /*                                                                       */
+  /*    `fcinit.c' (ft_create_default_module_classes) already contains a   */
+  /*    mechanism to call these functions for the default modules          */
+  /*    described in `ftmodule.h'.                                         */
+  /*                                                                       */
+  /*    Notice that the created `create' and `destroy' functions call      */
+  /*    `pic_init' and `pic_free' to allow you to manually allocate and    */
+  /*    initialize any additional global data, like a module specific      */
+  /*    interface, and put them in the global pic container defined in     */
+  /*    `ftpic.h'.  If you don't need them just implement the functions as */
+  /*    empty to resolve the link error.  Also the `pic_init' and          */
+  /*    `pic_free' functions should be declared in `pic.h', to be referred */
+  /*    by driver definition calling `FT_DEFINE_DRIVER' in following.      */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
+  /*    allocated in the global scope (or the scope where the macro is     */
+  /*    used).                                                             */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+#define FT_DEFINE_DRIVERS_OLD_INTERNALS( a_, b_ ) \
+          a_, b_,
+#else
+#define FT_DEFINE_DRIVERS_OLD_INTERNALS( a_, b_ )  /* empty */
+#endif
+
+#define FT_DECLARE_DRIVER( class_ )  \
+  FT_CALLBACK_TABLE                   \
+  const FT_Driver_ClassRec  class_;
+
+#define FT_DEFINE_DRIVER(                                    \
+          class_,                                            \
+          flags_,                                            \
+          size_,                                             \
+          name_,                                             \
+          version_,                                          \
+          requires_,                                         \
+          interface_,                                        \
+          init_,                                             \
+          done_,                                             \
+          get_interface_,                                    \
+          face_object_size_,                                 \
+          size_object_size_,                                 \
+          slot_object_size_,                                 \
+          init_face_,                                        \
+          done_face_,                                        \
+          init_size_,                                        \
+          done_size_,                                        \
+          init_slot_,                                        \
+          done_slot_,                                        \
+          old_set_char_sizes_,                               \
+          old_set_pixel_sizes_,                              \
+          load_glyph_,                                       \
+          get_kerning_,                                      \
+          attach_file_,                                      \
+          get_advances_,                                     \
+          request_size_,                                     \
+          select_size_ )                                     \
+  FT_CALLBACK_TABLE_DEF                                      \
+  const FT_Driver_ClassRec  class_ =                         \
+  {                                                          \
+    FT_DEFINE_ROOT_MODULE( flags_,                           \
+                           size_,                            \
+                           name_,                            \
+                           version_,                         \
+                           requires_,                        \
+                           interface_,                       \
+                           init_,                            \
+                           done_,                            \
+                           get_interface_ )                  \
+                                                             \
+    face_object_size_,                                       \
+    size_object_size_,                                       \
+    slot_object_size_,                                       \
+                                                             \
+    init_face_,                                              \
+    done_face_,                                              \
+                                                             \
+    init_size_,                                              \
+    done_size_,                                              \
+                                                             \
+    init_slot_,                                              \
+    done_slot_,                                              \
+                                                             \
+    FT_DEFINE_DRIVERS_OLD_INTERNALS( old_set_char_sizes_,    \
+                                     old_set_pixel_sizes_ )  \
+                                                             \
+    load_glyph_,                                             \
+                                                             \
+    get_kerning_,                                            \
+    attach_file_,                                            \
+    get_advances_,                                           \
+                                                             \
+    request_size_,                                           \
+    select_size_                                             \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+#define FT_DEFINE_DRIVERS_OLD_INTERNALS( a_, b_ )  \
+          clazz->set_char_sizes  = a_;             \
+          clazz->set_pixel_sizes = b_;
+#else
+#define FT_DEFINE_DRIVERS_OLD_INTERNALS( a_, b_ )  /* empty */
+#endif
+
+#define FT_DECLARE_DRIVER( class_ )  FT_DECLARE_MODULE( class_ )
+
+#define FT_DEFINE_DRIVER(                                        \
+          class_,                                                \
+          flags_,                                                \
+          size_,                                                 \
+          name_,                                                 \
+          version_,                                              \
+          requires_,                                             \
+          interface_,                                            \
+          init_,                                                 \
+          done_,                                                 \
+          get_interface_,                                        \
+          face_object_size_,                                     \
+          size_object_size_,                                     \
+          slot_object_size_,                                     \
+          init_face_,                                            \
+          done_face_,                                            \
+          init_size_,                                            \
+          done_size_,                                            \
+          init_slot_,                                            \
+          done_slot_,                                            \
+          old_set_char_sizes_,                                   \
+          old_set_pixel_sizes_,                                  \
+          load_glyph_,                                           \
+          get_kerning_,                                          \
+          attach_file_,                                          \
+          get_advances_,                                         \
+          request_size_,                                         \
+          select_size_ )                                         \
+  void                                                           \
+  FT_Destroy_Class_ ## class_( FT_Library        library,        \
+                               FT_Module_Class*  clazz )         \
+  {                                                              \
+    FT_Memory        memory = library->memory;                   \
+    FT_Driver_Class  dclazz = (FT_Driver_Class)clazz;            \
+                                                                 \
+                                                                 \
+    class_ ## _pic_free( library );                              \
+    if ( dclazz )                                                \
+      FT_FREE( dclazz );                                         \
+  }                                                              \
+                                                                 \
+                                                                 \
+  FT_Error                                                       \
+  FT_Create_Class_ ## class_( FT_Library         library,        \
+                              FT_Module_Class**  output_class )  \
+  {                                                              \
+    FT_Driver_Class  clazz  = NULL;                              \
+    FT_Error         error;                                      \
+    FT_Memory        memory = library->memory;                   \
+                                                                 \
+                                                                 \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) ) )                  \
+      return error;                                              \
+                                                                 \
+    error = class_ ## _pic_init( library );                      \
+    if ( error )                                                 \
+    {                                                            \
+      FT_FREE( clazz );                                          \
+      return error;                                              \
+    }                                                            \
+                                                                 \
+    FT_DEFINE_ROOT_MODULE( flags_,                               \
+                           size_,                                \
+                           name_,                                \
+                           version_,                             \
+                           requires_,                            \
+                           interface_,                           \
+                           init_,                                \
+                           done_,                                \
+                           get_interface_ )                      \
+                                                                 \
+    clazz->face_object_size = face_object_size_;                 \
+    clazz->size_object_size = size_object_size_;                 \
+    clazz->slot_object_size = slot_object_size_;                 \
+                                                                 \
+    clazz->init_face        = init_face_;                        \
+    clazz->done_face        = done_face_;                        \
+                                                                 \
+    clazz->init_size        = init_size_;                        \
+    clazz->done_size        = done_size_;                        \
+                                                                 \
+    clazz->init_slot        = init_slot_;                        \
+    clazz->done_slot        = done_slot_;                        \
+                                                                 \
+    FT_DEFINE_DRIVERS_OLD_INTERNALS( old_set_char_sizes_,        \
+                                     old_set_pixel_sizes_ )      \
+                                                                 \
+    clazz->load_glyph       = load_glyph_;                       \
+                                                                 \
+    clazz->get_kerning      = get_kerning_;                      \
+    clazz->attach_file      = attach_file_;                      \
+    clazz->get_advances     = get_advances_;                     \
+                                                                 \
+    clazz->request_size     = request_size_;                     \
+    clazz->select_size      = select_size_;                      \
+                                                                 \
+    *output_class = (FT_Module_Class*)clazz;                     \
+                                                                 \
+    return FT_Err_Ok;                                            \
+  }
+
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+FT_END_HEADER
+
+#endif /* __FTDRIVER_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftgloadr.h b/include/freetype/internal/ftgloadr.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftgloadr.h
@@ -0,0 +1,168 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftgloadr.h                                                             */
+/*                                                                         */
+/*    The FreeType glyph loader (specification).                           */
+/*                                                                         */
+/*  Copyright 2002, 2003, 2005, 2006 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg                       */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTGLOADR_H__
+#define __FTGLOADR_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_GlyphLoader                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The glyph loader is an internal object used to load several glyphs */
+  /*    together (for example, in the case of composites).                 */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The glyph loader implementation is not part of the high-level API, */
+  /*    hence the forward structure declaration.                           */
+  /*                                                                       */
+  typedef struct FT_GlyphLoaderRec_*  FT_GlyphLoader ;
+
+
+#if 0  /* moved to freetype.h in version 2.2 */
+#define FT_SUBGLYPH_FLAG_ARGS_ARE_WORDS          1
+#define FT_SUBGLYPH_FLAG_ARGS_ARE_XY_VALUES      2
+#define FT_SUBGLYPH_FLAG_ROUND_XY_TO_GRID        4
+#define FT_SUBGLYPH_FLAG_SCALE                   8
+#define FT_SUBGLYPH_FLAG_XY_SCALE             0x40
+#define FT_SUBGLYPH_FLAG_2X2                  0x80
+#define FT_SUBGLYPH_FLAG_USE_MY_METRICS      0x200
+#endif
+
+
+  typedef struct  FT_SubGlyphRec_
+  {
+    FT_Int     index;
+    FT_UShort  flags;
+    FT_Int     arg1;
+    FT_Int     arg2;
+    FT_Matrix  transform;
+
+  } FT_SubGlyphRec;
+
+
+  typedef struct  FT_GlyphLoadRec_
+  {
+    FT_Outline   outline;       /* outline                   */
+    FT_Vector*   extra_points;  /* extra points table        */
+    FT_Vector*   extra_points2; /* second extra points table */
+    FT_UInt      num_subglyphs; /* number of subglyphs       */
+    FT_SubGlyph  subglyphs;     /* subglyphs                 */
+
+  } FT_GlyphLoadRec, *FT_GlyphLoad;
+
+
+  typedef struct  FT_GlyphLoaderRec_
+  {
+    FT_Memory        memory;
+    FT_UInt          max_points;
+    FT_UInt          max_contours;
+    FT_UInt          max_subglyphs;
+    FT_Bool          use_extra;
+
+    FT_GlyphLoadRec  base;
+    FT_GlyphLoadRec  current;
+
+    void*            other;            /* for possible future extension? */
+
+  } FT_GlyphLoaderRec;
+
+
+  /* create new empty glyph loader */
+  FT_BASE( FT_Error )
+  FT_GlyphLoader_New( FT_Memory        memory,
+                      FT_GlyphLoader  *aloader );
+
+  /* add an extra points table to a glyph loader */
+  FT_BASE( FT_Error )
+  FT_GlyphLoader_CreateExtra( FT_GlyphLoader  loader );
+
+  /* destroy a glyph loader */
+  FT_BASE( void )
+  FT_GlyphLoader_Done( FT_GlyphLoader  loader );
+
+  /* reset a glyph loader (frees everything int it) */
+  FT_BASE( void )
+  FT_GlyphLoader_Reset( FT_GlyphLoader  loader );
+
+  /* rewind a glyph loader */
+  FT_BASE( void )
+  FT_GlyphLoader_Rewind( FT_GlyphLoader  loader );
+
+  /* check that there is enough space to add `n_points' and `n_contours' */
+  /* to the glyph loader                                                 */
+  FT_BASE( FT_Error )
+  FT_GlyphLoader_CheckPoints( FT_GlyphLoader  loader,
+                              FT_UInt         n_points,
+                              FT_UInt         n_contours );
+
+
+#define FT_GLYPHLOADER_CHECK_P( _loader, _count )                         \
+   ( (_count) == 0 || ((_loader)->base.outline.n_points    +              \
+                       (_loader)->current.outline.n_points +              \
+                       (unsigned long)(_count)) <= (_loader)->max_points )
+
+#define FT_GLYPHLOADER_CHECK_C( _loader, _count )                          \
+  ( (_count) == 0 || ((_loader)->base.outline.n_contours    +              \
+                      (_loader)->current.outline.n_contours +              \
+                      (unsigned long)(_count)) <= (_loader)->max_contours )
+
+#define FT_GLYPHLOADER_CHECK_POINTS( _loader, _points,_contours )      \
+  ( ( FT_GLYPHLOADER_CHECK_P( _loader, _points )   &&                  \
+      FT_GLYPHLOADER_CHECK_C( _loader, _contours ) )                   \
+    ? 0                                                                \
+    : FT_GlyphLoader_CheckPoints( (_loader), (_points), (_contours) ) )
+
+
+  /* check that there is enough space to add `n_subs' sub-glyphs to */
+  /* a glyph loader                                                 */
+  FT_BASE( FT_Error )
+  FT_GlyphLoader_CheckSubGlyphs( FT_GlyphLoader  loader,
+                                 FT_UInt         n_subs );
+
+  /* prepare a glyph loader, i.e. empty the current glyph */
+  FT_BASE( void )
+  FT_GlyphLoader_Prepare( FT_GlyphLoader  loader );
+
+  /* add the current glyph to the base glyph */
+  FT_BASE( void )
+  FT_GlyphLoader_Add( FT_GlyphLoader  loader );
+
+  /* copy points from one glyph loader to another */
+  FT_BASE( FT_Error )
+  FT_GlyphLoader_CopyPoints( FT_GlyphLoader  target,
+                             FT_GlyphLoader  source );
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTGLOADR_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftmemory.h b/include/freetype/internal/ftmemory.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftmemory.h
@@ -0,0 +1,380 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftmemory.h                                                             */
+/*                                                                         */
+/*    The FreeType memory management macros (specification).               */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2004, 2005, 2006, 2007, 2010 by             */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg                       */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTMEMORY_H__
+#define __FTMEMORY_H__
+
+
+#include <ft2build.h>
+#include FT_CONFIG_CONFIG_H
+#include FT_TYPES_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_SET_ERROR                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This macro is used to set an implicit `error' variable to a given  */
+  /*    expression's value (usually a function call), and convert it to a  */
+  /*    boolean which is set whenever the value is != 0.                   */
+  /*                                                                       */
+#undef  FT_SET_ERROR
+#define FT_SET_ERROR( expression ) \
+          ( ( error = (expression) ) != 0 )
+
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                           M E M O R Y                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*
+   *  C++ refuses to handle statements like p = (void*)anything, with `p' a
+   *  typed pointer.  Since we don't have a `typeof' operator in standard
+   *  C++, we have to use a template to emulate it.
+   */
+
+#ifdef __cplusplus
+
+  extern "C++"
+  template <typename T> inline T*
+  cplusplus_typeof(        T*,
+                    void  *v )
+  {
+    return static_cast <T*> ( v );
+  }
+
+#define FT_ASSIGNP( p, val )  (p) = cplusplus_typeof( (p), (val) )
+
+#else
+
+#define FT_ASSIGNP( p, val )  (p) = (val)
+
+#endif
+
+
+
+#ifdef FT_DEBUG_MEMORY
+
+  FT_BASE( const char* )  _ft_debug_file;
+  FT_BASE( long )         _ft_debug_lineno;
+
+#define FT_DEBUG_INNER( exp )  ( _ft_debug_file   = __FILE__, \
+                                 _ft_debug_lineno = __LINE__, \
+                                 (exp) )
+
+#define FT_ASSIGNP_INNER( p, exp )  ( _ft_debug_file   = __FILE__, \
+                                      _ft_debug_lineno = __LINE__, \
+                                      FT_ASSIGNP( p, exp ) )
+
+#else /* !FT_DEBUG_MEMORY */
+
+#define FT_DEBUG_INNER( exp )       (exp)
+#define FT_ASSIGNP_INNER( p, exp )  FT_ASSIGNP( p, exp )
+
+#endif /* !FT_DEBUG_MEMORY */
+
+
+  /*
+   *  The allocation functions return a pointer, and the error code
+   *  is written to through the `p_error' parameter.  See below for
+   *  for documentation.
+   */
+
+  FT_BASE( FT_Pointer )
+  ft_mem_alloc( FT_Memory  memory,
+                FT_Long    size,
+                FT_Error  *p_error );
+
+  FT_BASE( FT_Pointer )
+  ft_mem_qalloc( FT_Memory  memory,
+                 FT_Long    size,
+                 FT_Error  *p_error );
+
+  FT_BASE( FT_Pointer )
+  ft_mem_realloc( FT_Memory  memory,
+                  FT_Long    item_size,
+                  FT_Long    cur_count,
+                  FT_Long    new_count,
+                  void*      block,
+                  FT_Error  *p_error );
+
+  FT_BASE( FT_Pointer )
+  ft_mem_qrealloc( FT_Memory  memory,
+                   FT_Long    item_size,
+                   FT_Long    cur_count,
+                   FT_Long    new_count,
+                   void*      block,
+                   FT_Error  *p_error );
+
+  FT_BASE( void )
+  ft_mem_free( FT_Memory    memory,
+               const void*  P );
+
+
+#define FT_MEM_ALLOC( ptr, size )                                         \
+          FT_ASSIGNP_INNER( ptr, ft_mem_alloc( memory, (size), &error ) )
+
+#define FT_MEM_FREE( ptr )                \
+          FT_BEGIN_STMNT                  \
+            ft_mem_free( memory, (ptr) ); \
+            (ptr) = NULL;                 \
+          FT_END_STMNT
+
+#define FT_MEM_NEW( ptr )                        \
+          FT_MEM_ALLOC( ptr, sizeof ( *(ptr) ) )
+
+#define FT_MEM_REALLOC( ptr, cursz, newsz )                        \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory, 1,        \
+                                                 (cursz), (newsz), \
+                                                 (ptr), &error ) )
+
+#define FT_MEM_QALLOC( ptr, size )                                         \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qalloc( memory, (size), &error ) )
+
+#define FT_MEM_QNEW( ptr )                        \
+          FT_MEM_QALLOC( ptr, sizeof ( *(ptr) ) )
+
+#define FT_MEM_QREALLOC( ptr, cursz, newsz )                         \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory, 1,        \
+                                                  (cursz), (newsz), \
+                                                  (ptr), &error ) )
+
+#define FT_MEM_QRENEW_ARRAY( ptr, cursz, newsz )                             \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory, sizeof ( *(ptr) ), \
+                                                  (cursz), (newsz),          \
+                                                  (ptr), &error ) )
+
+#define FT_MEM_ALLOC_MULT( ptr, count, item_size )                    \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory, (item_size), \
+                                                 0, (count),          \
+                                                 NULL, &error ) )
+
+#define FT_MEM_REALLOC_MULT( ptr, oldcnt, newcnt, itmsz )            \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory, (itmsz),    \
+                                                 (oldcnt), (newcnt), \
+                                                 (ptr), &error ) )
+
+#define FT_MEM_QALLOC_MULT( ptr, count, item_size )                    \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory, (item_size), \
+                                                  0, (count),          \
+                                                  NULL, &error ) )
+
+#define FT_MEM_QREALLOC_MULT( ptr, oldcnt, newcnt, itmsz)             \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory, (itmsz),    \
+                                                  (oldcnt), (newcnt), \
+                                                  (ptr), &error ) )
+
+
+#define FT_MEM_SET_ERROR( cond )  ( (cond), error != 0 )
+
+
+#define FT_MEM_SET( dest, byte, count )     ft_memset( dest, byte, count )
+
+#define FT_MEM_COPY( dest, source, count )  ft_memcpy( dest, source, count )
+
+#define FT_MEM_MOVE( dest, source, count )  ft_memmove( dest, source, count )
+
+
+#define FT_MEM_ZERO( dest, count )  FT_MEM_SET( dest, 0, count )
+
+#define FT_ZERO( p )                FT_MEM_ZERO( p, sizeof ( *(p) ) )
+
+
+#define FT_ARRAY_ZERO( dest, count )                        \
+          FT_MEM_ZERO( dest, (count) * sizeof ( *(dest) ) )
+
+#define FT_ARRAY_COPY( dest, source, count )                        \
+          FT_MEM_COPY( dest, source, (count) * sizeof ( *(dest) ) )
+
+#define FT_ARRAY_MOVE( dest, source, count )                        \
+          FT_MEM_MOVE( dest, source, (count) * sizeof ( *(dest) ) )
+
+
+  /*
+   *  Return the maximum number of addressable elements in an array.
+   *  We limit ourselves to INT_MAX, rather than UINT_MAX, to avoid
+   *  any problems.
+   */
+#define FT_ARRAY_MAX( ptr )           ( FT_INT_MAX / sizeof ( *(ptr) ) )
+
+#define FT_ARRAY_CHECK( ptr, count )  ( (count) <= FT_ARRAY_MAX( ptr ) )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The following functions macros expect that their pointer argument is  */
+  /* _typed_ in order to automatically compute array element sizes.        */
+  /*                                                                       */
+
+#define FT_MEM_NEW_ARRAY( ptr, count )                                      \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory, sizeof ( *(ptr) ), \
+                                                 0, (count),                \
+                                                 NULL, &error ) )
+
+#define FT_MEM_RENEW_ARRAY( ptr, cursz, newsz )                             \
+          FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory, sizeof ( *(ptr) ), \
+                                                 (cursz), (newsz),          \
+                                                 (ptr), &error ) )
+
+#define FT_MEM_QNEW_ARRAY( ptr, count )                                      \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory, sizeof ( *(ptr) ), \
+                                                  0, (count),                \
+                                                  NULL, &error ) )
+
+#define FT_MEM_QRENEW_ARRAY( ptr, cursz, newsz )                             \
+          FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory, sizeof ( *(ptr) ), \
+                                                  (cursz), (newsz),          \
+                                                  (ptr), &error ) )
+
+
+#define FT_ALLOC( ptr, size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_ALLOC( ptr, size ) )
+
+#define FT_REALLOC( ptr, cursz, newsz )                           \
+          FT_MEM_SET_ERROR( FT_MEM_REALLOC( ptr, cursz, newsz ) )
+
+#define FT_ALLOC_MULT( ptr, count, item_size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_ALLOC_MULT( ptr, count, item_size ) )
+
+#define FT_REALLOC_MULT( ptr, oldcnt, newcnt, itmsz )              \
+          FT_MEM_SET_ERROR( FT_MEM_REALLOC_MULT( ptr, oldcnt,      \
+                                                 newcnt, itmsz ) )
+
+#define FT_QALLOC( ptr, size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QALLOC( ptr, size ) )
+
+#define FT_QREALLOC( ptr, cursz, newsz )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QREALLOC( ptr, cursz, newsz ) )
+
+#define FT_QALLOC_MULT( ptr, count, item_size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QALLOC_MULT( ptr, count, item_size ) )
+
+#define FT_QREALLOC_MULT( ptr, oldcnt, newcnt, itmsz )              \
+          FT_MEM_SET_ERROR( FT_MEM_QREALLOC_MULT( ptr, oldcnt,      \
+                                                  newcnt, itmsz ) )
+
+#define FT_FREE( ptr )  FT_MEM_FREE( ptr )
+
+#define FT_NEW( ptr )  FT_MEM_SET_ERROR( FT_MEM_NEW( ptr ) )
+
+#define FT_NEW_ARRAY( ptr, count )                           \
+          FT_MEM_SET_ERROR( FT_MEM_NEW_ARRAY( ptr, count ) )
+
+#define FT_RENEW_ARRAY( ptr, curcnt, newcnt )                           \
+          FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )
+
+#define FT_QNEW( ptr )                           \
+          FT_MEM_SET_ERROR( FT_MEM_QNEW( ptr ) )
+
+#define FT_QNEW_ARRAY( ptr, count )                          \
+          FT_MEM_SET_ERROR( FT_MEM_NEW_ARRAY( ptr, count ) )
+
+#define FT_QRENEW_ARRAY( ptr, curcnt, newcnt )                          \
+          FT_MEM_SET_ERROR( FT_MEM_RENEW_ARRAY( ptr, curcnt, newcnt ) )
+
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  FT_BASE( FT_Error )
+  FT_Alloc( FT_Memory  memory,
+            FT_Long    size,
+            void*     *P );
+
+  FT_BASE( FT_Error )
+  FT_QAlloc( FT_Memory  memory,
+             FT_Long    size,
+             void*     *p );
+
+  FT_BASE( FT_Error )
+  FT_Realloc( FT_Memory  memory,
+              FT_Long    current,
+              FT_Long    size,
+              void*     *P );
+
+  FT_BASE( FT_Error )
+  FT_QRealloc( FT_Memory  memory,
+               FT_Long    current,
+               FT_Long    size,
+               void*     *p );
+
+  FT_BASE( void )
+  FT_Free( FT_Memory  memory,
+           void*     *P );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  FT_BASE( FT_Pointer )
+  ft_mem_strdup( FT_Memory    memory,
+                 const char*  str,
+                 FT_Error    *p_error );
+
+  FT_BASE( FT_Pointer )
+  ft_mem_dup( FT_Memory    memory,
+              const void*  address,
+              FT_ULong     size,
+              FT_Error    *p_error );
+
+#define FT_MEM_STRDUP( dst, str )                                            \
+          (dst) = (char*)ft_mem_strdup( memory, (const char*)(str), &error )
+
+#define FT_STRDUP( dst, str )                           \
+          FT_MEM_SET_ERROR( FT_MEM_STRDUP( dst, str ) )
+
+#define FT_MEM_DUP( dst, address, size )                                    \
+          (dst) = ft_mem_dup( memory, (address), (FT_ULong)(size), &error )
+
+#define FT_DUP( dst, address, size )                           \
+          FT_MEM_SET_ERROR( FT_MEM_DUP( dst, address, size ) )
+
+
+  /* Return >= 1 if a truncation occurs.            */
+  /* Return 0 if the source string fits the buffer. */
+  /* This is *not* the same as strlcpy().           */
+  FT_BASE( FT_Int )
+  ft_mem_strcpyn( char*        dst,
+                  const char*  src,
+                  FT_ULong     size );
+
+#define FT_STRCPYN( dst, src, size )                                         \
+          ft_mem_strcpyn( (char*)dst, (const char*)(src), (FT_ULong)(size) )
+
+ /* */
+
+
+FT_END_HEADER
+
+#endif /* __FTMEMORY_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftobjs.h b/include/freetype/internal/ftobjs.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftobjs.h
@@ -0,0 +1,1573 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftobjs.h                                                               */
+/*                                                                         */
+/*    The FreeType private base classes (specification).                   */
+/*                                                                         */
+/*  Copyright 1996-2006, 2008, 2010, 2012 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*  This file contains the definition of all internal FreeType classes.  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTOBJS_H__
+#define __FTOBJS_H__
+
+#include <ft2build.h>
+#include FT_RENDER_H
+#include FT_SIZES_H
+#include FT_LCD_FILTER_H
+#include FT_INTERNAL_MEMORY_H
+#include FT_INTERNAL_GLYPH_LOADER_H
+#include FT_INTERNAL_DRIVER_H
+#include FT_INTERNAL_AUTOHINT_H
+#include FT_INTERNAL_SERVICE_H
+#include FT_INTERNAL_PIC_H
+
+#ifdef FT_CONFIG_OPTION_INCREMENTAL
+#include FT_INCREMENTAL_H
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Some generic definitions.                                             */
+  /*                                                                       */
+#ifndef TRUE
+#define TRUE  1
+#endif
+
+#ifndef FALSE
+#define FALSE  0
+#endif
+
+#ifndef NULL
+#define NULL  (void*)0
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The min and max functions missing in C.  As usual, be careful not to  */
+  /* write things like FT_MIN( a++, b++ ) to avoid side effects.           */
+  /*                                                                       */
+#define FT_MIN( a, b )  ( (a) < (b) ? (a) : (b) )
+#define FT_MAX( a, b )  ( (a) > (b) ? (a) : (b) )
+
+#define FT_ABS( a )     ( (a) < 0 ? -(a) : (a) )
+
+
+#define FT_PAD_FLOOR( x, n )  ( (x) & ~((n)-1) )
+#define FT_PAD_ROUND( x, n )  FT_PAD_FLOOR( (x) + ((n)/2), n )
+#define FT_PAD_CEIL( x, n )   FT_PAD_FLOOR( (x) + ((n)-1), n )
+
+#define FT_PIX_FLOOR( x )     ( (x) & ~63 )
+#define FT_PIX_ROUND( x )     FT_PIX_FLOOR( (x) + 32 )
+#define FT_PIX_CEIL( x )      FT_PIX_FLOOR( (x) + 63 )
+
+
+  /*
+   *  Return the highest power of 2 that is <= value; this correspond to
+   *  the highest bit in a given 32-bit value.
+   */
+  FT_BASE( FT_UInt32 )
+  ft_highpow2( FT_UInt32  value );
+
+
+  /*
+   *  character classification functions -- since these are used to parse
+   *  font files, we must not use those in <ctypes.h> which are
+   *  locale-dependent
+   */
+#define  ft_isdigit( x )   ( ( (unsigned)(x) - '0' ) < 10U )
+
+#define  ft_isxdigit( x )  ( ( (unsigned)(x) - '0' ) < 10U || \
+                             ( (unsigned)(x) - 'a' ) < 6U  || \
+                             ( (unsigned)(x) - 'A' ) < 6U  )
+
+  /* the next two macros assume ASCII representation */
+#define  ft_isupper( x )  ( ( (unsigned)(x) - 'A' ) < 26U )
+#define  ft_islower( x )  ( ( (unsigned)(x) - 'a' ) < 26U )
+
+#define  ft_isalpha( x )  ( ft_isupper( x ) || ft_islower( x ) )
+#define  ft_isalnum( x )  ( ft_isdigit( x ) || ft_isalpha( x ) )
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                       C H A R M A P S                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /* handle to internal charmap object */
+  typedef struct FT_CMapRec_*              FT_CMap;
+
+  /* handle to charmap class structure */
+  typedef const struct FT_CMap_ClassRec_*  FT_CMap_Class;
+
+  /* internal charmap object structure */
+  typedef struct  FT_CMapRec_
+  {
+    FT_CharMapRec  charmap;
+    FT_CMap_Class  clazz;
+
+  } FT_CMapRec;
+
+  /* typecase any pointer to a charmap handle */
+#define FT_CMAP( x )              ((FT_CMap)( x ))
+
+  /* obvious macros */
+#define FT_CMAP_PLATFORM_ID( x )  FT_CMAP( x )->charmap.platform_id
+#define FT_CMAP_ENCODING_ID( x )  FT_CMAP( x )->charmap.encoding_id
+#define FT_CMAP_ENCODING( x )     FT_CMAP( x )->charmap.encoding
+#define FT_CMAP_FACE( x )         FT_CMAP( x )->charmap.face
+
+
+  /* class method definitions */
+  typedef FT_Error
+  (*FT_CMap_InitFunc)( FT_CMap     cmap,
+                       FT_Pointer  init_data );
+
+  typedef void
+  (*FT_CMap_DoneFunc)( FT_CMap  cmap );
+
+  typedef FT_UInt
+  (*FT_CMap_CharIndexFunc)( FT_CMap    cmap,
+                            FT_UInt32  char_code );
+
+  typedef FT_UInt
+  (*FT_CMap_CharNextFunc)( FT_CMap     cmap,
+                           FT_UInt32  *achar_code );
+
+  typedef FT_UInt
+  (*FT_CMap_CharVarIndexFunc)( FT_CMap    cmap,
+                               FT_CMap    unicode_cmap,
+                               FT_UInt32  char_code,
+                               FT_UInt32  variant_selector );
+
+  typedef FT_Bool
+  (*FT_CMap_CharVarIsDefaultFunc)( FT_CMap    cmap,
+                                   FT_UInt32  char_code,
+                                   FT_UInt32  variant_selector );
+
+  typedef FT_UInt32 *
+  (*FT_CMap_VariantListFunc)( FT_CMap    cmap,
+                              FT_Memory  mem );
+
+  typedef FT_UInt32 *
+  (*FT_CMap_CharVariantListFunc)( FT_CMap    cmap,
+                                  FT_Memory  mem,
+                                  FT_UInt32  char_code );
+
+  typedef FT_UInt32 *
+  (*FT_CMap_VariantCharListFunc)( FT_CMap    cmap,
+                                  FT_Memory  mem,
+                                  FT_UInt32  variant_selector );
+
+
+  typedef struct  FT_CMap_ClassRec_
+  {
+    FT_ULong               size;
+    FT_CMap_InitFunc       init;
+    FT_CMap_DoneFunc       done;
+    FT_CMap_CharIndexFunc  char_index;
+    FT_CMap_CharNextFunc   char_next;
+
+    /* Subsequent entries are special ones for format 14 -- the variant */
+    /* selector subtable which behaves like no other                    */
+
+    FT_CMap_CharVarIndexFunc      char_var_index;
+    FT_CMap_CharVarIsDefaultFunc  char_var_default;
+    FT_CMap_VariantListFunc       variant_list;
+    FT_CMap_CharVariantListFunc   charvariant_list;
+    FT_CMap_VariantCharListFunc   variantchar_list;
+
+  } FT_CMap_ClassRec;
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DECLARE_CMAP_CLASS( class_ )              \
+  FT_CALLBACK_TABLE const  FT_CMap_ClassRec class_;
+
+#define FT_DEFINE_CMAP_CLASS(       \
+          class_,                   \
+          size_,                    \
+          init_,                    \
+          done_,                    \
+          char_index_,              \
+          char_next_,               \
+          char_var_index_,          \
+          char_var_default_,        \
+          variant_list_,            \
+          charvariant_list_,        \
+          variantchar_list_ )       \
+  FT_CALLBACK_TABLE_DEF             \
+  const FT_CMap_ClassRec  class_ =  \
+  {                                 \
+    size_,                          \
+    init_,                          \
+    done_,                          \
+    char_index_,                    \
+    char_next_,                     \
+    char_var_index_,                \
+    char_var_default_,              \
+    variant_list_,                  \
+    charvariant_list_,              \
+    variantchar_list_               \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DECLARE_CMAP_CLASS( class_ )                  \
+  void                                                   \
+  FT_Init_Class_ ## class_( FT_Library         library,  \
+                            FT_CMap_ClassRec*  clazz );
+
+#define FT_DEFINE_CMAP_CLASS(                            \
+          class_,                                        \
+          size_,                                         \
+          init_,                                         \
+          done_,                                         \
+          char_index_,                                   \
+          char_next_,                                    \
+          char_var_index_,                               \
+          char_var_default_,                             \
+          variant_list_,                                 \
+          charvariant_list_,                             \
+          variantchar_list_ )                            \
+  void                                                   \
+  FT_Init_Class_ ## class_( FT_Library         library,  \
+                            FT_CMap_ClassRec*  clazz )   \
+  {                                                      \
+    FT_UNUSED( library );                                \
+                                                         \
+    clazz->size             = size_;                     \
+    clazz->init             = init_;                     \
+    clazz->done             = done_;                     \
+    clazz->char_index       = char_index_;               \
+    clazz->char_next        = char_next_;                \
+    clazz->char_var_index   = char_var_index_;           \
+    clazz->char_var_default = char_var_default_;         \
+    clazz->variant_list     = variant_list_;             \
+    clazz->charvariant_list = charvariant_list_;         \
+    clazz->variantchar_list = variantchar_list_;         \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /* create a new charmap and add it to charmap->face */
+  FT_BASE( FT_Error )
+  FT_CMap_New( FT_CMap_Class  clazz,
+               FT_Pointer     init_data,
+               FT_CharMap     charmap,
+               FT_CMap       *acmap );
+
+  /* destroy a charmap and remove it from face's list */
+  FT_BASE( void )
+  FT_CMap_Done( FT_CMap  cmap );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Face_InternalRec                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure contains the internal fields of each FT_Face        */
+  /*    object.  These fields may change between different releases of     */
+  /*    FreeType.                                                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    max_points ::                                                      */
+  /*      The maximum number of points used to store the vectorial outline */
+  /*      of any glyph in this face.  If this value cannot be known in     */
+  /*      advance, or if the face isn't scalable, this should be set to 0. */
+  /*      Only relevant for scalable formats.                              */
+  /*                                                                       */
+  /*    max_contours ::                                                    */
+  /*      The maximum number of contours used to store the vectorial       */
+  /*      outline of any glyph in this face.  If this value cannot be      */
+  /*      known in advance, or if the face isn't scalable, this should be  */
+  /*      set to 0.  Only relevant for scalable formats.                   */
+  /*                                                                       */
+  /*    transform_matrix ::                                                */
+  /*      A 2x2 matrix of 16.16 coefficients used to transform glyph       */
+  /*      outlines after they are loaded from the font.  Only used by the  */
+  /*      convenience functions.                                           */
+  /*                                                                       */
+  /*    transform_delta ::                                                 */
+  /*      A translation vector used to transform glyph outlines after they */
+  /*      are loaded from the font.  Only used by the convenience          */
+  /*      functions.                                                       */
+  /*                                                                       */
+  /*    transform_flags ::                                                 */
+  /*      Some flags used to classify the transform.  Only used by the     */
+  /*      convenience functions.                                           */
+  /*                                                                       */
+  /*    services ::                                                        */
+  /*      A cache for frequently used services.  It should be only         */
+  /*      accessed with the macro `FT_FACE_LOOKUP_SERVICE'.                */
+  /*                                                                       */
+  /*    incremental_interface ::                                           */
+  /*      If non-null, the interface through which glyph data and metrics  */
+  /*      are loaded incrementally for faces that do not provide all of    */
+  /*      this data when first opened.  This field exists only if          */
+  /*      @FT_CONFIG_OPTION_INCREMENTAL is defined.                        */
+  /*                                                                       */
+  /*    ignore_unpatented_hinter ::                                        */
+  /*      This boolean flag instructs the glyph loader to ignore the       */
+  /*      native font hinter, if one is found.  This is exclusively used   */
+  /*      in the case when the unpatented hinter is compiled within the    */
+  /*      library.                                                         */
+  /*                                                                       */
+  /*    refcount ::                                                        */
+  /*      A counter initialized to~1 at the time an @FT_Face structure is  */
+  /*      created.  @FT_Reference_Face increments this counter, and        */
+  /*      @FT_Done_Face only destroys a face if the counter is~1,          */
+  /*      otherwise it simply decrements it.                               */
+  /*                                                                       */
+  typedef struct  FT_Face_InternalRec_
+  {
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    FT_UShort           reserved1;
+    FT_Short            reserved2;
+#endif
+    FT_Matrix           transform_matrix;
+    FT_Vector           transform_delta;
+    FT_Int              transform_flags;
+
+    FT_ServiceCacheRec  services;
+
+#ifdef FT_CONFIG_OPTION_INCREMENTAL
+    FT_Incremental_InterfaceRec*  incremental_interface;
+#endif
+
+    FT_Bool             ignore_unpatented_hinter;
+    FT_UInt             refcount;
+
+  } FT_Face_InternalRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Slot_InternalRec                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure contains the internal fields of each FT_GlyphSlot   */
+  /*    object.  These fields may change between different releases of     */
+  /*    FreeType.                                                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    loader            :: The glyph loader object used to load outlines */
+  /*                         into the glyph slot.                          */
+  /*                                                                       */
+  /*    flags             :: Possible values are zero or                   */
+  /*                         FT_GLYPH_OWN_BITMAP.  The latter indicates    */
+  /*                         that the FT_GlyphSlot structure owns the      */
+  /*                         bitmap buffer.                                */
+  /*                                                                       */
+  /*    glyph_transformed :: Boolean.  Set to TRUE when the loaded glyph   */
+  /*                         must be transformed through a specific        */
+  /*                         font transformation.  This is _not_ the same  */
+  /*                         as the face transform set through             */
+  /*                         FT_Set_Transform().                           */
+  /*                                                                       */
+  /*    glyph_matrix      :: The 2x2 matrix corresponding to the glyph     */
+  /*                         transformation, if necessary.                 */
+  /*                                                                       */
+  /*    glyph_delta       :: The 2d translation vector corresponding to    */
+  /*                         the glyph transformation, if necessary.       */
+  /*                                                                       */
+  /*    glyph_hints       :: Format-specific glyph hints management.       */
+  /*                                                                       */
+
+#define FT_GLYPH_OWN_BITMAP  0x1
+
+  typedef struct  FT_Slot_InternalRec_
+  {
+    FT_GlyphLoader  loader;
+    FT_UInt         flags;
+    FT_Bool         glyph_transformed;
+    FT_Matrix       glyph_matrix;
+    FT_Vector       glyph_delta;
+    void*           glyph_hints;
+
+  } FT_GlyphSlot_InternalRec;
+
+
+#if 0
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_Size_InternalRec                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure contains the internal fields of each FT_Size        */
+  /*    object.  Currently, it's empty.                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+  typedef struct  FT_Size_InternalRec_
+  {
+    /* empty */
+
+  } FT_Size_InternalRec;
+
+#endif
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                         M O D U L E S                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_ModuleRec                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A module object instance.                                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    clazz   :: A pointer to the module's class.                        */
+  /*                                                                       */
+  /*    library :: A handle to the parent library object.                  */
+  /*                                                                       */
+  /*    memory  :: A handle to the memory manager.                         */
+  /*                                                                       */
+  typedef struct  FT_ModuleRec_
+  {
+    FT_Module_Class*  clazz;
+    FT_Library        library;
+    FT_Memory         memory;
+
+  } FT_ModuleRec;
+
+
+  /* typecast an object to an FT_Module */
+#define FT_MODULE( x )          ((FT_Module)( x ))
+#define FT_MODULE_CLASS( x )    FT_MODULE( x )->clazz
+#define FT_MODULE_LIBRARY( x )  FT_MODULE( x )->library
+#define FT_MODULE_MEMORY( x )   FT_MODULE( x )->memory
+
+
+#define FT_MODULE_IS_DRIVER( x )  ( FT_MODULE_CLASS( x )->module_flags & \
+                                    FT_MODULE_FONT_DRIVER )
+
+#define FT_MODULE_IS_RENDERER( x )  ( FT_MODULE_CLASS( x )->module_flags & \
+                                      FT_MODULE_RENDERER )
+
+#define FT_MODULE_IS_HINTER( x )  ( FT_MODULE_CLASS( x )->module_flags & \
+                                    FT_MODULE_HINTER )
+
+#define FT_MODULE_IS_STYLER( x )  ( FT_MODULE_CLASS( x )->module_flags & \
+                                    FT_MODULE_STYLER )
+
+#define FT_DRIVER_IS_SCALABLE( x )  ( FT_MODULE_CLASS( x )->module_flags & \
+                                      FT_MODULE_DRIVER_SCALABLE )
+
+#define FT_DRIVER_USES_OUTLINES( x )  !( FT_MODULE_CLASS( x )->module_flags & \
+                                         FT_MODULE_DRIVER_NO_OUTLINES )
+
+#define FT_DRIVER_HAS_HINTER( x )  ( FT_MODULE_CLASS( x )->module_flags & \
+                                     FT_MODULE_DRIVER_HAS_HINTER )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Module_Interface                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Finds a module and returns its specific interface as a typeless    */
+  /*    pointer.                                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library     :: A handle to the library object.                     */
+  /*                                                                       */
+  /*    module_name :: The module's name (as an ASCII string).             */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A module-specific interface if available, 0 otherwise.             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    You should better be familiar with FreeType internals to know      */
+  /*    which module to look for, and what its interface is :-)            */
+  /*                                                                       */
+  FT_BASE( const void* )
+  FT_Get_Module_Interface( FT_Library   library,
+                           const char*  mod_name );
+
+  FT_BASE( FT_Pointer )
+  ft_module_get_service( FT_Module    module,
+                         const char*  service_id );
+
+  /* */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****   F A C E,   S I Z E   &   G L Y P H   S L O T   O B J E C T S  ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /* a few macros used to perform easy typecasts with minimal brain damage */
+
+#define FT_FACE( x )          ((FT_Face)(x))
+#define FT_SIZE( x )          ((FT_Size)(x))
+#define FT_SLOT( x )          ((FT_GlyphSlot)(x))
+
+#define FT_FACE_DRIVER( x )   FT_FACE( x )->driver
+#define FT_FACE_LIBRARY( x )  FT_FACE_DRIVER( x )->root.library
+#define FT_FACE_MEMORY( x )   FT_FACE( x )->memory
+#define FT_FACE_STREAM( x )   FT_FACE( x )->stream
+
+#define FT_SIZE_FACE( x )     FT_SIZE( x )->face
+#define FT_SLOT_FACE( x )     FT_SLOT( x )->face
+
+#define FT_FACE_SLOT( x )     FT_FACE( x )->glyph
+#define FT_FACE_SIZE( x )     FT_FACE( x )->size
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_GlyphSlot                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    It is sometimes useful to have more than one glyph slot for a      */
+  /*    given face object.  This function is used to create additional     */
+  /*    slots.  All of them are automatically discarded when the face is   */
+  /*    destroyed.                                                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face  :: A handle to a parent face object.                         */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    aslot :: A handle to a new glyph slot object.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  FT_BASE( FT_Error )
+  FT_New_GlyphSlot( FT_Face        face,
+                    FT_GlyphSlot  *aslot );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_GlyphSlot                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroys a given glyph slot.  Remember however that all slots are  */
+  /*    automatically destroyed with its parent.  Using this function is   */
+  /*    not always mandatory.                                              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    slot :: A handle to a target glyph slot.                           */
+  /*                                                                       */
+  FT_BASE( void )
+  FT_Done_GlyphSlot( FT_GlyphSlot  slot );
+
+ /* */
+
+#define FT_REQUEST_WIDTH( req )                                            \
+          ( (req)->horiResolution                                          \
+              ? (FT_Pos)( (req)->width * (req)->horiResolution + 36 ) / 72 \
+              : (req)->width )
+
+#define FT_REQUEST_HEIGHT( req )                                            \
+          ( (req)->vertResolution                                           \
+              ? (FT_Pos)( (req)->height * (req)->vertResolution + 36 ) / 72 \
+              : (req)->height )
+
+
+  /* Set the metrics according to a bitmap strike. */
+  FT_BASE( void )
+  FT_Select_Metrics( FT_Face   face,
+                     FT_ULong  strike_index );
+
+
+  /* Set the metrics according to a size request. */
+  FT_BASE( void )
+  FT_Request_Metrics( FT_Face          face,
+                      FT_Size_Request  req );
+
+
+  /* Match a size request against `available_sizes'. */
+  FT_BASE( FT_Error )
+  FT_Match_Size( FT_Face          face,
+                 FT_Size_Request  req,
+                 FT_Bool          ignore_width,
+                 FT_ULong*        size_index );
+
+
+  /* Use the horizontal metrics to synthesize the vertical metrics. */
+  /* If `advance' is zero, it is also synthesized.                  */
+  FT_BASE( void )
+  ft_synthesize_vertical_metrics( FT_Glyph_Metrics*  metrics,
+                                  FT_Pos             advance );
+
+
+  /* Free the bitmap of a given glyphslot when needed (i.e., only when it */
+  /* was allocated with ft_glyphslot_alloc_bitmap).                       */
+  FT_BASE( void )
+  ft_glyphslot_free_bitmap( FT_GlyphSlot  slot );
+
+
+  /* Allocate a new bitmap buffer in a glyph slot. */
+  FT_BASE( FT_Error )
+  ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,
+                             FT_ULong      size );
+
+
+  /* Set the bitmap buffer in a glyph slot to a given pointer.  The buffer */
+  /* will not be freed by a later call to ft_glyphslot_free_bitmap.        */
+  FT_BASE( void )
+  ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,
+                           FT_Byte*      buffer );
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                        R E N D E R E R S                        ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+#define FT_RENDERER( x )      ((FT_Renderer)( x ))
+#define FT_GLYPH( x )         ((FT_Glyph)( x ))
+#define FT_BITMAP_GLYPH( x )  ((FT_BitmapGlyph)( x ))
+#define FT_OUTLINE_GLYPH( x ) ((FT_OutlineGlyph)( x ))
+
+
+  typedef struct  FT_RendererRec_
+  {
+    FT_ModuleRec            root;
+    FT_Renderer_Class*      clazz;
+    FT_Glyph_Format         glyph_format;
+    FT_Glyph_Class          glyph_class;
+
+    FT_Raster               raster;
+    FT_Raster_Render_Func   raster_render;
+    FT_Renderer_RenderFunc  render;
+
+  } FT_RendererRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                    F O N T   D R I V E R S                      ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* typecast a module into a driver easily */
+#define FT_DRIVER( x )        ((FT_Driver)(x))
+
+  /* typecast a module as a driver, and get its driver class */
+#define FT_DRIVER_CLASS( x )  FT_DRIVER( x )->clazz
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_DriverRec                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The root font driver class.  A font driver is responsible for      */
+  /*    managing and loading font files of a given format.                 */
+  /*                                                                       */
+  /*  <Fields>                                                             */
+  /*     root         :: Contains the fields of the root module class.     */
+  /*                                                                       */
+  /*     clazz        :: A pointer to the font driver's class.  Note that  */
+  /*                     this is NOT root.clazz.  `class' wasn't used      */
+  /*                     as it is a reserved word in C++.                  */
+  /*                                                                       */
+  /*     faces_list   :: The list of faces currently opened by this        */
+  /*                     driver.                                           */
+  /*                                                                       */
+  /*     glyph_loader :: The glyph loader for all faces managed by this    */
+  /*                     driver.  This object isn't defined for unscalable */
+  /*                     formats.                                          */
+  /*                                                                       */
+  typedef struct  FT_DriverRec_
+  {
+    FT_ModuleRec     root;
+    FT_Driver_Class  clazz;
+    FT_ListRec       faces_list;
+    FT_GlyphLoader   glyph_loader;
+
+  } FT_DriverRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                       L I B R A R I E S                         ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* This hook is used by the TrueType debugger.  It must be set to an */
+  /* alternate truetype bytecode interpreter function.                 */
+#define FT_DEBUG_HOOK_TRUETYPE            0
+
+
+  /* Set this debug hook to a non-null pointer to force unpatented hinting */
+  /* for all faces when both TT_USE_BYTECODE_INTERPRETER and               */
+  /* TT_CONFIG_OPTION_UNPATENTED_HINTING are defined.  This is only used   */
+  /* during debugging.                                                     */
+#define FT_DEBUG_HOOK_UNPATENTED_HINTING  1
+
+
+  typedef void  (*FT_Bitmap_LcdFilterFunc)( FT_Bitmap*      bitmap,
+                                            FT_Render_Mode  render_mode,
+                                            FT_Library      library );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    FT_LibraryRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The FreeType library class.  This is the root of all FreeType      */
+  /*    data.  Use FT_New_Library() to create a library object, and        */
+  /*    FT_Done_Library() to discard it and all child objects.             */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    memory           :: The library's memory object.  Manages memory   */
+  /*                        allocation.                                    */
+  /*                                                                       */
+  /*    version_major    :: The major version number of the library.       */
+  /*                                                                       */
+  /*    version_minor    :: The minor version number of the library.       */
+  /*                                                                       */
+  /*    version_patch    :: The current patch level of the library.        */
+  /*                                                                       */
+  /*    num_modules      :: The number of modules currently registered     */
+  /*                        within this library.  This is set to 0 for new */
+  /*                        libraries.  New modules are added through the  */
+  /*                        FT_Add_Module() API function.                  */
+  /*                                                                       */
+  /*    modules          :: A table used to store handles to the currently */
+  /*                        registered modules. Note that each font driver */
+  /*                        contains a list of its opened faces.           */
+  /*                                                                       */
+  /*    renderers        :: The list of renderers currently registered     */
+  /*                        within the library.                            */
+  /*                                                                       */
+  /*    cur_renderer     :: The current outline renderer.  This is a       */
+  /*                        shortcut used to avoid parsing the list on     */
+  /*                        each call to FT_Outline_Render().  It is a     */
+  /*                        handle to the current renderer for the         */
+  /*                        FT_GLYPH_FORMAT_OUTLINE format.                */
+  /*                                                                       */
+  /*    auto_hinter      :: XXX                                            */
+  /*                                                                       */
+  /*    raster_pool      :: The raster object's render pool.  This can     */
+  /*                        ideally be changed dynamically at run-time.    */
+  /*                                                                       */
+  /*    raster_pool_size :: The size of the render pool in bytes.          */
+  /*                                                                       */
+  /*    debug_hooks      :: XXX                                            */
+  /*                                                                       */
+  /*    lcd_filter       :: If subpixel rendering is activated, the        */
+  /*                        selected LCD filter mode.                      */
+  /*                                                                       */
+  /*    lcd_extra        :: If subpixel rendering is activated, the number */
+  /*                        of extra pixels needed for the LCD filter.     */
+  /*                                                                       */
+  /*    lcd_weights      :: If subpixel rendering is activated, the LCD    */
+  /*                        filter weights, if any.                        */
+  /*                                                                       */
+  /*    lcd_filter_func  :: If subpixel rendering is activated, the LCD    */
+  /*                        filtering callback function.                   */
+  /*                                                                       */
+  /*    pic_container    :: Contains global structs and tables, instead    */
+  /*                        of defining them globallly.                    */
+  /*                                                                       */
+  /*    refcount         :: A counter initialized to~1 at the time an      */
+  /*                        @FT_Library structure is created.              */
+  /*                        @FT_Reference_Library increments this counter, */
+  /*                        and @FT_Done_Library only destroys a library   */
+  /*                        if the counter is~1, otherwise it simply       */
+  /*                        decrements it.                                 */
+  /*                                                                       */
+  typedef struct  FT_LibraryRec_
+  {
+    FT_Memory          memory;           /* library's memory manager */
+
+    FT_Int             version_major;
+    FT_Int             version_minor;
+    FT_Int             version_patch;
+
+    FT_UInt            num_modules;
+    FT_Module          modules[FT_MAX_MODULES];  /* module objects  */
+
+    FT_ListRec         renderers;        /* list of renderers        */
+    FT_Renderer        cur_renderer;     /* current outline renderer */
+    FT_Module          auto_hinter;
+
+    FT_Byte*           raster_pool;      /* scan-line conversion */
+                                         /* render pool          */
+    FT_ULong           raster_pool_size; /* size of render pool in bytes */
+
+    FT_DebugHook_Func  debug_hooks[4];
+
+#ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
+    FT_LcdFilter             lcd_filter;
+    FT_Int                   lcd_extra;        /* number of extra pixels */
+    FT_Byte                  lcd_weights[7];   /* filter weights, if any */
+    FT_Bitmap_LcdFilterFunc  lcd_filter_func;  /* filtering callback     */
+#endif
+
+#ifdef FT_CONFIG_OPTION_PIC
+    FT_PIC_Container   pic_container;
+#endif
+
+    FT_UInt            refcount;
+
+  } FT_LibraryRec;
+
+
+  FT_BASE( FT_Renderer )
+  FT_Lookup_Renderer( FT_Library       library,
+                      FT_Glyph_Format  format,
+                      FT_ListNode*     node );
+
+  FT_BASE( FT_Error )
+  FT_Render_Glyph_Internal( FT_Library      library,
+                            FT_GlyphSlot    slot,
+                            FT_Render_Mode  render_mode );
+
+  typedef const char*
+  (*FT_Face_GetPostscriptNameFunc)( FT_Face  face );
+
+  typedef FT_Error
+  (*FT_Face_GetGlyphNameFunc)( FT_Face     face,
+                               FT_UInt     glyph_index,
+                               FT_Pointer  buffer,
+                               FT_UInt     buffer_max );
+
+  typedef FT_UInt
+  (*FT_Face_GetGlyphNameIndexFunc)( FT_Face     face,
+                                    FT_String*  glyph_name );
+
+
+#ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_New_Memory                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Creates a new memory object.                                       */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A pointer to the new memory object.  0 in case of error.           */
+  /*                                                                       */
+  FT_BASE( FT_Memory )
+  FT_New_Memory( void );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Done_Memory                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Discards memory manager.                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory :: A handle to the memory manager.                          */
+  /*                                                                       */
+  FT_BASE( void )
+  FT_Done_Memory( FT_Memory  memory );
+
+#endif /* !FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM */
+
+
+  /* Define default raster's interface.  The default raster is located in  */
+  /* `src/base/ftraster.c'.                                                */
+  /*                                                                       */
+  /* Client applications can register new rasters through the              */
+  /* FT_Set_Raster() API.                                                  */
+
+#ifndef FT_NO_DEFAULT_RASTER
+  FT_EXPORT_VAR( FT_Raster_Funcs )  ft_default_raster;
+#endif
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                      P I C   S U P P O R T                      ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* PIC support macros for ftimage.h */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_OUTLINE_FUNCS                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of FT_Outline_Funcs struct.         */
+  /*    When FT_CONFIG_OPTION_PIC is defined an init funtion will need to  */
+  /*    be called with a pre-allocated structure to be filled.             */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
+  /*    allocated in the global scope (or the scope where the macro        */
+  /*    is used).                                                          */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_OUTLINE_FUNCS(           \
+          class_,                          \
+          move_to_,                        \
+          line_to_,                        \
+          conic_to_,                       \
+          cubic_to_,                       \
+          shift_,                          \
+          delta_ )                         \
+  static const  FT_Outline_Funcs class_ =  \
+  {                                        \
+    move_to_,                              \
+    line_to_,                              \
+    conic_to_,                             \
+    cubic_to_,                             \
+    shift_,                                \
+    delta_                                 \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_OUTLINE_FUNCS(                     \
+          class_,                                    \
+          move_to_,                                  \
+          line_to_,                                  \
+          conic_to_,                                 \
+          cubic_to_,                                 \
+          shift_,                                    \
+          delta_ )                                   \
+  static FT_Error                                    \
+  Init_Class_ ## class_( FT_Outline_Funcs*  clazz )  \
+  {                                                  \
+    clazz->move_to  = move_to_;                      \
+    clazz->line_to  = line_to_;                      \
+    clazz->conic_to = conic_to_;                     \
+    clazz->cubic_to = cubic_to_;                     \
+    clazz->shift    = shift_;                        \
+    clazz->delta    = delta_;                        \
+                                                     \
+    return FT_Err_Ok;                                \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_RASTER_FUNCS                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of FT_Raster_Funcs struct.          */
+  /*    When FT_CONFIG_OPTION_PIC is defined an init funtion will need to  */
+  /*    be called with a pre-allocated structure to be filled.             */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
+  /*    allocated in the global scope (or the scope where the macro        */
+  /*    is used).                                                          */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_RASTER_FUNCS(    \
+          class_,                  \
+          glyph_format_,           \
+          raster_new_,             \
+          raster_reset_,           \
+          raster_set_mode_,        \
+          raster_render_,          \
+          raster_done_ )           \
+  const FT_Raster_Funcs  class_ =  \
+  {                                \
+    glyph_format_,                 \
+    raster_new_,                   \
+    raster_reset_,                 \
+    raster_set_mode_,              \
+    raster_render_,                \
+    raster_done_                   \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_RASTER_FUNCS(                        \
+          class_,                                      \
+          glyph_format_,                               \
+          raster_new_,                                 \
+          raster_reset_,                               \
+          raster_set_mode_,                            \
+          raster_render_,                              \
+          raster_done_ )                               \
+  void                                                 \
+  FT_Init_Class_ ## class_( FT_Raster_Funcs*  clazz )  \
+  {                                                    \
+    clazz->glyph_format    = glyph_format_;            \
+    clazz->raster_new      = raster_new_;              \
+    clazz->raster_reset    = raster_reset_;            \
+    clazz->raster_set_mode = raster_set_mode_;         \
+    clazz->raster_render   = raster_render_;           \
+    clazz->raster_done     = raster_done_;             \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /* PIC support macros for ftrender.h */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_GLYPH                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of FT_Glyph_Class struct.           */
+  /*    When FT_CONFIG_OPTION_PIC is defined an init funtion will need to  */
+  /*    be called with a pre-allocated stcture to be filled.               */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
+  /*    allocated in the global scope (or the scope where the macro        */
+  /*    is used).                                                          */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_GLYPH(          \
+          class_,                 \
+          size_,                  \
+          format_,                \
+          init_,                  \
+          done_,                  \
+          copy_,                  \
+          transform_,             \
+          bbox_,                  \
+          prepare_ )              \
+  FT_CALLBACK_TABLE_DEF           \
+  const FT_Glyph_Class  class_ =  \
+  {                               \
+    size_,                        \
+    format_,                      \
+    init_,                        \
+    done_,                        \
+    copy_,                        \
+    transform_,                   \
+    bbox_,                        \
+    prepare_                      \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_GLYPH(                              \
+          class_,                                     \
+          size_,                                      \
+          format_,                                    \
+          init_,                                      \
+          done_,                                      \
+          copy_,                                      \
+          transform_,                                 \
+          bbox_,                                      \
+          prepare_ )                                  \
+  void                                                \
+  FT_Init_Class_ ## class_( FT_Glyph_Class*  clazz )  \
+  {                                                   \
+    clazz->glyph_size      = size_;                   \
+    clazz->glyph_format    = format_;                 \
+    clazz->glyph_init      = init_;                   \
+    clazz->glyph_done      = done_;                   \
+    clazz->glyph_copy      = copy_;                   \
+    clazz->glyph_transform = transform_;              \
+    clazz->glyph_bbox      = bbox_;                   \
+    clazz->glyph_prepare   = prepare_;                \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DECLARE_RENDERER                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to create a forward declaration of a                          */
+  /*    FT_Renderer_Class struct instance.                                 */
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_RENDERER                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of FT_Renderer_Class struct.        */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is defined a `create' funtion will need  */
+  /*    to be called with a pointer where the allocated structure is       */
+  /*    returned.  And when it is no longer needed a `destroy' function    */
+  /*    needs to be called to release that allocation.                     */
+  /*    `fcinit.c' (ft_create_default_module_classes) already contains     */
+  /*    a mechanism to call these functions for the default modules        */
+  /*    described in `ftmodule.h'.                                         */
+  /*                                                                       */
+  /*    Notice that the created `create' and `destroy' functions call      */
+  /*    `pic_init' and `pic_free' to allow you to manually allocate and    */
+  /*    initialize any additional global data, like a module specific      */
+  /*    interface, and put them in the global pic container defined in     */
+  /*    `ftpic.h'.  If you don't need them just implement the functions as */
+  /*    empty to resolve the link error.  Also the `pic_init' and          */
+  /*    `pic_free' functions should be declared in `pic.h', to be referred */
+  /*    by the renderer definition calling `FT_DEFINE_RENDERER' in the     */
+  /*    following.                                                         */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
+  /*    allocated in the global scope (or the scope where the macro        */
+  /*    is used).                                                          */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DECLARE_RENDERER( class_ )               \
+  FT_EXPORT_VAR( const FT_Renderer_Class ) class_;
+
+#define FT_DEFINE_RENDERER(                  \
+          class_,                            \
+          flags_,                            \
+          size_,                             \
+          name_,                             \
+          version_,                          \
+          requires_,                         \
+          interface_,                        \
+          init_,                             \
+          done_,                             \
+          get_interface_,                    \
+          glyph_format_,                     \
+          render_glyph_,                     \
+          transform_glyph_,                  \
+          get_glyph_cbox_,                   \
+          set_mode_,                         \
+          raster_class_ )                    \
+  FT_CALLBACK_TABLE_DEF                      \
+  const FT_Renderer_Class  class_ =          \
+  {                                          \
+    FT_DEFINE_ROOT_MODULE( flags_,           \
+                           size_,            \
+                           name_,            \
+                           version_,         \
+                           requires_,        \
+                           interface_,       \
+                           init_,            \
+                           done_,            \
+                           get_interface_ )  \
+    glyph_format_,                           \
+                                             \
+    render_glyph_,                           \
+    transform_glyph_,                        \
+    get_glyph_cbox_,                         \
+    set_mode_,                               \
+                                             \
+    raster_class_                            \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DECLARE_RENDERER( class_ )  FT_DECLARE_MODULE( class_ )
+
+#define FT_DEFINE_RENDERER(                                      \
+          class_,                                                \
+          flags_,                                                \
+          size_,                                                 \
+          name_,                                                 \
+          version_,                                              \
+          requires_,                                             \
+          interface_,                                            \
+          init_,                                                 \
+          done_,                                                 \
+          get_interface_,                                        \
+          glyph_format_,                                         \
+          render_glyph_,                                         \
+          transform_glyph_,                                      \
+          get_glyph_cbox_,                                       \
+          set_mode_,                                             \
+          raster_class_ )                                        \
+  void                                                           \
+  FT_Destroy_Class_ ## class_( FT_Library        library,        \
+                               FT_Module_Class*  clazz )         \
+  {                                                              \
+    FT_Renderer_Class*  rclazz = (FT_Renderer_Class*)clazz;      \
+    FT_Memory           memory = library->memory;                \
+                                                                 \
+                                                                 \
+    class_ ## _pic_free( library );                              \
+    if ( rclazz )                                                \
+      FT_FREE( rclazz );                                         \
+  }                                                              \
+                                                                 \
+                                                                 \
+  FT_Error                                                       \
+  FT_Create_Class_ ## class_( FT_Library         library,        \
+                              FT_Module_Class**  output_class )  \
+  {                                                              \
+    FT_Renderer_Class*  clazz = NULL;                            \
+    FT_Error            error;                                   \
+    FT_Memory           memory = library->memory;                \
+                                                                 \
+                                                                 \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) ) )                  \
+      return error;                                              \
+                                                                 \
+    error = class_ ## _pic_init( library );                      \
+    if ( error )                                                 \
+    {                                                            \
+      FT_FREE( clazz );                                          \
+      return error;                                              \
+    }                                                            \
+                                                                 \
+    FT_DEFINE_ROOT_MODULE( flags_,                               \
+                           size_,                                \
+                           name_,                                \
+                           version_,                             \
+                           requires_,                            \
+                           interface_,                           \
+                           init_,                                \
+                           done_,                                \
+                           get_interface_ )                      \
+                                                                 \
+    clazz->glyph_format    = glyph_format_;                      \
+                                                                 \
+    clazz->render_glyph    = render_glyph_;                      \
+    clazz->transform_glyph = transform_glyph_;                   \
+    clazz->get_glyph_cbox  = get_glyph_cbox_;                    \
+    clazz->set_mode        = set_mode_;                          \
+                                                                 \
+    clazz->raster_class    = raster_class_;                      \
+                                                                 \
+    *output_class = (FT_Module_Class*)clazz;                     \
+                                                                 \
+    return FT_Err_Ok;                                            \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /* PIC support macros for ftmodapi.h **/
+
+
+#ifdef FT_CONFIG_OPTION_PIC
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Module_Creator                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to create (allocate) a new module class object.    */
+  /*    The object's members are initialized, but the module itself is     */
+  /*    not.                                                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory       :: A handle to the memory manager.                    */
+  /*    output_class :: Initialized with the newly allocated class.        */
+  /*                                                                       */
+  typedef FT_Error
+  (*FT_Module_Creator)( FT_Memory          memory,
+                        FT_Module_Class**  output_class );
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    FT_Module_Destroyer                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A function used to destroy (deallocate) a module class object.     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory :: A handle to the memory manager.                          */
+  /*    clazz  :: Module class to destroy.                                 */
+  /*                                                                       */
+  typedef void
+  (*FT_Module_Destroyer)( FT_Memory         memory,
+                          FT_Module_Class*  clazz );
+
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DECLARE_MODULE                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to create a forward declaration of a                          */
+  /*    FT_Module_Class struct instance.                                   */
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_MODULE                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of an FT_Module_Class struct.       */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is defined a `create' funtion needs to   */
+  /*    be called with a pointer where the allocated structure is          */
+  /*    returned.  And when it is no longer needed a `destroy' function    */
+  /*    needs to be called to release that allocation.                     */
+  /*    `fcinit.c' (ft_create_default_module_classes) already contains     */
+  /*    a mechanism to call these functions for the default modules        */
+  /*    described in `ftmodule.h'.                                         */
+  /*                                                                       */
+  /*    Notice that the created `create' and `destroy' functions call      */
+  /*    `pic_init' and `pic_free' to allow you to manually allocate and    */
+  /*    initialize any additional global data, like a module specific      */
+  /*    interface, and put them in the global pic container defined in     */
+  /*    `ftpic.h'.  If you don't need them just implement the functions as */
+  /*    empty to resolve the link error.  Also the `pic_init' and          */
+  /*    `pic_free' functions should be declared in `pic.h', to be referred */
+  /*    by the module definition calling `FT_DEFINE_MODULE' in the         */
+  /*    following.                                                         */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
+  /*    allocated in the global scope (or the scope where the macro        */
+  /*    is used).                                                          */
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_ROOT_MODULE                                              */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an instance of an FT_Module_Class struct inside */
+  /*    another struct that contains it or in a function that initializes  */
+  /*    that containing struct.                                            */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DECLARE_MODULE( class_ )  \
+  FT_CALLBACK_TABLE                  \
+  const FT_Module_Class  class_;
+
+#define FT_DEFINE_ROOT_MODULE(  \
+          flags_,               \
+          size_,                \
+          name_,                \
+          version_,             \
+          requires_,            \
+          interface_,           \
+          init_,                \
+          done_,                \
+          get_interface_ )      \
+  {                             \
+    flags_,                     \
+    size_,                      \
+                                \
+    name_,                      \
+    version_,                   \
+    requires_,                  \
+                                \
+    interface_,                 \
+                                \
+    init_,                      \
+    done_,                      \
+    get_interface_,             \
+  },
+
+#define FT_DEFINE_MODULE(         \
+          class_,                 \
+          flags_,                 \
+          size_,                  \
+          name_,                  \
+          version_,               \
+          requires_,              \
+          interface_,             \
+          init_,                  \
+          done_,                  \
+          get_interface_ )        \
+  FT_CALLBACK_TABLE_DEF           \
+  const FT_Module_Class class_ =  \
+  {                               \
+    flags_,                       \
+    size_,                        \
+                                  \
+    name_,                        \
+    version_,                     \
+    requires_,                    \
+                                  \
+    interface_,                   \
+                                  \
+    init_,                        \
+    done_,                        \
+    get_interface_,               \
+  };
+
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DECLARE_MODULE( class_ )                               \
+  FT_Error                                                        \
+  FT_Create_Class_ ## class_( FT_Library         library,         \
+                              FT_Module_Class**  output_class );  \
+  void                                                            \
+  FT_Destroy_Class_ ## class_( FT_Library        library,         \
+                               FT_Module_Class*  clazz );
+
+#define FT_DEFINE_ROOT_MODULE(                      \
+          flags_,                                   \
+          size_,                                    \
+          name_,                                    \
+          version_,                                 \
+          requires_,                                \
+          interface_,                               \
+          init_,                                    \
+          done_,                                    \
+          get_interface_ )                          \
+    clazz->root.module_flags     = flags_;          \
+    clazz->root.module_size      = size_;           \
+    clazz->root.module_name      = name_;           \
+    clazz->root.module_version   = version_;        \
+    clazz->root.module_requires  = requires_;       \
+                                                    \
+    clazz->root.module_interface = interface_;      \
+                                                    \
+    clazz->root.module_init      = init_;           \
+    clazz->root.module_done      = done_;           \
+    clazz->root.get_interface    = get_interface_;
+
+#define FT_DEFINE_MODULE(                                        \
+          class_,                                                \
+          flags_,                                                \
+          size_,                                                 \
+          name_,                                                 \
+          version_,                                              \
+          requires_,                                             \
+          interface_,                                            \
+          init_,                                                 \
+          done_,                                                 \
+          get_interface_ )                                       \
+  void                                                           \
+  FT_Destroy_Class_ ## class_( FT_Library        library,        \
+                               FT_Module_Class*  clazz )         \
+  {                                                              \
+    FT_Memory memory = library->memory;                          \
+                                                                 \
+                                                                 \
+    class_ ## _pic_free( library );                              \
+    if ( clazz )                                                 \
+      FT_FREE( clazz );                                          \
+  }                                                              \
+                                                                 \
+                                                                 \
+  FT_Error                                                       \
+  FT_Create_Class_ ## class_( FT_Library         library,        \
+                              FT_Module_Class**  output_class )  \
+  {                                                              \
+    FT_Memory         memory = library->memory;                  \
+    FT_Module_Class*  clazz  = NULL;                             \
+    FT_Error          error;                                     \
+                                                                 \
+                                                                 \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) ) )                  \
+      return error;                                              \
+    error = class_ ## _pic_init( library );                      \
+    if ( error )                                                 \
+    {                                                            \
+      FT_FREE( clazz );                                          \
+      return error;                                              \
+    }                                                            \
+                                                                 \
+    clazz->module_flags     = flags_;                            \
+    clazz->module_size      = size_;                             \
+    clazz->module_name      = name_;                             \
+    clazz->module_version   = version_;                          \
+    clazz->module_requires  = requires_;                         \
+                                                                 \
+    clazz->module_interface = interface_;                        \
+                                                                 \
+    clazz->module_init      = init_;                             \
+    clazz->module_done      = done_;                             \
+    clazz->get_interface    = get_interface_;                    \
+                                                                 \
+    *output_class = clazz;                                       \
+                                                                 \
+    return FT_Err_Ok;                                            \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+FT_END_HEADER
+
+#endif /* __FTOBJS_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftpic.h b/include/freetype/internal/ftpic.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftpic.h
@@ -0,0 +1,71 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftpic.h                                                                */
+/*                                                                         */
+/*    The FreeType position independent code services (declaration).       */
+/*                                                                         */
+/*  Copyright 2009, 2012 by                                                */
+/*  Oran Agra and Mickey Gabel.                                            */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*  Modules that ordinarily have const global data that need address     */
+  /*  can instead define pointers here.                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTPIC_H__
+#define __FTPIC_H__
+
+
+FT_BEGIN_HEADER
+
+#ifdef FT_CONFIG_OPTION_PIC
+
+  typedef struct  FT_PIC_Container_
+  {
+    /* pic containers for base */
+    void*  base;
+
+    /* pic containers for modules */
+    void*  autofit;
+    void*  cff;
+    void*  pshinter;
+    void*  psnames;
+    void*  raster;
+    void*  sfnt;
+    void*  smooth;
+    void*  truetype;
+
+  } FT_PIC_Container;
+
+
+  /* Initialize the various function tables, structs, etc. */
+  /* stored in the container.                              */
+  FT_BASE( FT_Error )
+  ft_pic_container_init( FT_Library  library );
+
+
+  /* Destroy the contents of the container. */
+  FT_BASE( void )
+  ft_pic_container_destroy( FT_Library  library );
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTPIC_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftrfork.h b/include/freetype/internal/ftrfork.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftrfork.h
@@ -0,0 +1,258 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftrfork.h                                                              */
+/*                                                                         */
+/*    Embedded resource forks accessor (specification).                    */
+/*                                                                         */
+/*  Copyright 2004, 2006, 2007, 2012 by                                    */
+/*  Masatake YAMATO and Redhat K.K.                                        */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+/***************************************************************************/
+/* Development of the code in this file is support of                      */
+/* Information-technology Promotion Agency, Japan.                         */
+/***************************************************************************/
+
+
+#ifndef __FTRFORK_H__
+#define __FTRFORK_H__
+
+
+#include <ft2build.h>
+#include FT_INTERNAL_OBJECTS_H
+
+
+FT_BEGIN_HEADER
+
+
+  /* Number of guessing rules supported in `FT_Raccess_Guess'.            */
+  /* Don't forget to increment the number if you add a new guessing rule. */
+#define FT_RACCESS_N_RULES  9
+
+
+  /* A structure to describe a reference in a resource by its resource ID */
+  /* and internal offset.  The `POST' resource expects to be concatenated */
+  /* by the order of resource IDs instead of its appearance in the file.  */
+
+  typedef struct  FT_RFork_Ref_
+  {
+    FT_UShort  res_id;
+    FT_ULong   offset;
+
+  } FT_RFork_Ref;
+
+#ifdef FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
+  typedef FT_Error
+  (*ft_raccess_guess_func)( FT_Library  library,
+                            FT_Stream   stream,
+                            char       *base_file_name,
+                            char      **result_file_name,
+                            FT_Long    *result_offset );
+
+  typedef enum  FT_RFork_Rule_ {
+    FT_RFork_Rule_invalid = -2,
+    FT_RFork_Rule_uknown, /* -1 */
+    FT_RFork_Rule_apple_double,
+    FT_RFork_Rule_apple_single,
+    FT_RFork_Rule_darwin_ufs_export,
+    FT_RFork_Rule_darwin_newvfs,
+    FT_RFork_Rule_darwin_hfsplus,
+    FT_RFork_Rule_vfat,
+    FT_RFork_Rule_linux_cap,
+    FT_RFork_Rule_linux_double,
+    FT_RFork_Rule_linux_netatalk
+  } FT_RFork_Rule;
+
+  /* For fast translation between rule index and rule type,
+   * the macros FT_RFORK_xxx should be kept consistent with
+   * the raccess_guess_funcs table
+   */
+  typedef struct ft_raccess_guess_rec_ {
+    ft_raccess_guess_func  func;
+    FT_RFork_Rule          type;
+  } ft_raccess_guess_rec;
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+  /* this array is a storage in non-PIC mode, so ; is needed in END */
+#define CONST_FT_RFORK_RULE_ARRAY_BEGIN( name, type )  \
+          const type name[] = {
+#define CONST_FT_RFORK_RULE_ARRAY_ENTRY( func_suffix, type_suffix )  \
+          { raccess_guess_ ## func_suffix,                           \
+            FT_RFork_Rule_ ## type_suffix },
+#define CONST_FT_RFORK_RULE_ARRAY_END  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+  /* this array is a function in PIC mode, so no ; is needed in END */
+#define CONST_FT_RFORK_RULE_ARRAY_BEGIN( name, type )  \
+          void                                         \
+          FT_Init_ ## name( type*  storage )           \
+          {                                            \
+            type*  local = storage;                    \
+                                                       \
+                                                       \
+            int  i = 0;
+#define CONST_FT_RFORK_RULE_ARRAY_ENTRY( func_suffix, type_suffix )  \
+          local[i].func = raccess_guess_ ## func_suffix;             \
+          local[i].type = FT_RFork_Rule_ ## type_suffix;             \
+          i++;
+#define CONST_FT_RFORK_RULE_ARRAY_END  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+#endif /* FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Raccess_Guess                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Guess a file name and offset where the actual resource fork is     */
+  /*    stored.  The macro FT_RACCESS_N_RULES holds the number of          */
+  /*    guessing rules;  the guessed result for the Nth rule is            */
+  /*    represented as a triplet: a new file name (new_names[N]), a file   */
+  /*    offset (offsets[N]), and an error code (errors[N]).                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library ::                                                         */
+  /*      A FreeType library instance.                                     */
+  /*                                                                       */
+  /*    stream ::                                                          */
+  /*      A file stream containing the resource fork.                      */
+  /*                                                                       */
+  /*    base_name ::                                                       */
+  /*      The (base) file name of the resource fork used for some          */
+  /*      guessing rules.                                                  */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    new_names ::                                                       */
+  /*      An array of guessed file names in which the resource forks may   */
+  /*      exist.  If `new_names[N]' is NULL, the guessed file name is      */
+  /*      equal to `base_name'.                                            */
+  /*                                                                       */
+  /*    offsets ::                                                         */
+  /*      An array of guessed file offsets.  `offsets[N]' holds the file   */
+  /*      offset of the possible start of the resource fork in file        */
+  /*      `new_names[N]'.                                                  */
+  /*                                                                       */
+  /*    errors ::                                                          */
+  /*      An array of FreeType error codes.  `errors[N]' is the error      */
+  /*      code of Nth guessing rule function.  If `errors[N]' is not       */
+  /*      FT_Err_Ok, `new_names[N]' and `offsets[N]' are meaningless.      */
+  /*                                                                       */
+  FT_BASE( void )
+  FT_Raccess_Guess( FT_Library  library,
+                    FT_Stream   stream,
+                    char*       base_name,
+                    char**      new_names,
+                    FT_Long*    offsets,
+                    FT_Error*   errors );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Raccess_Get_HeaderInfo                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Get the information from the header of resource fork.  The         */
+  /*    information includes the file offset where the resource map        */
+  /*    starts, and the file offset where the resource data starts.        */
+  /*    `FT_Raccess_Get_DataOffsets' requires these two data.              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library ::                                                         */
+  /*      A FreeType library instance.                                     */
+  /*                                                                       */
+  /*    stream ::                                                          */
+  /*      A file stream containing the resource fork.                      */
+  /*                                                                       */
+  /*    rfork_offset ::                                                    */
+  /*      The file offset where the resource fork starts.                  */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    map_offset ::                                                      */
+  /*      The file offset where the resource map starts.                   */
+  /*                                                                       */
+  /*    rdata_pos ::                                                       */
+  /*      The file offset where the resource data starts.                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  FT_Err_Ok means success.                     */
+  /*                                                                       */
+  FT_BASE( FT_Error )
+  FT_Raccess_Get_HeaderInfo( FT_Library  library,
+                             FT_Stream   stream,
+                             FT_Long     rfork_offset,
+                             FT_Long    *map_offset,
+                             FT_Long    *rdata_pos );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Raccess_Get_DataOffsets                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Get the data offsets for a tag in a resource fork.  Offsets are    */
+  /*    stored in an array because, in some cases, resources in a resource */
+  /*    fork have the same tag.                                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    library ::                                                         */
+  /*      A FreeType library instance.                                     */
+  /*                                                                       */
+  /*    stream ::                                                          */
+  /*      A file stream containing the resource fork.                      */
+  /*                                                                       */
+  /*    map_offset ::                                                      */
+  /*      The file offset where the resource map starts.                   */
+  /*                                                                       */
+  /*    rdata_pos ::                                                       */
+  /*      The file offset where the resource data starts.                  */
+  /*                                                                       */
+  /*    tag ::                                                             */
+  /*      The resource tag.                                                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    offsets ::                                                         */
+  /*      The stream offsets for the resource data specified by `tag'.     */
+  /*      This array is allocated by the function, so you have to call     */
+  /*      @ft_mem_free after use.                                          */
+  /*                                                                       */
+  /*    count ::                                                           */
+  /*      The length of offsets array.                                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  FT_Err_Ok means success.                     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Normally you should use `FT_Raccess_Get_HeaderInfo' to get the     */
+  /*    value for `map_offset' and `rdata_pos'.                            */
+  /*                                                                       */
+  FT_BASE( FT_Error )
+  FT_Raccess_Get_DataOffsets( FT_Library  library,
+                              FT_Stream   stream,
+                              FT_Long     map_offset,
+                              FT_Long     rdata_pos,
+                              FT_Long     tag,
+                              FT_Long   **offsets,
+                              FT_Long    *count );
+
+
+FT_END_HEADER
+
+#endif /* __FTRFORK_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftserv.h b/include/freetype/internal/ftserv.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftserv.h
@@ -0,0 +1,695 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftserv.h                                                               */
+/*                                                                         */
+/*    The FreeType services (specification only).                          */
+/*                                                                         */
+/*  Copyright 2003-2007, 2009, 2012 by                                     */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*  Each module can export one or more `services'.  Each service is      */
+  /*  identified by a constant string and modeled by a pointer; the latter */
+  /*  generally corresponds to a structure containing function pointers.   */
+  /*                                                                       */
+  /*  Note that a service's data cannot be a mere function pointer because */
+  /*  in C it is possible that function pointers might be implemented      */
+  /*  differently than data pointers (e.g. 48 bits instead of 32).         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FTSERV_H__
+#define __FTSERV_H__
+
+
+FT_BEGIN_HEADER
+
+#if defined( _MSC_VER )      /* Visual C++ (and Intel C++) */
+
+  /* we disable the warning `conditional expression is constant' here */
+  /* in order to compile cleanly with the maximum level of warnings   */
+#pragma warning( disable : 4127 )
+
+#endif /* _MSC_VER */
+
+  /*
+   * @macro:
+   *   FT_FACE_FIND_SERVICE
+   *
+   * @description:
+   *   This macro is used to look up a service from a face's driver module.
+   *
+   * @input:
+   *   face ::
+   *     The source face handle.
+   *
+   *   id ::
+   *     A string describing the service as defined in the service's
+   *     header files (e.g. FT_SERVICE_ID_MULTI_MASTERS which expands to
+   *     `multi-masters').  It is automatically prefixed with
+   *     `FT_SERVICE_ID_'.
+   *
+   * @output:
+   *   ptr ::
+   *     A variable that receives the service pointer.  Will be NULL
+   *     if not found.
+   */
+#ifdef __cplusplus
+
+#define FT_FACE_FIND_SERVICE( face, ptr, id )                               \
+  FT_BEGIN_STMNT                                                            \
+    FT_Module    module = FT_MODULE( FT_FACE( face )->driver );             \
+    FT_Pointer   _tmp_  = NULL;                                             \
+    FT_Pointer*  _pptr_ = (FT_Pointer*)&(ptr);                              \
+                                                                            \
+                                                                            \
+    if ( module->clazz->get_interface )                                     \
+      _tmp_ = module->clazz->get_interface( module, FT_SERVICE_ID_ ## id ); \
+    *_pptr_ = _tmp_;                                                        \
+  FT_END_STMNT
+
+#else /* !C++ */
+
+#define FT_FACE_FIND_SERVICE( face, ptr, id )                               \
+  FT_BEGIN_STMNT                                                            \
+    FT_Module   module = FT_MODULE( FT_FACE( face )->driver );              \
+    FT_Pointer  _tmp_  = NULL;                                              \
+                                                                            \
+    if ( module->clazz->get_interface )                                     \
+      _tmp_ = module->clazz->get_interface( module, FT_SERVICE_ID_ ## id ); \
+    ptr = _tmp_;                                                            \
+  FT_END_STMNT
+
+#endif /* !C++ */
+
+
+  /*
+   * @macro:
+   *   FT_FACE_FIND_GLOBAL_SERVICE
+   *
+   * @description:
+   *   This macro is used to look up a service from all modules.
+   *
+   * @input:
+   *   face ::
+   *     The source face handle.
+   *
+   *   id ::
+   *     A string describing the service as defined in the service's
+   *     header files (e.g. FT_SERVICE_ID_MULTI_MASTERS which expands to
+   *     `multi-masters').  It is automatically prefixed with
+   *     `FT_SERVICE_ID_'.
+   *
+   * @output:
+   *   ptr ::
+   *     A variable that receives the service pointer.  Will be NULL
+   *     if not found.
+   */
+#ifdef __cplusplus
+
+#define FT_FACE_FIND_GLOBAL_SERVICE( face, ptr, id )               \
+  FT_BEGIN_STMNT                                                   \
+    FT_Module    module = FT_MODULE( FT_FACE( face )->driver );    \
+    FT_Pointer   _tmp_;                                            \
+    FT_Pointer*  _pptr_ = (FT_Pointer*)&(ptr);                     \
+                                                                   \
+                                                                   \
+    _tmp_ = ft_module_get_service( module, FT_SERVICE_ID_ ## id ); \
+    *_pptr_ = _tmp_;                                               \
+  FT_END_STMNT
+
+#else /* !C++ */
+
+#define FT_FACE_FIND_GLOBAL_SERVICE( face, ptr, id )               \
+  FT_BEGIN_STMNT                                                   \
+    FT_Module   module = FT_MODULE( FT_FACE( face )->driver );     \
+    FT_Pointer  _tmp_;                                             \
+                                                                   \
+                                                                   \
+    _tmp_ = ft_module_get_service( module, FT_SERVICE_ID_ ## id ); \
+    ptr   = _tmp_;                                                 \
+  FT_END_STMNT
+
+#endif /* !C++ */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****         S E R V I C E   D E S C R I P T O R S                 *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*
+   *  The following structure is used to _describe_ a given service
+   *  to the library.  This is useful to build simple static service lists.
+   */
+  typedef struct  FT_ServiceDescRec_
+  {
+    const char*  serv_id;     /* service name         */
+    const void*  serv_data;   /* service pointer/data */
+
+  } FT_ServiceDescRec;
+
+  typedef const FT_ServiceDescRec*  FT_ServiceDesc;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Macro>                                                               */
+  /*    FT_DEFINE_SERVICEDESCREC1                                          */
+  /*    FT_DEFINE_SERVICEDESCREC2                                          */
+  /*    FT_DEFINE_SERVICEDESCREC3                                          */
+  /*    FT_DEFINE_SERVICEDESCREC4                                          */
+  /*    FT_DEFINE_SERVICEDESCREC5                                          */
+  /*    FT_DEFINE_SERVICEDESCREC6                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Used to initialize an array of FT_ServiceDescRec structures.       */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is defined a `create' function needs to  */
+  /*    be called with a pointer to return an allocated array.  As soon as */
+  /*    it is no longer needed, a `destroy' function needs to be called to */
+  /*    release that allocation.                                           */
+  /*                                                                       */
+  /*    These functions should be manually called from the `pic_init' and  */
+  /*    `pic_free' functions of your module (see FT_DEFINE_MODULE).        */
+  /*                                                                       */
+  /*    When FT_CONFIG_OPTION_PIC is not defined the array will be         */
+  /*    allocated in the global scope (or the scope where the macro is     */
+  /*    used).                                                             */
+  /*                                                                       */
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICEDESCREC1( class_,                                  \
+                                   serv_id_1, serv_data_1 )                 \
+  static const FT_ServiceDescRec  class_[] =                                \
+  {                                                                         \
+    { serv_id_1, serv_data_1 },                                             \
+    { NULL, NULL }                                                          \
+  };
+
+#define FT_DEFINE_SERVICEDESCREC2( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2 )                 \
+  static const FT_ServiceDescRec  class_[] =                                \
+  {                                                                         \
+    { serv_id_1, serv_data_1 },                                             \
+    { serv_id_2, serv_data_2 },                                             \
+    { NULL, NULL }                                                          \
+  };
+
+#define FT_DEFINE_SERVICEDESCREC3( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3 )                 \
+  static const FT_ServiceDescRec  class_[] =                                \
+  {                                                                         \
+    { serv_id_1, serv_data_1 },                                             \
+    { serv_id_2, serv_data_2 },                                             \
+    { serv_id_3, serv_data_3 },                                             \
+    { NULL, NULL }                                                          \
+  };
+
+#define FT_DEFINE_SERVICEDESCREC4( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3,                  \
+                                   serv_id_4, serv_data_4 )                 \
+  static const FT_ServiceDescRec  class_[] =                                \
+  {                                                                         \
+    { serv_id_1, serv_data_1 },                                             \
+    { serv_id_2, serv_data_2 },                                             \
+    { serv_id_3, serv_data_3 },                                             \
+    { serv_id_4, serv_data_4 },                                             \
+    { NULL, NULL }                                                          \
+  };
+
+#define FT_DEFINE_SERVICEDESCREC5( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3,                  \
+                                   serv_id_4, serv_data_4,                  \
+                                   serv_id_5, serv_data_5 )                 \
+  static const FT_ServiceDescRec  class_[] =                                \
+  {                                                                         \
+    { serv_id_1, serv_data_1 },                                             \
+    { serv_id_2, serv_data_2 },                                             \
+    { serv_id_3, serv_data_3 },                                             \
+    { serv_id_4, serv_data_4 },                                             \
+    { serv_id_5, serv_data_5 },                                             \
+    { NULL, NULL }                                                          \
+  };
+
+#define FT_DEFINE_SERVICEDESCREC6( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3,                  \
+                                   serv_id_4, serv_data_4,                  \
+                                   serv_id_5, serv_data_5,                  \
+                                   serv_id_6, serv_data_6 )                 \
+  static const FT_ServiceDescRec  class_[] =                                \
+  {                                                                         \
+    { serv_id_1, serv_data_1 },                                             \
+    { serv_id_2, serv_data_2 },                                             \
+    { serv_id_3, serv_data_3 },                                             \
+    { serv_id_4, serv_data_4 },                                             \
+    { serv_id_5, serv_data_5 },                                             \
+    { serv_id_6, serv_data_6 },                                             \
+    { NULL, NULL }                                                          \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICEDESCREC1( class_,                                  \
+                                   serv_id_1, serv_data_1 )                 \
+  void                                                                      \
+  FT_Destroy_Class_ ## class_( FT_Library          library,                 \
+                               FT_ServiceDescRec*  clazz )                  \
+  {                                                                         \
+    FT_Memory  memory = library->memory;                                    \
+                                                                            \
+                                                                            \
+    if ( clazz )                                                            \
+      FT_FREE( clazz );                                                     \
+  }                                                                         \
+                                                                            \
+  FT_Error                                                                  \
+  FT_Create_Class_ ## class_( FT_Library           library,                 \
+                              FT_ServiceDescRec**  output_class )           \
+  {                                                                         \
+    FT_ServiceDescRec*  clazz  = NULL;                                      \
+    FT_Error            error;                                              \
+    FT_Memory           memory = library->memory;                           \
+                                                                            \
+                                                                            \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * 2 ) )                         \
+      return error;                                                         \
+                                                                            \
+    clazz[0].serv_id   = serv_id_1;                                         \
+    clazz[0].serv_data = serv_data_1;                                       \
+    clazz[1].serv_id   = NULL;                                              \
+    clazz[1].serv_data = NULL;                                              \
+                                                                            \
+    *output_class = clazz;                                                  \
+                                                                            \
+    return FT_Err_Ok;                                                       \
+  }
+
+#define FT_DEFINE_SERVICEDESCREC2( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2 )                 \
+  void                                                                      \
+  FT_Destroy_Class_ ## class_( FT_Library          library,                 \
+                               FT_ServiceDescRec*  clazz )                  \
+  {                                                                         \
+    FT_Memory  memory = library->memory;                                    \
+                                                                            \
+                                                                            \
+    if ( clazz )                                                            \
+      FT_FREE( clazz );                                                     \
+  }                                                                         \
+                                                                            \
+  FT_Error                                                                  \
+  FT_Create_Class_ ## class_( FT_Library           library,                 \
+                              FT_ServiceDescRec**  output_class )           \
+  {                                                                         \
+    FT_ServiceDescRec*  clazz  = NULL;                                      \
+    FT_Error            error;                                              \
+    FT_Memory           memory = library->memory;                           \
+                                                                            \
+                                                                            \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * 3 ) )                         \
+      return error;                                                         \
+                                                                            \
+    clazz[0].serv_id   = serv_id_1;                                         \
+    clazz[0].serv_data = serv_data_1;                                       \
+    clazz[1].serv_id   = serv_id_2;                                         \
+    clazz[1].serv_data = serv_data_2;                                       \
+    clazz[2].serv_id   = NULL;                                              \
+    clazz[2].serv_data = NULL;                                              \
+                                                                            \
+    *output_class = clazz;                                                  \
+                                                                            \
+    return FT_Err_Ok;                                                       \
+  }
+
+#define FT_DEFINE_SERVICEDESCREC3( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3 )                 \
+  void                                                                      \
+  FT_Destroy_Class_ ## class_( FT_Library          library,                 \
+                               FT_ServiceDescRec*  clazz )                  \
+  {                                                                         \
+    FT_Memory  memory = library->memory;                                    \
+                                                                            \
+                                                                            \
+    if ( clazz )                                                            \
+      FT_FREE( clazz );                                                     \
+  }                                                                         \
+                                                                            \
+  FT_Error                                                                  \
+  FT_Create_Class_ ## class_( FT_Library           library,                 \
+                              FT_ServiceDescRec**  output_class )           \
+  {                                                                         \
+    FT_ServiceDescRec*  clazz  = NULL;                                      \
+    FT_Error            error;                                              \
+    FT_Memory           memory = library->memory;                           \
+                                                                            \
+                                                                            \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * 4 ) )                         \
+      return error;                                                         \
+                                                                            \
+    clazz[0].serv_id   = serv_id_1;                                         \
+    clazz[0].serv_data = serv_data_1;                                       \
+    clazz[1].serv_id   = serv_id_2;                                         \
+    clazz[1].serv_data = serv_data_2;                                       \
+    clazz[2].serv_id   = serv_id_3;                                         \
+    clazz[2].serv_data = serv_data_3;                                       \
+    clazz[3].serv_id   = NULL;                                              \
+    clazz[3].serv_data = NULL;                                              \
+                                                                            \
+    *output_class = clazz;                                                  \
+                                                                            \
+    return FT_Err_Ok;                                                       \
+  }
+
+#define FT_DEFINE_SERVICEDESCREC4( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3,                  \
+                                   serv_id_4, serv_data_4 )                 \
+  void                                                                      \
+  FT_Destroy_Class_ ## class_( FT_Library          library,                 \
+                               FT_ServiceDescRec*  clazz )                  \
+  {                                                                         \
+    FT_Memory  memory = library->memory;                                    \
+                                                                            \
+                                                                            \
+    if ( clazz )                                                            \
+      FT_FREE( clazz );                                                     \
+  }                                                                         \
+                                                                            \
+  FT_Error                                                                  \
+  FT_Create_Class_ ## class_( FT_Library           library,                 \
+                              FT_ServiceDescRec**  output_class )           \
+  {                                                                         \
+    FT_ServiceDescRec*  clazz  = NULL;                                      \
+    FT_Error            error;                                              \
+    FT_Memory           memory = library->memory;                           \
+                                                                            \
+                                                                            \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * 5 ) )                         \
+      return error;                                                         \
+                                                                            \
+    clazz[0].serv_id   = serv_id_1;                                         \
+    clazz[0].serv_data = serv_data_1;                                       \
+    clazz[1].serv_id   = serv_id_2;                                         \
+    clazz[1].serv_data = serv_data_2;                                       \
+    clazz[2].serv_id   = serv_id_3;                                         \
+    clazz[2].serv_data = serv_data_3;                                       \
+    clazz[3].serv_id   = serv_id_4;                                         \
+    clazz[3].serv_data = serv_data_4;                                       \
+    clazz[4].serv_id   = NULL;                                              \
+    clazz[4].serv_data = NULL;                                              \
+                                                                            \
+    *output_class = clazz;                                                  \
+                                                                            \
+    return FT_Err_Ok;                                                       \
+  }
+
+#define FT_DEFINE_SERVICEDESCREC5( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3,                  \
+                                   serv_id_4, serv_data_4,                  \
+                                   serv_id_5, serv_data_5 )                 \
+  void                                                                      \
+  FT_Destroy_Class_ ## class_( FT_Library          library,                 \
+                               FT_ServiceDescRec*  clazz )                  \
+  {                                                                         \
+    FT_Memory  memory = library->memory;                                    \
+                                                                            \
+                                                                            \
+    if ( clazz )                                                            \
+      FT_FREE( clazz );                                                     \
+  }                                                                         \
+                                                                            \
+  FT_Error                                                                  \
+  FT_Create_Class_ ## class_( FT_Library           library,                 \
+                              FT_ServiceDescRec**  output_class )           \
+  {                                                                         \
+    FT_ServiceDescRec*  clazz  = NULL;                                      \
+    FT_Error            error;                                              \
+    FT_Memory           memory = library->memory;                           \
+                                                                            \
+                                                                            \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * 6 ) )                         \
+      return error;                                                         \
+                                                                            \
+    clazz[0].serv_id   = serv_id_1;                                         \
+    clazz[0].serv_data = serv_data_1;                                       \
+    clazz[1].serv_id   = serv_id_2;                                         \
+    clazz[1].serv_data = serv_data_2;                                       \
+    clazz[2].serv_id   = serv_id_3;                                         \
+    clazz[2].serv_data = serv_data_3;                                       \
+    clazz[3].serv_id   = serv_id_4;                                         \
+    clazz[3].serv_data = serv_data_4;                                       \
+    clazz[4].serv_id   = serv_id_5;                                         \
+    clazz[4].serv_data = serv_data_5;                                       \
+    clazz[5].serv_id   = NULL;                                              \
+    clazz[5].serv_data = NULL;                                              \
+                                                                            \
+    *output_class = clazz;                                                  \
+                                                                            \
+    return FT_Err_Ok;                                                       \
+  }
+
+#define FT_DEFINE_SERVICEDESCREC6( class_,                                  \
+                                   serv_id_1, serv_data_1,                  \
+                                   serv_id_2, serv_data_2,                  \
+                                   serv_id_3, serv_data_3,                  \
+                                   serv_id_4, serv_data_4,                  \
+                                   serv_id_5, serv_data_5,                  \
+                                   serv_id_6, serv_data_6 )                 \
+  void                                                                      \
+  FT_Destroy_Class_ ## class_( FT_Library          library,                 \
+                               FT_ServiceDescRec*  clazz )                  \
+  {                                                                         \
+    FT_Memory  memory = library->memory;                                    \
+                                                                            \
+                                                                            \
+    if ( clazz )                                                            \
+      FT_FREE( clazz );                                                     \
+  }                                                                         \
+                                                                            \
+  FT_Error                                                                  \
+  FT_Create_Class_ ## class_( FT_Library           library,                 \
+                              FT_ServiceDescRec**  output_class)            \
+  {                                                                         \
+    FT_ServiceDescRec*  clazz  = NULL;                                      \
+    FT_Error            error;                                              \
+    FT_Memory           memory = library->memory;                           \
+                                                                            \
+                                                                            \
+    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * 7 ) )                         \
+      return error;                                                         \
+                                                                            \
+    clazz[0].serv_id   = serv_id_1;                                         \
+    clazz[0].serv_data = serv_data_1;                                       \
+    clazz[1].serv_id   = serv_id_2;                                         \
+    clazz[1].serv_data = serv_data_2;                                       \
+    clazz[2].serv_id   = serv_id_3;                                         \
+    clazz[2].serv_data = serv_data_3;                                       \
+    clazz[3].serv_id   = serv_id_4;                                         \
+    clazz[3].serv_data = serv_data_4;                                       \
+    clazz[4].serv_id   = serv_id_5;                                         \
+    clazz[4].serv_data = serv_data_5;                                       \
+    clazz[5].serv_id   = serv_id_6;                                         \
+    clazz[5].serv_data = serv_data_6;                                       \
+    clazz[6].serv_id   = NULL;                                              \
+    clazz[6].serv_data = NULL;                                              \
+                                                                            \
+    *output_class = clazz;                                                  \
+                                                                            \
+    return FT_Err_Ok;                                                       \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /*
+   *  Parse a list of FT_ServiceDescRec descriptors and look for
+   *  a specific service by ID.  Note that the last element in the
+   *  array must be { NULL, NULL }, and that the function should
+   *  return NULL if the service isn't available.
+   *
+   *  This function can be used by modules to implement their
+   *  `get_service' method.
+   */
+  FT_BASE( FT_Pointer )
+  ft_service_list_lookup( FT_ServiceDesc  service_descriptors,
+                          const char*     service_id );
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****             S E R V I C E S   C A C H E                       *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*
+   *  This structure is used to store a cache for several frequently used
+   *  services.  It is the type of `face->internal->services'.  You
+   *  should only use FT_FACE_LOOKUP_SERVICE to access it.
+   *
+   *  All fields should have the type FT_Pointer to relax compilation
+   *  dependencies.  We assume the developer isn't completely stupid.
+   *
+   *  Each field must be named `service_XXXX' where `XXX' corresponds to
+   *  the correct FT_SERVICE_ID_XXXX macro.  See the definition of
+   *  FT_FACE_LOOKUP_SERVICE below how this is implemented.
+   *
+   */
+  typedef struct  FT_ServiceCacheRec_
+  {
+    FT_Pointer  service_POSTSCRIPT_FONT_NAME;
+    FT_Pointer  service_MULTI_MASTERS;
+    FT_Pointer  service_GLYPH_DICT;
+    FT_Pointer  service_PFR_METRICS;
+    FT_Pointer  service_WINFNT;
+
+  } FT_ServiceCacheRec, *FT_ServiceCache;
+
+
+  /*
+   *  A magic number used within the services cache.
+   */
+#define FT_SERVICE_UNAVAILABLE  ((FT_Pointer)~1)  /* magic number */
+
+
+  /*
+   * @macro:
+   *   FT_FACE_LOOKUP_SERVICE
+   *
+   * @description:
+   *   This macro is used to lookup a service from a face's driver module
+   *   using its cache.
+   *
+   * @input:
+   *   face::
+   *     The source face handle containing the cache.
+   *
+   *   field ::
+   *     The field name in the cache.
+   *
+   *   id ::
+   *     The service ID.
+   *
+   * @output:
+   *   ptr ::
+   *     A variable receiving the service data.  NULL if not available.
+   */
+#ifdef __cplusplus
+
+#define FT_FACE_LOOKUP_SERVICE( face, ptr, id )                \
+  FT_BEGIN_STMNT                                               \
+    FT_Pointer   svc;                                          \
+    FT_Pointer*  Pptr = (FT_Pointer*)&(ptr);                   \
+                                                               \
+                                                               \
+    svc = FT_FACE( face )->internal->services. service_ ## id; \
+    if ( svc == FT_SERVICE_UNAVAILABLE )                       \
+      svc = NULL;                                              \
+    else if ( svc == NULL )                                    \
+    {                                                          \
+      FT_FACE_FIND_SERVICE( face, svc, id );                   \
+                                                               \
+      FT_FACE( face )->internal->services. service_ ## id =    \
+        (FT_Pointer)( svc != NULL ? svc                        \
+                                  : FT_SERVICE_UNAVAILABLE );  \
+    }                                                          \
+    *Pptr = svc;                                               \
+  FT_END_STMNT
+
+#else /* !C++ */
+
+#define FT_FACE_LOOKUP_SERVICE( face, ptr, id )                \
+  FT_BEGIN_STMNT                                               \
+    FT_Pointer  svc;                                           \
+                                                               \
+                                                               \
+    svc = FT_FACE( face )->internal->services. service_ ## id; \
+    if ( svc == FT_SERVICE_UNAVAILABLE )                       \
+      svc = NULL;                                              \
+    else if ( svc == NULL )                                    \
+    {                                                          \
+      FT_FACE_FIND_SERVICE( face, svc, id );                   \
+                                                               \
+      FT_FACE( face )->internal->services. service_ ## id =    \
+        (FT_Pointer)( svc != NULL ? svc                        \
+                                  : FT_SERVICE_UNAVAILABLE );  \
+    }                                                          \
+    ptr = svc;                                                 \
+  FT_END_STMNT
+
+#endif /* !C++ */
+
+  /*
+   *  A macro used to define new service structure types.
+   */
+
+#define FT_DEFINE_SERVICE( name )            \
+  typedef struct FT_Service_ ## name ## Rec_ \
+    FT_Service_ ## name ## Rec ;             \
+  typedef struct FT_Service_ ## name ## Rec_ \
+    const * FT_Service_ ## name ;            \
+  struct FT_Service_ ## name ## Rec_
+
+  /* */
+
+  /*
+   *  The header files containing the services.
+   */
+
+#define FT_SERVICE_BDF_H                <freetype/internal/services/svbdf.h>
+#define FT_SERVICE_CID_H                <freetype/internal/services/svcid.h>
+#define FT_SERVICE_GLYPH_DICT_H         <freetype/internal/services/svgldict.h>
+#define FT_SERVICE_GX_VALIDATE_H        <freetype/internal/services/svgxval.h>
+#define FT_SERVICE_KERNING_H            <freetype/internal/services/svkern.h>
+#define FT_SERVICE_MULTIPLE_MASTERS_H   <freetype/internal/services/svmm.h>
+#define FT_SERVICE_OPENTYPE_VALIDATE_H  <freetype/internal/services/svotval.h>
+#define FT_SERVICE_PFR_H                <freetype/internal/services/svpfr.h>
+#define FT_SERVICE_POSTSCRIPT_CMAPS_H   <freetype/internal/services/svpscmap.h>
+#define FT_SERVICE_POSTSCRIPT_INFO_H    <freetype/internal/services/svpsinfo.h>
+#define FT_SERVICE_POSTSCRIPT_NAME_H    <freetype/internal/services/svpostnm.h>
+#define FT_SERVICE_PROPERTIES_H         <freetype/internal/services/svprop.h>
+#define FT_SERVICE_SFNT_H               <freetype/internal/services/svsfnt.h>
+#define FT_SERVICE_TRUETYPE_ENGINE_H    <freetype/internal/services/svtteng.h>
+#define FT_SERVICE_TT_CMAP_H            <freetype/internal/services/svttcmap.h>
+#define FT_SERVICE_WINFNT_H             <freetype/internal/services/svwinfnt.h>
+#define FT_SERVICE_XFREE86_NAME_H       <freetype/internal/services/svxf86nm.h>
+#define FT_SERVICE_TRUETYPE_GLYF_H      <freetype/internal/services/svttglyf.h>
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __FTSERV_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/ftstream.h b/include/freetype/internal/ftstream.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftstream.h
@@ -0,0 +1,539 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftstream.h                                                             */
+/*                                                                         */
+/*    Stream handling (specification).                                     */
+/*                                                                         */
+/*  Copyright 1996-2002, 2004-2006, 2011 by                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTSTREAM_H__
+#define __FTSTREAM_H__
+
+
+#include <ft2build.h>
+#include FT_SYSTEM_H
+#include FT_INTERNAL_OBJECTS_H
+
+
+FT_BEGIN_HEADER
+
+
+  /* format of an 8-bit frame_op value:           */
+  /*                                              */
+  /* bit  76543210                                */
+  /*      xxxxxxes                                */
+  /*                                              */
+  /* s is set to 1 if the value is signed.        */
+  /* e is set to 1 if the value is little-endian. */
+  /* xxx is a command.                            */
+
+#define FT_FRAME_OP_SHIFT         2
+#define FT_FRAME_OP_SIGNED        1
+#define FT_FRAME_OP_LITTLE        2
+#define FT_FRAME_OP_COMMAND( x )  ( x >> FT_FRAME_OP_SHIFT )
+
+#define FT_MAKE_FRAME_OP( command, little, sign ) \
+          ( ( command << FT_FRAME_OP_SHIFT ) | ( little << 1 ) | sign )
+
+#define FT_FRAME_OP_END    0
+#define FT_FRAME_OP_START  1  /* start a new frame     */
+#define FT_FRAME_OP_BYTE   2  /* read 1-byte value     */
+#define FT_FRAME_OP_SHORT  3  /* read 2-byte value     */
+#define FT_FRAME_OP_LONG   4  /* read 4-byte value     */
+#define FT_FRAME_OP_OFF3   5  /* read 3-byte value     */
+#define FT_FRAME_OP_BYTES  6  /* read a bytes sequence */
+
+
+  typedef enum  FT_Frame_Op_
+  {
+    ft_frame_end       = 0,
+    ft_frame_start     = FT_MAKE_FRAME_OP( FT_FRAME_OP_START, 0, 0 ),
+
+    ft_frame_byte      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTE,  0, 0 ),
+    ft_frame_schar     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTE,  0, 1 ),
+
+    ft_frame_ushort_be = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 0, 0 ),
+    ft_frame_short_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 0, 1 ),
+    ft_frame_ushort_le = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 1, 0 ),
+    ft_frame_short_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 1, 1 ),
+
+    ft_frame_ulong_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 0, 0 ),
+    ft_frame_long_be   = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 0, 1 ),
+    ft_frame_ulong_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 1, 0 ),
+    ft_frame_long_le   = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 1, 1 ),
+
+    ft_frame_uoff3_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 0, 0 ),
+    ft_frame_off3_be   = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 0, 1 ),
+    ft_frame_uoff3_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 1, 0 ),
+    ft_frame_off3_le   = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 1, 1 ),
+
+    ft_frame_bytes     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 0 ),
+    ft_frame_skip      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 1 )
+
+  } FT_Frame_Op;
+
+
+  typedef struct  FT_Frame_Field_
+  {
+    FT_Byte    value;
+    FT_Byte    size;
+    FT_UShort  offset;
+
+  } FT_Frame_Field;
+
+
+  /* Construct an FT_Frame_Field out of a structure type and a field name. */
+  /* The structure type must be set in the FT_STRUCTURE macro before       */
+  /* calling the FT_FRAME_START() macro.                                   */
+  /*                                                                       */
+#define FT_FIELD_SIZE( f ) \
+          (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)->f )
+
+#define FT_FIELD_SIZE_DELTA( f ) \
+          (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)->f[0] )
+
+#define FT_FIELD_OFFSET( f ) \
+          (FT_UShort)( offsetof( FT_STRUCTURE, f ) )
+
+#define FT_FRAME_FIELD( frame_op, field ) \
+          {                               \
+            frame_op,                     \
+            FT_FIELD_SIZE( field ),       \
+            FT_FIELD_OFFSET( field )      \
+          }
+
+#define FT_MAKE_EMPTY_FIELD( frame_op )  { frame_op, 0, 0 }
+
+#define FT_FRAME_START( size )   { ft_frame_start, 0, size }
+#define FT_FRAME_END             { ft_frame_end, 0, 0 }
+
+#define FT_FRAME_LONG( f )       FT_FRAME_FIELD( ft_frame_long_be, f )
+#define FT_FRAME_ULONG( f )      FT_FRAME_FIELD( ft_frame_ulong_be, f )
+#define FT_FRAME_SHORT( f )      FT_FRAME_FIELD( ft_frame_short_be, f )
+#define FT_FRAME_USHORT( f )     FT_FRAME_FIELD( ft_frame_ushort_be, f )
+#define FT_FRAME_OFF3( f )       FT_FRAME_FIELD( ft_frame_off3_be, f )
+#define FT_FRAME_UOFF3( f )      FT_FRAME_FIELD( ft_frame_uoff3_be, f )
+#define FT_FRAME_BYTE( f )       FT_FRAME_FIELD( ft_frame_byte, f )
+#define FT_FRAME_CHAR( f )       FT_FRAME_FIELD( ft_frame_schar, f )
+
+#define FT_FRAME_LONG_LE( f )    FT_FRAME_FIELD( ft_frame_long_le, f )
+#define FT_FRAME_ULONG_LE( f )   FT_FRAME_FIELD( ft_frame_ulong_le, f )
+#define FT_FRAME_SHORT_LE( f )   FT_FRAME_FIELD( ft_frame_short_le, f )
+#define FT_FRAME_USHORT_LE( f )  FT_FRAME_FIELD( ft_frame_ushort_le, f )
+#define FT_FRAME_OFF3_LE( f )    FT_FRAME_FIELD( ft_frame_off3_le, f )
+#define FT_FRAME_UOFF3_LE( f )   FT_FRAME_FIELD( ft_frame_uoff3_le, f )
+
+#define FT_FRAME_SKIP_LONG       { ft_frame_long_be, 0, 0 }
+#define FT_FRAME_SKIP_SHORT      { ft_frame_short_be, 0, 0 }
+#define FT_FRAME_SKIP_BYTE       { ft_frame_byte, 0, 0 }
+
+#define FT_FRAME_BYTES( field, count ) \
+          {                            \
+            ft_frame_bytes,            \
+            count,                     \
+            FT_FIELD_OFFSET( field )   \
+          }
+
+#define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Integer extraction macros -- the `buffer' parameter must ALWAYS be of */
+  /* type `char*' or equivalent (1-byte elements).                         */
+  /*                                                                       */
+
+#define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
+#define FT_INT8_( p, i )  ( ((const FT_Char*)(p))[(i)] )
+
+#define FT_INT16( x )   ( (FT_Int16)(x)  )
+#define FT_UINT16( x )  ( (FT_UInt16)(x) )
+#define FT_INT32( x )   ( (FT_Int32)(x)  )
+#define FT_UINT32( x )  ( (FT_UInt32)(x) )
+
+#define FT_BYTE_I16( p, i, s )  ( FT_INT16(  FT_BYTE_( p, i ) ) << (s) )
+#define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) << (s) )
+#define FT_BYTE_I32( p, i, s )  ( FT_INT32(  FT_BYTE_( p, i ) ) << (s) )
+#define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) << (s) )
+
+#define FT_INT8_I16( p, i, s )  ( FT_INT16(  FT_INT8_( p, i ) ) << (s) )
+#define FT_INT8_U16( p, i, s )  ( FT_UINT16( FT_INT8_( p, i ) ) << (s) )
+#define FT_INT8_I32( p, i, s )  ( FT_INT32(  FT_INT8_( p, i ) ) << (s) )
+#define FT_INT8_U32( p, i, s )  ( FT_UINT32( FT_INT8_( p, i ) ) << (s) )
+
+
+#define FT_PEEK_SHORT( p )  FT_INT16( FT_INT8_I16( p, 0, 8) | \
+                                      FT_BYTE_I16( p, 1, 0) )
+
+#define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
+                                        FT_BYTE_U16( p, 1, 0 ) )
+
+#define FT_PEEK_LONG( p )  FT_INT32( FT_INT8_I32( p, 0, 24 ) | \
+                                     FT_BYTE_I32( p, 1, 16 ) | \
+                                     FT_BYTE_I32( p, 2,  8 ) | \
+                                     FT_BYTE_I32( p, 3,  0 ) )
+
+#define FT_PEEK_ULONG( p )  FT_UINT32( FT_BYTE_U32( p, 0, 24 ) | \
+                                       FT_BYTE_U32( p, 1, 16 ) | \
+                                       FT_BYTE_U32( p, 2,  8 ) | \
+                                       FT_BYTE_U32( p, 3,  0 ) )
+
+#define FT_PEEK_OFF3( p )  FT_INT32( FT_INT8_I32( p, 0, 16 ) | \
+                                     FT_BYTE_I32( p, 1,  8 ) | \
+                                     FT_BYTE_I32( p, 2,  0 ) )
+
+#define FT_PEEK_UOFF3( p )  FT_UINT32( FT_BYTE_U32( p, 0, 16 ) | \
+                                       FT_BYTE_U32( p, 1,  8 ) | \
+                                       FT_BYTE_U32( p, 2,  0 ) )
+
+#define FT_PEEK_SHORT_LE( p )  FT_INT16( FT_INT8_I16( p, 1, 8 ) | \
+                                         FT_BYTE_I16( p, 0, 0 ) )
+
+#define FT_PEEK_USHORT_LE( p )  FT_UINT16( FT_BYTE_U16( p, 1, 8 ) |  \
+                                           FT_BYTE_U16( p, 0, 0 ) )
+
+#define FT_PEEK_LONG_LE( p )  FT_INT32( FT_INT8_I32( p, 3, 24 ) | \
+                                        FT_BYTE_I32( p, 2, 16 ) | \
+                                        FT_BYTE_I32( p, 1,  8 ) | \
+                                        FT_BYTE_I32( p, 0,  0 ) )
+
+#define FT_PEEK_ULONG_LE( p )  FT_UINT32( FT_BYTE_U32( p, 3, 24 ) | \
+                                          FT_BYTE_U32( p, 2, 16 ) | \
+                                          FT_BYTE_U32( p, 1,  8 ) | \
+                                          FT_BYTE_U32( p, 0,  0 ) )
+
+#define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_INT8_I32( p, 2, 16 ) | \
+                                        FT_BYTE_I32( p, 1,  8 ) | \
+                                        FT_BYTE_I32( p, 0,  0 ) )
+
+#define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
+                                          FT_BYTE_U32( p, 1,  8 ) | \
+                                          FT_BYTE_U32( p, 0,  0 ) )
+
+
+#define FT_NEXT_CHAR( buffer )       \
+          ( (signed char)*buffer++ )
+
+#define FT_NEXT_BYTE( buffer )         \
+          ( (unsigned char)*buffer++ )
+
+#define FT_NEXT_SHORT( buffer )                                   \
+          ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )
+
+#define FT_NEXT_USHORT( buffer )                                            \
+          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )
+
+#define FT_NEXT_OFF3( buffer )                                  \
+          ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )
+
+#define FT_NEXT_UOFF3( buffer )                                           \
+          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )
+
+#define FT_NEXT_LONG( buffer )                                  \
+          ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )
+
+#define FT_NEXT_ULONG( buffer )                                           \
+          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) ) )
+
+
+#define FT_NEXT_SHORT_LE( buffer )                                   \
+          ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )
+
+#define FT_NEXT_USHORT_LE( buffer )                                            \
+          ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )
+
+#define FT_NEXT_OFF3_LE( buffer )                                  \
+          ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )
+
+#define FT_NEXT_UOFF3_LE( buffer )                                           \
+          ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )
+
+#define FT_NEXT_LONG_LE( buffer )                                  \
+          ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )
+
+#define FT_NEXT_ULONG_LE( buffer )                                           \
+          ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Each GET_xxxx() macro uses an implicit `stream' variable.             */
+  /*                                                                       */
+#if 0
+#define FT_GET_MACRO( type )    FT_NEXT_ ## type ( stream->cursor )
+
+#define FT_GET_CHAR()       FT_GET_MACRO( CHAR )
+#define FT_GET_BYTE()       FT_GET_MACRO( BYTE )
+#define FT_GET_SHORT()      FT_GET_MACRO( SHORT )
+#define FT_GET_USHORT()     FT_GET_MACRO( USHORT )
+#define FT_GET_OFF3()       FT_GET_MACRO( OFF3 )
+#define FT_GET_UOFF3()      FT_GET_MACRO( UOFF3 )
+#define FT_GET_LONG()       FT_GET_MACRO( LONG )
+#define FT_GET_ULONG()      FT_GET_MACRO( ULONG )
+#define FT_GET_TAG4()       FT_GET_MACRO( ULONG )
+
+#define FT_GET_SHORT_LE()   FT_GET_MACRO( SHORT_LE )
+#define FT_GET_USHORT_LE()  FT_GET_MACRO( USHORT_LE )
+#define FT_GET_LONG_LE()    FT_GET_MACRO( LONG_LE )
+#define FT_GET_ULONG_LE()   FT_GET_MACRO( ULONG_LE )
+
+#else
+#define FT_GET_MACRO( func, type )        ( (type)func( stream ) )
+
+#define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )
+#define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )
+#define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Short )
+#define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UShort )
+#define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetUOffset, FT_Long )
+#define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_ULong )
+#define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Long )
+#define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
+#define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
+
+#define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Short )
+#define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )
+#define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )
+#define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )
+#endif
+
+#define FT_READ_MACRO( func, type, var )        \
+          ( var = (type)func( stream, &error ), \
+            error != FT_Err_Ok )
+
+#define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
+#define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
+#define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )
+#define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )
+#define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )
+#define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_ULong, var )
+#define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Long, var )
+#define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_ULong, var )
+
+#define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Short, var )
+#define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UShort, var )
+#define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Long, var )
+#define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_ULong, var )
+
+
+#ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
+
+  /* initialize a stream for reading a regular system stream */
+  FT_BASE( FT_Error )
+  FT_Stream_Open( FT_Stream    stream,
+                  const char*  filepathname );
+
+#endif /* FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM */
+
+
+  /* create a new (input) stream from an FT_Open_Args structure */
+  FT_BASE( FT_Error )
+  FT_Stream_New( FT_Library           library,
+                 const FT_Open_Args*  args,
+                 FT_Stream           *astream );
+
+  /* free a stream */
+  FT_BASE( void )
+  FT_Stream_Free( FT_Stream  stream,
+                  FT_Int     external );
+
+  /* initialize a stream for reading in-memory data */
+  FT_BASE( void )
+  FT_Stream_OpenMemory( FT_Stream       stream,
+                        const FT_Byte*  base,
+                        FT_ULong        size );
+
+  /* close a stream (does not destroy the stream structure) */
+  FT_BASE( void )
+  FT_Stream_Close( FT_Stream  stream );
+
+
+  /* seek within a stream. position is relative to start of stream */
+  FT_BASE( FT_Error )
+  FT_Stream_Seek( FT_Stream  stream,
+                  FT_ULong   pos );
+
+  /* skip bytes in a stream */
+  FT_BASE( FT_Error )
+  FT_Stream_Skip( FT_Stream  stream,
+                  FT_Long    distance );
+
+  /* return current stream position */
+  FT_BASE( FT_Long )
+  FT_Stream_Pos( FT_Stream  stream );
+
+  /* read bytes from a stream into a user-allocated buffer, returns an */
+  /* error if not all bytes could be read.                             */
+  FT_BASE( FT_Error )
+  FT_Stream_Read( FT_Stream  stream,
+                  FT_Byte*   buffer,
+                  FT_ULong   count );
+
+  /* read bytes from a stream at a given position */
+  FT_BASE( FT_Error )
+  FT_Stream_ReadAt( FT_Stream  stream,
+                    FT_ULong   pos,
+                    FT_Byte*   buffer,
+                    FT_ULong   count );
+
+  /* try to read bytes at the end of a stream; return number of bytes */
+  /* really available                                                 */
+  FT_BASE( FT_ULong )
+  FT_Stream_TryRead( FT_Stream  stream,
+                     FT_Byte*   buffer,
+                     FT_ULong   count );
+
+  /* Enter a frame of `count' consecutive bytes in a stream.  Returns an */
+  /* error if the frame could not be read/accessed.  The caller can use  */
+  /* the FT_Stream_Get_XXX functions to retrieve frame data without      */
+  /* error checks.                                                       */
+  /*                                                                     */
+  /* You must _always_ call FT_Stream_ExitFrame() once you have entered  */
+  /* a stream frame!                                                     */
+  /*                                                                     */
+  FT_BASE( FT_Error )
+  FT_Stream_EnterFrame( FT_Stream  stream,
+                        FT_ULong   count );
+
+  /* exit a stream frame */
+  FT_BASE( void )
+  FT_Stream_ExitFrame( FT_Stream  stream );
+
+  /* Extract a stream frame.  If the stream is disk-based, a heap block */
+  /* is allocated and the frame bytes are read into it.  If the stream  */
+  /* is memory-based, this function simply set a pointer to the data.   */
+  /*                                                                    */
+  /* Useful to optimize access to memory-based streams transparently.   */
+  /*                                                                    */
+  /* All extracted frames must be `freed' with a call to the function   */
+  /* FT_Stream_ReleaseFrame().                                          */
+  /*                                                                    */
+  FT_BASE( FT_Error )
+  FT_Stream_ExtractFrame( FT_Stream  stream,
+                          FT_ULong   count,
+                          FT_Byte**  pbytes );
+
+  /* release an extract frame (see FT_Stream_ExtractFrame) */
+  FT_BASE( void )
+  FT_Stream_ReleaseFrame( FT_Stream  stream,
+                          FT_Byte**  pbytes );
+
+  /* read a byte from an entered frame */
+  FT_BASE( FT_Char )
+  FT_Stream_GetChar( FT_Stream  stream );
+
+  /* read a 16-bit big-endian unsigned integer from an entered frame */
+  FT_BASE( FT_UShort )
+  FT_Stream_GetUShort( FT_Stream  stream );
+
+  /* read a 24-bit big-endian unsigned integer from an entered frame */
+  FT_BASE( FT_ULong )
+  FT_Stream_GetUOffset( FT_Stream  stream );
+
+  /* read a 32-bit big-endian unsigned integer from an entered frame */
+  FT_BASE( FT_ULong )
+  FT_Stream_GetULong( FT_Stream  stream );
+
+  /* read a 16-bit little-endian unsigned integer from an entered frame */
+  FT_BASE( FT_UShort )
+  FT_Stream_GetUShortLE( FT_Stream  stream );
+
+  /* read a 32-bit little-endian unsigned integer from an entered frame */
+  FT_BASE( FT_ULong )
+  FT_Stream_GetULongLE( FT_Stream  stream );
+
+
+  /* read a byte from a stream */
+  FT_BASE( FT_Char )
+  FT_Stream_ReadChar( FT_Stream  stream,
+                      FT_Error*  error );
+
+  /* read a 16-bit big-endian unsigned integer from a stream */
+  FT_BASE( FT_UShort )
+  FT_Stream_ReadUShort( FT_Stream  stream,
+                        FT_Error*  error );
+
+  /* read a 24-bit big-endian unsigned integer from a stream */
+  FT_BASE( FT_ULong )
+  FT_Stream_ReadUOffset( FT_Stream  stream,
+                         FT_Error*  error );
+
+  /* read a 32-bit big-endian integer from a stream */
+  FT_BASE( FT_ULong )
+  FT_Stream_ReadULong( FT_Stream  stream,
+                       FT_Error*  error );
+
+  /* read a 16-bit little-endian unsigned integer from a stream */
+  FT_BASE( FT_UShort )
+  FT_Stream_ReadUShortLE( FT_Stream  stream,
+                          FT_Error*  error );
+
+  /* read a 32-bit little-endian unsigned integer from a stream */
+  FT_BASE( FT_ULong )
+  FT_Stream_ReadULongLE( FT_Stream  stream,
+                         FT_Error*  error );
+
+  /* Read a structure from a stream.  The structure must be described */
+  /* by an array of FT_Frame_Field records.                           */
+  FT_BASE( FT_Error )
+  FT_Stream_ReadFields( FT_Stream              stream,
+                        const FT_Frame_Field*  fields,
+                        void*                  structure );
+
+
+#define FT_STREAM_POS()           \
+          FT_Stream_Pos( stream )
+
+#define FT_STREAM_SEEK( position )                           \
+          FT_SET_ERROR( FT_Stream_Seek( stream, position ) )
+
+#define FT_STREAM_SKIP( distance )                           \
+          FT_SET_ERROR( FT_Stream_Skip( stream, distance ) )
+
+#define FT_STREAM_READ( buffer, count )                   \
+          FT_SET_ERROR( FT_Stream_Read( stream,           \
+                                        (FT_Byte*)buffer, \
+                                        count ) )
+
+#define FT_STREAM_READ_AT( position, buffer, count )         \
+          FT_SET_ERROR( FT_Stream_ReadAt( stream,            \
+                                           position,         \
+                                           (FT_Byte*)buffer, \
+                                           count ) )
+
+#define FT_STREAM_READ_FIELDS( fields, object )                          \
+          FT_SET_ERROR( FT_Stream_ReadFields( stream, fields, object ) )
+
+
+#define FT_FRAME_ENTER( size )                                       \
+          FT_SET_ERROR(                                              \
+            FT_DEBUG_INNER( FT_Stream_EnterFrame( stream, size ) ) )
+
+#define FT_FRAME_EXIT()                 \
+          FT_DEBUG_INNER( FT_Stream_ExitFrame( stream ) )
+
+#define FT_FRAME_EXTRACT( size, bytes )                                       \
+          FT_SET_ERROR(                                                       \
+            FT_DEBUG_INNER( FT_Stream_ExtractFrame( stream, size,             \
+                                                    (FT_Byte**)&(bytes) ) ) )
+
+#define FT_FRAME_RELEASE( bytes )                                         \
+          FT_DEBUG_INNER( FT_Stream_ReleaseFrame( stream,                 \
+                                                  (FT_Byte**)&(bytes) ) )
+
+
+FT_END_HEADER
+
+#endif /* __FTSTREAM_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/fttrace.h b/include/freetype/internal/fttrace.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/fttrace.h
@@ -0,0 +1,147 @@
+/***************************************************************************/
+/*                                                                         */
+/*  fttrace.h                                                              */
+/*                                                                         */
+/*    Tracing handling (specification only).                               */
+/*                                                                         */
+/*  Copyright 2002, 2004-2007, 2009, 2011-2012 by                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /* definitions of trace levels for FreeType 2 */
+
+  /* the first level must always be `trace_any' */
+FT_TRACE_DEF( any )
+
+  /* base components */
+FT_TRACE_DEF( calc )      /* calculations            (ftcalc.c)   */
+FT_TRACE_DEF( memory )    /* memory manager          (ftobjs.c)   */
+FT_TRACE_DEF( stream )    /* stream manager          (ftstream.c) */
+FT_TRACE_DEF( io )        /* i/o interface           (ftsystem.c) */
+FT_TRACE_DEF( list )      /* list management         (ftlist.c)   */
+FT_TRACE_DEF( init )      /* initialization          (ftinit.c)   */
+FT_TRACE_DEF( objs )      /* base objects            (ftobjs.c)   */
+FT_TRACE_DEF( outline )   /* outline management      (ftoutln.c)  */
+FT_TRACE_DEF( glyph )     /* glyph management        (ftglyph.c)  */
+FT_TRACE_DEF( gloader )   /* glyph loader            (ftgloadr.c) */
+
+FT_TRACE_DEF( raster )    /* monochrome rasterizer   (ftraster.c) */
+FT_TRACE_DEF( smooth )    /* anti-aliasing raster    (ftgrays.c)  */
+FT_TRACE_DEF( mm )        /* MM interface            (ftmm.c)     */
+FT_TRACE_DEF( raccess )   /* resource fork accessor  (ftrfork.c)  */
+FT_TRACE_DEF( synth )     /* bold/slant synthesizer  (ftsynth.c)  */
+
+  /* Cache sub-system */
+FT_TRACE_DEF( cache )     /* cache sub-system        (ftcache.c, etc.) */
+
+  /* SFNT driver components */
+FT_TRACE_DEF( sfdriver )  /* SFNT font driver        (sfdriver.c) */
+FT_TRACE_DEF( sfobjs )    /* SFNT object handler     (sfobjs.c)   */
+FT_TRACE_DEF( ttcmap )    /* charmap handler         (ttcmap.c)   */
+FT_TRACE_DEF( ttkern )    /* kerning handler         (ttkern.c)   */
+FT_TRACE_DEF( ttload )    /* basic TrueType tables   (ttload.c)   */
+FT_TRACE_DEF( ttmtx )     /* metrics-related tables  (ttmtx.c)    */
+FT_TRACE_DEF( ttpost )    /* PS table processing     (ttpost.c)   */
+FT_TRACE_DEF( ttsbit )    /* TrueType sbit handling  (ttsbit.c)   */
+FT_TRACE_DEF( ttbdf )     /* TrueType embedded BDF   (ttbdf.c)    */
+
+  /* TrueType driver components */
+FT_TRACE_DEF( ttdriver )  /* TT font driver          (ttdriver.c) */
+FT_TRACE_DEF( ttgload )   /* TT glyph loader         (ttgload.c)  */
+FT_TRACE_DEF( ttinterp )  /* bytecode interpreter    (ttinterp.c) */
+FT_TRACE_DEF( ttobjs )    /* TT objects manager      (ttobjs.c)   */
+FT_TRACE_DEF( ttpload )   /* TT data/program loader  (ttpload.c)  */
+FT_TRACE_DEF( ttgxvar )   /* TrueType GX var handler (ttgxvar.c)  */
+
+  /* Type 1 driver components */
+FT_TRACE_DEF( t1afm )
+FT_TRACE_DEF( t1driver )
+FT_TRACE_DEF( t1gload )
+FT_TRACE_DEF( t1hint )
+FT_TRACE_DEF( t1load )
+FT_TRACE_DEF( t1objs )
+FT_TRACE_DEF( t1parse )
+
+  /* PostScript helper module `psaux' */
+FT_TRACE_DEF( t1decode )
+FT_TRACE_DEF( psobjs )
+FT_TRACE_DEF( psconv )
+
+  /* PostScript hinting module `pshinter' */
+FT_TRACE_DEF( pshrec )
+FT_TRACE_DEF( pshalgo1 )
+FT_TRACE_DEF( pshalgo2 )
+
+  /* Type 2 driver components */
+FT_TRACE_DEF( cffdriver )
+FT_TRACE_DEF( cffgload )
+FT_TRACE_DEF( cffload )
+FT_TRACE_DEF( cffobjs )
+FT_TRACE_DEF( cffparse )
+
+  /* Type 42 driver component */
+FT_TRACE_DEF( t42 )
+
+  /* CID driver components */
+FT_TRACE_DEF( cidafm )
+FT_TRACE_DEF( ciddriver )
+FT_TRACE_DEF( cidgload )
+FT_TRACE_DEF( cidload )
+FT_TRACE_DEF( cidobjs )
+FT_TRACE_DEF( cidparse )
+
+  /* Windows font component */
+FT_TRACE_DEF( winfnt )
+
+  /* PCF font components */
+FT_TRACE_DEF( pcfdriver )
+FT_TRACE_DEF( pcfread )
+
+  /* BDF font components */
+FT_TRACE_DEF( bdfdriver )
+FT_TRACE_DEF( bdflib )
+
+  /* PFR font component */
+FT_TRACE_DEF( pfr )
+
+  /* OpenType validation components */
+FT_TRACE_DEF( otvmodule )
+FT_TRACE_DEF( otvcommon )
+FT_TRACE_DEF( otvbase )
+FT_TRACE_DEF( otvgdef )
+FT_TRACE_DEF( otvgpos )
+FT_TRACE_DEF( otvgsub )
+FT_TRACE_DEF( otvjstf )
+FT_TRACE_DEF( otvmath )
+
+  /* TrueTypeGX/AAT validation components */
+FT_TRACE_DEF( gxvmodule )
+FT_TRACE_DEF( gxvcommon )
+FT_TRACE_DEF( gxvfeat )
+FT_TRACE_DEF( gxvmort )
+FT_TRACE_DEF( gxvmorx )
+FT_TRACE_DEF( gxvbsln )
+FT_TRACE_DEF( gxvjust )
+FT_TRACE_DEF( gxvkern )
+FT_TRACE_DEF( gxvopbd )
+FT_TRACE_DEF( gxvtrak )
+FT_TRACE_DEF( gxvprop )
+FT_TRACE_DEF( gxvlcar )
+
+  /* autofit components */
+FT_TRACE_DEF( afmodule )
+FT_TRACE_DEF( afhints )
+FT_TRACE_DEF( afcjk )
+FT_TRACE_DEF( aflatin )
+FT_TRACE_DEF( aflatin2 )
+FT_TRACE_DEF( afwarp )
+
+/* END */
diff --git a/include/freetype/internal/ftvalid.h b/include/freetype/internal/ftvalid.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/ftvalid.h
@@ -0,0 +1,150 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftvalid.h                                                              */
+/*                                                                         */
+/*    FreeType validation support (specification).                         */
+/*                                                                         */
+/*  Copyright 2004 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __FTVALID_H__
+#define __FTVALID_H__
+
+#include <ft2build.h>
+#include FT_CONFIG_STANDARD_LIBRARY_H   /* for ft_setjmp and ft_longjmp */
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                    V A L I D A T I O N                          ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /* handle to a validation object */
+  typedef struct FT_ValidatorRec_ volatile*  FT_Validator;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* There are three distinct validation levels defined here:              */
+  /*                                                                       */
+  /* FT_VALIDATE_DEFAULT ::                                                */
+  /*   A table that passes this validation level can be used reliably by   */
+  /*   FreeType.  It generally means that all offsets have been checked to */
+  /*   prevent out-of-bound reads, that array counts are correct, etc.     */
+  /*                                                                       */
+  /* FT_VALIDATE_TIGHT ::                                                  */
+  /*   A table that passes this validation level can be used reliably and  */
+  /*   doesn't contain invalid data.  For example, a charmap table that    */
+  /*   returns invalid glyph indices will not pass, even though it can     */
+  /*   be used with FreeType in default mode (the library will simply      */
+  /*   return an error later when trying to load the glyph).               */
+  /*                                                                       */
+  /*   It also checks that fields which must be a multiple of 2, 4, or 8,  */
+  /*   don't have incorrect values, etc.                                   */
+  /*                                                                       */
+  /* FT_VALIDATE_PARANOID ::                                               */
+  /*   Only for font debugging.  Checks that a table follows the           */
+  /*   specification by 100%.  Very few fonts will be able to pass this    */
+  /*   level anyway but it can be useful for certain tools like font       */
+  /*   editors/converters.                                                 */
+  /*                                                                       */
+  typedef enum  FT_ValidationLevel_
+  {
+    FT_VALIDATE_DEFAULT = 0,
+    FT_VALIDATE_TIGHT,
+    FT_VALIDATE_PARANOID
+
+  } FT_ValidationLevel;
+
+
+  /* validator structure */
+  typedef struct  FT_ValidatorRec_
+  {
+    const FT_Byte*      base;        /* address of table in memory       */
+    const FT_Byte*      limit;       /* `base' + sizeof(table) in memory */
+    FT_ValidationLevel  level;       /* validation level                 */
+    FT_Error            error;       /* error returned. 0 means success  */
+
+    ft_jmp_buf          jump_buffer; /* used for exception handling      */
+
+  } FT_ValidatorRec;
+
+
+#define FT_VALIDATOR( x )  ((FT_Validator)( x ))
+
+
+  FT_BASE( void )
+  ft_validator_init( FT_Validator        valid,
+                     const FT_Byte*      base,
+                     const FT_Byte*      limit,
+                     FT_ValidationLevel  level );
+
+  /* Do not use this. It's broken and will cause your validator to crash */
+  /* if you run it on an invalid font.                                   */
+  FT_BASE( FT_Int )
+  ft_validator_run( FT_Validator  valid );
+
+  /* Sets the error field in a validator, then calls `longjmp' to return */
+  /* to high-level caller.  Using `setjmp/longjmp' avoids many stupid    */
+  /* error checks within the validation routines.                        */
+  /*                                                                     */
+  FT_BASE( void )
+  ft_validator_error( FT_Validator  valid,
+                      FT_Error      error );
+
+
+  /* Calls ft_validate_error.  Assumes that the `valid' local variable */
+  /* holds a pointer to the current validator object.                  */
+  /*                                                                   */
+  /* Use preprocessor prescan to pass FT_ERR_PREFIX.                   */
+  /*                                                                   */
+#define FT_INVALID( _prefix, _error )  FT_INVALID_( _prefix, _error )
+#define FT_INVALID_( _prefix, _error ) \
+          ft_validator_error( valid, _prefix ## _error )
+
+  /* called when a broken table is detected */
+#define FT_INVALID_TOO_SHORT \
+          FT_INVALID( FT_ERR_PREFIX, Invalid_Table )
+
+  /* called when an invalid offset is detected */
+#define FT_INVALID_OFFSET \
+          FT_INVALID( FT_ERR_PREFIX, Invalid_Offset )
+
+  /* called when an invalid format/value is detected */
+#define FT_INVALID_FORMAT \
+          FT_INVALID( FT_ERR_PREFIX, Invalid_Table )
+
+  /* called when an invalid glyph index is detected */
+#define FT_INVALID_GLYPH_ID \
+          FT_INVALID( FT_ERR_PREFIX, Invalid_Glyph_Index )
+
+  /* called when an invalid field value is detected */
+#define FT_INVALID_DATA \
+          FT_INVALID( FT_ERR_PREFIX, Invalid_Table )
+
+
+FT_END_HEADER
+
+#endif /* __FTVALID_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/internal.h b/include/freetype/internal/internal.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/internal.h
@@ -0,0 +1,51 @@
+/***************************************************************************/
+/*                                                                         */
+/*  internal.h                                                             */
+/*                                                                         */
+/*    Internal header files (specification only).                          */
+/*                                                                         */
+/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This file is automatically included by `ft2build.h'.                  */
+  /* Do not include it manually!                                           */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#define FT_INTERNAL_OBJECTS_H             <freetype/internal/ftobjs.h>
+#define FT_INTERNAL_PIC_H                 <freetype/internal/ftpic.h>
+#define FT_INTERNAL_STREAM_H              <freetype/internal/ftstream.h>
+#define FT_INTERNAL_MEMORY_H              <freetype/internal/ftmemory.h>
+#define FT_INTERNAL_DEBUG_H               <freetype/internal/ftdebug.h>
+#define FT_INTERNAL_CALC_H                <freetype/internal/ftcalc.h>
+#define FT_INTERNAL_DRIVER_H              <freetype/internal/ftdriver.h>
+#define FT_INTERNAL_TRACE_H               <freetype/internal/fttrace.h>
+#define FT_INTERNAL_GLYPH_LOADER_H        <freetype/internal/ftgloadr.h>
+#define FT_INTERNAL_SFNT_H                <freetype/internal/sfnt.h>
+#define FT_INTERNAL_SERVICE_H             <freetype/internal/ftserv.h>
+#define FT_INTERNAL_RFORK_H               <freetype/internal/ftrfork.h>
+#define FT_INTERNAL_VALIDATE_H            <freetype/internal/ftvalid.h>
+
+#define FT_INTERNAL_TRUETYPE_TYPES_H      <freetype/internal/tttypes.h>
+#define FT_INTERNAL_TYPE1_TYPES_H         <freetype/internal/t1types.h>
+
+#define FT_INTERNAL_POSTSCRIPT_AUX_H      <freetype/internal/psaux.h>
+#define FT_INTERNAL_POSTSCRIPT_HINTS_H    <freetype/internal/pshints.h>
+#define FT_INTERNAL_POSTSCRIPT_GLOBALS_H  <freetype/internal/psglobal.h>
+
+#define FT_INTERNAL_AUTOHINT_H            <freetype/internal/autohint.h>
+
+
+/* END */
diff --git a/include/freetype/internal/psaux.h b/include/freetype/internal/psaux.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/psaux.h
@@ -0,0 +1,873 @@
+/***************************************************************************/
+/*                                                                         */
+/*  psaux.h                                                                */
+/*                                                                         */
+/*    Auxiliary functions and data structures related to PostScript fonts  */
+/*    (specification).                                                     */
+/*                                                                         */
+/*  Copyright 1996-2004, 2006, 2008, 2009, 2012 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __PSAUX_H__
+#define __PSAUX_H__
+
+
+#include <ft2build.h>
+#include FT_INTERNAL_OBJECTS_H
+#include FT_INTERNAL_TYPE1_TYPES_H
+#include FT_SERVICE_POSTSCRIPT_CMAPS_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                             T1_TABLE                          *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  typedef struct PS_TableRec_*              PS_Table;
+  typedef const struct PS_Table_FuncsRec_*  PS_Table_Funcs;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_Table_FuncsRec                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A set of function pointers to manage PS_Table objects.             */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    table_init    :: Used to initialize a table.                       */
+  /*                                                                       */
+  /*    table_done    :: Finalizes resp. destroy a given table.            */
+  /*                                                                       */
+  /*    table_add     :: Adds a new object to a table.                     */
+  /*                                                                       */
+  /*    table_release :: Releases table data, then finalizes it.           */
+  /*                                                                       */
+  typedef struct  PS_Table_FuncsRec_
+  {
+    FT_Error
+    (*init)( PS_Table   table,
+             FT_Int     count,
+             FT_Memory  memory );
+
+    void
+    (*done)( PS_Table  table );
+
+    FT_Error
+    (*add)( PS_Table    table,
+            FT_Int      idx,
+            void*       object,
+            FT_PtrDist  length );
+
+    void
+    (*release)( PS_Table  table );
+
+  } PS_Table_FuncsRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_TableRec                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A PS_Table is a simple object used to store an array of objects in */
+  /*    a single memory block.                                             */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    block     :: The address in memory of the growheap's block.  This  */
+  /*                 can change between two object adds, due to            */
+  /*                 reallocation.                                         */
+  /*                                                                       */
+  /*    cursor    :: The current top of the grow heap within its block.    */
+  /*                                                                       */
+  /*    capacity  :: The current size of the heap block.  Increments by    */
+  /*                 1kByte chunks.                                        */
+  /*                                                                       */
+  /*    max_elems :: The maximum number of elements in table.              */
+  /*                                                                       */
+  /*    num_elems :: The current number of elements in table.              */
+  /*                                                                       */
+  /*    elements  :: A table of element addresses within the block.        */
+  /*                                                                       */
+  /*    lengths   :: A table of element sizes within the block.            */
+  /*                                                                       */
+  /*    memory    :: The object used for memory operations                 */
+  /*                 (alloc/realloc).                                      */
+  /*                                                                       */
+  /*    funcs     :: A table of method pointers for this object.           */
+  /*                                                                       */
+  typedef struct  PS_TableRec_
+  {
+    FT_Byte*           block;          /* current memory block           */
+    FT_Offset          cursor;         /* current cursor in memory block */
+    FT_Offset          capacity;       /* current size of memory block   */
+    FT_Long            init;
+
+    FT_Int             max_elems;
+    FT_Int             num_elems;
+    FT_Byte**          elements;       /* addresses of table elements */
+    FT_PtrDist*        lengths;        /* lengths of table elements   */
+
+    FT_Memory          memory;
+    PS_Table_FuncsRec  funcs;
+
+  } PS_TableRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                       T1 FIELDS & TOKENS                      *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef struct PS_ParserRec_*  PS_Parser;
+
+  typedef struct T1_TokenRec_*   T1_Token;
+
+  typedef struct T1_FieldRec_*   T1_Field;
+
+
+  /* simple enumeration type used to identify token types */
+  typedef enum  T1_TokenType_
+  {
+    T1_TOKEN_TYPE_NONE = 0,
+    T1_TOKEN_TYPE_ANY,
+    T1_TOKEN_TYPE_STRING,
+    T1_TOKEN_TYPE_ARRAY,
+    T1_TOKEN_TYPE_KEY, /* aka `name' */
+
+    /* do not remove */
+    T1_TOKEN_TYPE_MAX
+
+  } T1_TokenType;
+
+
+  /* a simple structure used to identify tokens */
+  typedef struct  T1_TokenRec_
+  {
+    FT_Byte*      start;   /* first character of token in input stream */
+    FT_Byte*      limit;   /* first character after the token          */
+    T1_TokenType  type;    /* type of token                            */
+
+  } T1_TokenRec;
+
+
+  /* enumeration type used to identify object fields */
+  typedef enum  T1_FieldType_
+  {
+    T1_FIELD_TYPE_NONE = 0,
+    T1_FIELD_TYPE_BOOL,
+    T1_FIELD_TYPE_INTEGER,
+    T1_FIELD_TYPE_FIXED,
+    T1_FIELD_TYPE_FIXED_1000,
+    T1_FIELD_TYPE_STRING,
+    T1_FIELD_TYPE_KEY,
+    T1_FIELD_TYPE_BBOX,
+    T1_FIELD_TYPE_INTEGER_ARRAY,
+    T1_FIELD_TYPE_FIXED_ARRAY,
+    T1_FIELD_TYPE_CALLBACK,
+
+    /* do not remove */
+    T1_FIELD_TYPE_MAX
+
+  } T1_FieldType;
+
+
+  typedef enum  T1_FieldLocation_
+  {
+    T1_FIELD_LOCATION_CID_INFO,
+    T1_FIELD_LOCATION_FONT_DICT,
+    T1_FIELD_LOCATION_FONT_EXTRA,
+    T1_FIELD_LOCATION_FONT_INFO,
+    T1_FIELD_LOCATION_PRIVATE,
+    T1_FIELD_LOCATION_BBOX,
+    T1_FIELD_LOCATION_LOADER,
+    T1_FIELD_LOCATION_FACE,
+    T1_FIELD_LOCATION_BLEND,
+
+    /* do not remove */
+    T1_FIELD_LOCATION_MAX
+
+  } T1_FieldLocation;
+
+
+  typedef void
+  (*T1_Field_ParseFunc)( FT_Face     face,
+                         FT_Pointer  parser );
+
+
+  /* structure type used to model object fields */
+  typedef struct  T1_FieldRec_
+  {
+    const char*         ident;        /* field identifier               */
+    T1_FieldLocation    location;
+    T1_FieldType        type;         /* type of field                  */
+    T1_Field_ParseFunc  reader;
+    FT_UInt             offset;       /* offset of field in object      */
+    FT_Byte             size;         /* size of field in bytes         */
+    FT_UInt             array_max;    /* maximum number of elements for */
+                                      /* array                          */
+    FT_UInt             count_offset; /* offset of element count for    */
+                                      /* arrays; must not be zero if in */
+                                      /* use -- in other words, a       */
+                                      /* `num_FOO' element must not     */
+                                      /* start the used structure if we */
+                                      /* parse a `FOO' array            */
+    FT_UInt             dict;         /* where we expect it             */
+  } T1_FieldRec;
+
+#define T1_FIELD_DICT_FONTDICT ( 1 << 0 ) /* also FontInfo and FDArray */
+#define T1_FIELD_DICT_PRIVATE  ( 1 << 1 )
+
+
+
+#define T1_NEW_SIMPLE_FIELD( _ident, _type, _fname, _dict ) \
+          {                                                 \
+            _ident, T1CODE, _type,                          \
+            0,                                              \
+            FT_FIELD_OFFSET( _fname ),                      \
+            FT_FIELD_SIZE( _fname ),                        \
+            0, 0,                                           \
+            _dict                                           \
+          },
+
+#define T1_NEW_CALLBACK_FIELD( _ident, _reader, _dict ) \
+          {                                             \
+            _ident, T1CODE, T1_FIELD_TYPE_CALLBACK,     \
+            (T1_Field_ParseFunc)_reader,                \
+            0, 0,                                       \
+            0, 0,                                       \
+            _dict                                       \
+          },
+
+#define T1_NEW_TABLE_FIELD( _ident, _type, _fname, _max, _dict ) \
+          {                                                      \
+            _ident, T1CODE, _type,                               \
+            0,                                                   \
+            FT_FIELD_OFFSET( _fname ),                           \
+            FT_FIELD_SIZE_DELTA( _fname ),                       \
+            _max,                                                \
+            FT_FIELD_OFFSET( num_ ## _fname ),                   \
+            _dict                                                \
+          },
+
+#define T1_NEW_TABLE_FIELD2( _ident, _type, _fname, _max, _dict ) \
+          {                                                       \
+            _ident, T1CODE, _type,                                \
+            0,                                                    \
+            FT_FIELD_OFFSET( _fname ),                            \
+            FT_FIELD_SIZE_DELTA( _fname ),                        \
+            _max, 0,                                              \
+            _dict                                                 \
+          },
+
+
+#define T1_FIELD_BOOL( _ident, _fname, _dict )                             \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_BOOL, _fname, _dict )
+
+#define T1_FIELD_NUM( _ident, _fname, _dict )                                 \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_INTEGER, _fname, _dict )
+
+#define T1_FIELD_FIXED( _ident, _fname, _dict )                             \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_FIXED, _fname, _dict )
+
+#define T1_FIELD_FIXED_1000( _ident, _fname, _dict )                     \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_FIXED_1000, _fname, \
+                               _dict )
+
+#define T1_FIELD_STRING( _ident, _fname, _dict )                             \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_STRING, _fname, _dict )
+
+#define T1_FIELD_KEY( _ident, _fname, _dict )                             \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_KEY, _fname, _dict )
+
+#define T1_FIELD_BBOX( _ident, _fname, _dict )                             \
+          T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_BBOX, _fname, _dict )
+
+
+#define T1_FIELD_NUM_TABLE( _ident, _fname, _fmax, _dict )         \
+          T1_NEW_TABLE_FIELD( _ident, T1_FIELD_TYPE_INTEGER_ARRAY, \
+                              _fname, _fmax, _dict )
+
+#define T1_FIELD_FIXED_TABLE( _ident, _fname, _fmax, _dict )     \
+          T1_NEW_TABLE_FIELD( _ident, T1_FIELD_TYPE_FIXED_ARRAY, \
+                              _fname, _fmax, _dict )
+
+#define T1_FIELD_NUM_TABLE2( _ident, _fname, _fmax, _dict )         \
+          T1_NEW_TABLE_FIELD2( _ident, T1_FIELD_TYPE_INTEGER_ARRAY, \
+                               _fname, _fmax, _dict )
+
+#define T1_FIELD_FIXED_TABLE2( _ident, _fname, _fmax, _dict )     \
+          T1_NEW_TABLE_FIELD2( _ident, T1_FIELD_TYPE_FIXED_ARRAY, \
+                               _fname, _fmax, _dict )
+
+#define T1_FIELD_CALLBACK( _ident, _name, _dict )       \
+          T1_NEW_CALLBACK_FIELD( _ident, _name, _dict )
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                            T1 PARSER                          *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef const struct PS_Parser_FuncsRec_*  PS_Parser_Funcs;
+
+  typedef struct  PS_Parser_FuncsRec_
+  {
+    void
+    (*init)( PS_Parser  parser,
+             FT_Byte*   base,
+             FT_Byte*   limit,
+             FT_Memory  memory );
+
+    void
+    (*done)( PS_Parser  parser );
+
+    void
+    (*skip_spaces)( PS_Parser  parser );
+    void
+    (*skip_PS_token)( PS_Parser  parser );
+
+    FT_Long
+    (*to_int)( PS_Parser  parser );
+    FT_Fixed
+    (*to_fixed)( PS_Parser  parser,
+                 FT_Int     power_ten );
+
+    FT_Error
+    (*to_bytes)( PS_Parser  parser,
+                 FT_Byte*   bytes,
+                 FT_Offset  max_bytes,
+                 FT_Long*   pnum_bytes,
+                 FT_Bool    delimiters );
+
+    FT_Int
+    (*to_coord_array)( PS_Parser  parser,
+                       FT_Int     max_coords,
+                       FT_Short*  coords );
+    FT_Int
+    (*to_fixed_array)( PS_Parser  parser,
+                       FT_Int     max_values,
+                       FT_Fixed*  values,
+                       FT_Int     power_ten );
+
+    void
+    (*to_token)( PS_Parser  parser,
+                 T1_Token   token );
+    void
+    (*to_token_array)( PS_Parser  parser,
+                       T1_Token   tokens,
+                       FT_UInt    max_tokens,
+                       FT_Int*    pnum_tokens );
+
+    FT_Error
+    (*load_field)( PS_Parser       parser,
+                   const T1_Field  field,
+                   void**          objects,
+                   FT_UInt         max_objects,
+                   FT_ULong*       pflags );
+
+    FT_Error
+    (*load_field_table)( PS_Parser       parser,
+                         const T1_Field  field,
+                         void**          objects,
+                         FT_UInt         max_objects,
+                         FT_ULong*       pflags );
+
+  } PS_Parser_FuncsRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_ParserRec                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A PS_Parser is an object used to parse a Type 1 font very quickly. */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    cursor :: The current position in the text.                        */
+  /*                                                                       */
+  /*    base   :: Start of the processed text.                             */
+  /*                                                                       */
+  /*    limit  :: End of the processed text.                               */
+  /*                                                                       */
+  /*    error  :: The last error returned.                                 */
+  /*                                                                       */
+  /*    memory :: The object used for memory operations (alloc/realloc).   */
+  /*                                                                       */
+  /*    funcs  :: A table of functions for the parser.                     */
+  /*                                                                       */
+  typedef struct  PS_ParserRec_
+  {
+    FT_Byte*   cursor;
+    FT_Byte*   base;
+    FT_Byte*   limit;
+    FT_Error   error;
+    FT_Memory  memory;
+
+    PS_Parser_FuncsRec  funcs;
+
+  } PS_ParserRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                         T1 BUILDER                            *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  typedef struct T1_BuilderRec_*  T1_Builder;
+
+
+  typedef FT_Error
+  (*T1_Builder_Check_Points_Func)( T1_Builder  builder,
+                                   FT_Int      count );
+
+  typedef void
+  (*T1_Builder_Add_Point_Func)( T1_Builder  builder,
+                                FT_Pos      x,
+                                FT_Pos      y,
+                                FT_Byte     flag );
+
+  typedef FT_Error
+  (*T1_Builder_Add_Point1_Func)( T1_Builder  builder,
+                                 FT_Pos      x,
+                                 FT_Pos      y );
+
+  typedef FT_Error
+  (*T1_Builder_Add_Contour_Func)( T1_Builder  builder );
+
+  typedef FT_Error
+  (*T1_Builder_Start_Point_Func)( T1_Builder  builder,
+                                  FT_Pos      x,
+                                  FT_Pos      y );
+
+  typedef void
+  (*T1_Builder_Close_Contour_Func)( T1_Builder  builder );
+
+
+  typedef const struct T1_Builder_FuncsRec_*  T1_Builder_Funcs;
+
+  typedef struct  T1_Builder_FuncsRec_
+  {
+    void
+    (*init)( T1_Builder    builder,
+             FT_Face       face,
+             FT_Size       size,
+             FT_GlyphSlot  slot,
+             FT_Bool       hinting );
+
+    void
+    (*done)( T1_Builder   builder );
+
+    T1_Builder_Check_Points_Func   check_points;
+    T1_Builder_Add_Point_Func      add_point;
+    T1_Builder_Add_Point1_Func     add_point1;
+    T1_Builder_Add_Contour_Func    add_contour;
+    T1_Builder_Start_Point_Func    start_point;
+    T1_Builder_Close_Contour_Func  close_contour;
+
+  } T1_Builder_FuncsRec;
+
+
+  /* an enumeration type to handle charstring parsing states */
+  typedef enum  T1_ParseState_
+  {
+    T1_Parse_Start,
+    T1_Parse_Have_Width,
+    T1_Parse_Have_Moveto,
+    T1_Parse_Have_Path
+
+  } T1_ParseState;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Structure>                                                           */
+  /*    T1_BuilderRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*     A structure used during glyph loading to store its outline.       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    memory       :: The current memory object.                         */
+  /*                                                                       */
+  /*    face         :: The current face object.                           */
+  /*                                                                       */
+  /*    glyph        :: The current glyph slot.                            */
+  /*                                                                       */
+  /*    loader       :: XXX                                                */
+  /*                                                                       */
+  /*    base         :: The base glyph outline.                            */
+  /*                                                                       */
+  /*    current      :: The current glyph outline.                         */
+  /*                                                                       */
+  /*    max_points   :: maximum points in builder outline                  */
+  /*                                                                       */
+  /*    max_contours :: Maximum number of contours in builder outline.     */
+  /*                                                                       */
+  /*    pos_x        :: The horizontal translation (if composite glyph).   */
+  /*                                                                       */
+  /*    pos_y        :: The vertical translation (if composite glyph).     */
+  /*                                                                       */
+  /*    left_bearing :: The left side bearing point.                       */
+  /*                                                                       */
+  /*    advance      :: The horizontal advance vector.                     */
+  /*                                                                       */
+  /*    bbox         :: Unused.                                            */
+  /*                                                                       */
+  /*    parse_state  :: An enumeration which controls the charstring       */
+  /*                    parsing state.                                     */
+  /*                                                                       */
+  /*    load_points  :: If this flag is not set, no points are loaded.     */
+  /*                                                                       */
+  /*    no_recurse   :: Set but not used.                                  */
+  /*                                                                       */
+  /*    metrics_only :: A boolean indicating that we only want to compute  */
+  /*                    the metrics of a given glyph, not load all of its  */
+  /*                    points.                                            */
+  /*                                                                       */
+  /*    funcs        :: An array of function pointers for the builder.     */
+  /*                                                                       */
+  typedef struct  T1_BuilderRec_
+  {
+    FT_Memory       memory;
+    FT_Face         face;
+    FT_GlyphSlot    glyph;
+    FT_GlyphLoader  loader;
+    FT_Outline*     base;
+    FT_Outline*     current;
+
+    FT_Pos          pos_x;
+    FT_Pos          pos_y;
+
+    FT_Vector       left_bearing;
+    FT_Vector       advance;
+
+    FT_BBox         bbox;          /* bounding box */
+    T1_ParseState   parse_state;
+    FT_Bool         load_points;
+    FT_Bool         no_recurse;
+
+    FT_Bool         metrics_only;
+
+    void*           hints_funcs;    /* hinter-specific */
+    void*           hints_globals;  /* hinter-specific */
+
+    T1_Builder_FuncsRec  funcs;
+
+  } T1_BuilderRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                         T1 DECODER                            *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+#if 0
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
+  /* calls during glyph loading.                                           */
+  /*                                                                       */
+#define T1_MAX_SUBRS_CALLS  8
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
+  /* minimum of 16 is required.                                            */
+  /*                                                                       */
+#define T1_MAX_CHARSTRINGS_OPERANDS  32
+
+#endif /* 0 */
+
+
+  typedef struct  T1_Decoder_ZoneRec_
+  {
+    FT_Byte*  cursor;
+    FT_Byte*  base;
+    FT_Byte*  limit;
+
+  } T1_Decoder_ZoneRec, *T1_Decoder_Zone;
+
+
+  typedef struct T1_DecoderRec_*              T1_Decoder;
+  typedef const struct T1_Decoder_FuncsRec_*  T1_Decoder_Funcs;
+
+
+  typedef FT_Error
+  (*T1_Decoder_Callback)( T1_Decoder  decoder,
+                          FT_UInt     glyph_index );
+
+
+  typedef struct  T1_Decoder_FuncsRec_
+  {
+    FT_Error
+    (*init)( T1_Decoder           decoder,
+             FT_Face              face,
+             FT_Size              size,
+             FT_GlyphSlot         slot,
+             FT_Byte**            glyph_names,
+             PS_Blend             blend,
+             FT_Bool              hinting,
+             FT_Render_Mode       hint_mode,
+             T1_Decoder_Callback  callback );
+
+    void
+    (*done)( T1_Decoder  decoder );
+
+    FT_Error
+    (*parse_charstrings)( T1_Decoder  decoder,
+                          FT_Byte*    base,
+                          FT_UInt     len );
+
+  } T1_Decoder_FuncsRec;
+
+
+  typedef struct  T1_DecoderRec_
+  {
+    T1_BuilderRec        builder;
+
+    FT_Long              stack[T1_MAX_CHARSTRINGS_OPERANDS];
+    FT_Long*             top;
+
+    T1_Decoder_ZoneRec   zones[T1_MAX_SUBRS_CALLS + 1];
+    T1_Decoder_Zone      zone;
+
+    FT_Service_PsCMaps   psnames;      /* for seac */
+    FT_UInt              num_glyphs;
+    FT_Byte**            glyph_names;
+
+    FT_Int               lenIV;        /* internal for sub routine calls */
+    FT_UInt              num_subrs;
+    FT_Byte**            subrs;
+    FT_PtrDist*          subrs_len;    /* array of subrs length (optional) */
+
+    FT_Matrix            font_matrix;
+    FT_Vector            font_offset;
+
+    FT_Int               flex_state;
+    FT_Int               num_flex_vectors;
+    FT_Vector            flex_vectors[7];
+
+    PS_Blend             blend;       /* for multiple master support */
+
+    FT_Render_Mode       hint_mode;
+
+    T1_Decoder_Callback  parse_callback;
+    T1_Decoder_FuncsRec  funcs;
+
+    FT_Long*             buildchar;
+    FT_UInt              len_buildchar;
+
+    FT_Bool              seac;
+
+  } T1_DecoderRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                            AFM PARSER                         *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef struct AFM_ParserRec_*  AFM_Parser;
+
+  typedef struct  AFM_Parser_FuncsRec_
+  {
+    FT_Error
+    (*init)( AFM_Parser  parser,
+             FT_Memory   memory,
+             FT_Byte*    base,
+             FT_Byte*    limit );
+
+    void
+    (*done)( AFM_Parser  parser );
+
+    FT_Error
+    (*parse)( AFM_Parser  parser );
+
+  } AFM_Parser_FuncsRec;
+
+
+  typedef struct AFM_StreamRec_*  AFM_Stream;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    AFM_ParserRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An AFM_Parser is a parser for the AFM files.                       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    memory    :: The object used for memory operations (alloc and      */
+  /*                 realloc).                                             */
+  /*                                                                       */
+  /*    stream    :: This is an opaque object.                             */
+  /*                                                                       */
+  /*    FontInfo  :: The result will be stored here.                       */
+  /*                                                                       */
+  /*    get_index :: A user provided function to get a glyph index by its  */
+  /*                 name.                                                 */
+  /*                                                                       */
+  typedef struct  AFM_ParserRec_
+  {
+    FT_Memory     memory;
+    AFM_Stream    stream;
+
+    AFM_FontInfo  FontInfo;
+
+    FT_Int
+    (*get_index)( const char*  name,
+                  FT_Offset    len,
+                  void*        user_data );
+
+    void*         user_data;
+
+  } AFM_ParserRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                     TYPE1 CHARMAPS                            *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef const struct T1_CMap_ClassesRec_*  T1_CMap_Classes;
+
+  typedef struct T1_CMap_ClassesRec_
+  {
+    FT_CMap_Class  standard;
+    FT_CMap_Class  expert;
+    FT_CMap_Class  custom;
+    FT_CMap_Class  unicode;
+
+  } T1_CMap_ClassesRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                        PSAux Module Interface                 *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef struct  PSAux_ServiceRec_
+  {
+    /* don't use `PS_Table_Funcs' and friends to avoid compiler warnings */
+    const PS_Table_FuncsRec*    ps_table_funcs;
+    const PS_Parser_FuncsRec*   ps_parser_funcs;
+    const T1_Builder_FuncsRec*  t1_builder_funcs;
+    const T1_Decoder_FuncsRec*  t1_decoder_funcs;
+
+    void
+    (*t1_decrypt)( FT_Byte*   buffer,
+                   FT_Offset  length,
+                   FT_UShort  seed );
+
+    T1_CMap_Classes  t1_cmap_classes;
+
+    /* fields after this comment line were added after version 2.1.10 */
+    const AFM_Parser_FuncsRec*  afm_parser_funcs;
+
+  } PSAux_ServiceRec, *PSAux_Service;
+
+  /* backwards-compatible type definition */
+  typedef PSAux_ServiceRec   PSAux_Interface;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                 Some convenience functions                    *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+#define IS_PS_NEWLINE( ch ) \
+  ( (ch) == '\r' ||         \
+    (ch) == '\n' )
+
+#define IS_PS_SPACE( ch )  \
+  ( (ch) == ' '         || \
+    IS_PS_NEWLINE( ch ) || \
+    (ch) == '\t'        || \
+    (ch) == '\f'        || \
+    (ch) == '\0' )
+
+#define IS_PS_SPECIAL( ch )       \
+  ( (ch) == '/'                || \
+    (ch) == '(' || (ch) == ')' || \
+    (ch) == '<' || (ch) == '>' || \
+    (ch) == '[' || (ch) == ']' || \
+    (ch) == '{' || (ch) == '}' || \
+    (ch) == '%'                )
+
+#define IS_PS_DELIM( ch )  \
+  ( IS_PS_SPACE( ch )   || \
+    IS_PS_SPECIAL( ch ) )
+
+#define IS_PS_DIGIT( ch )        \
+  ( (ch) >= '0' && (ch) <= '9' )
+
+#define IS_PS_XDIGIT( ch )            \
+  ( IS_PS_DIGIT( ch )              || \
+    ( (ch) >= 'A' && (ch) <= 'F' ) || \
+    ( (ch) >= 'a' && (ch) <= 'f' ) )
+
+#define IS_PS_BASE85( ch )       \
+  ( (ch) >= '!' && (ch) <= 'u' )
+
+#define IS_PS_TOKEN( cur, limit, token )                                \
+  ( (char)(cur)[0] == (token)[0]                                     && \
+    ( (cur) + sizeof ( (token) ) == (limit) ||                          \
+      ( (cur) + sizeof( (token) ) < (limit)          &&                 \
+        IS_PS_DELIM( (cur)[sizeof ( (token) ) - 1] ) ) )             && \
+    ft_strncmp( (char*)(cur), (token), sizeof ( (token) ) - 1 ) == 0 )
+
+
+FT_END_HEADER
+
+#endif /* __PSAUX_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/pshints.h b/include/freetype/internal/pshints.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/pshints.h
@@ -0,0 +1,722 @@
+/***************************************************************************/
+/*                                                                         */
+/*  pshints.h                                                              */
+/*                                                                         */
+/*    Interface to Postscript-specific (Type 1 and Type 2) hints           */
+/*    recorders (specification only).  These are used to support native    */
+/*    T1/T2 hints in the `type1', `cid', and `cff' font drivers.           */
+/*                                                                         */
+/*  Copyright 2001-2003, 2005-2007, 2009, 2012 by                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __PSHINTS_H__
+#define __PSHINTS_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_TYPE1_TABLES_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****               INTERNAL REPRESENTATION OF GLOBALS              *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef struct PSH_GlobalsRec_*  PSH_Globals;
+
+  typedef FT_Error
+  (*PSH_Globals_NewFunc)( FT_Memory     memory,
+                          T1_Private*   private_dict,
+                          PSH_Globals*  aglobals );
+
+  typedef FT_Error
+  (*PSH_Globals_SetScaleFunc)( PSH_Globals  globals,
+                               FT_Fixed     x_scale,
+                               FT_Fixed     y_scale,
+                               FT_Fixed     x_delta,
+                               FT_Fixed     y_delta );
+
+  typedef void
+  (*PSH_Globals_DestroyFunc)( PSH_Globals  globals );
+
+
+  typedef struct  PSH_Globals_FuncsRec_
+  {
+    PSH_Globals_NewFunc       create;
+    PSH_Globals_SetScaleFunc  set_scale;
+    PSH_Globals_DestroyFunc   destroy;
+
+  } PSH_Globals_FuncsRec, *PSH_Globals_Funcs;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                  PUBLIC TYPE 1 HINTS RECORDER                 *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************
+   *
+   * @type:
+   *   T1_Hints
+   *
+   * @description:
+   *   This is a handle to an opaque structure used to record glyph hints
+   *   from a Type 1 character glyph character string.
+   *
+   *   The methods used to operate on this object are defined by the
+   *   @T1_Hints_FuncsRec structure.  Recording glyph hints is normally
+   *   achieved through the following scheme:
+   *
+   *   - Open a new hint recording session by calling the `open' method.
+   *     This rewinds the recorder and prepare it for new input.
+   *
+   *   - For each hint found in the glyph charstring, call the corresponding
+   *     method (`stem', `stem3', or `reset').  Note that these functions do
+   *     not return an error code.
+   *
+   *   - Close the recording session by calling the `close' method.  It
+   *     returns an error code if the hints were invalid or something
+   *     strange happened (e.g., memory shortage).
+   *
+   *   The hints accumulated in the object can later be used by the
+   *   PostScript hinter.
+   *
+   */
+  typedef struct T1_HintsRec_*  T1_Hints;
+
+
+  /*************************************************************************
+   *
+   * @type:
+   *   T1_Hints_Funcs
+   *
+   * @description:
+   *   A pointer to the @T1_Hints_FuncsRec structure that defines the API of
+   *   a given @T1_Hints object.
+   *
+   */
+  typedef const struct T1_Hints_FuncsRec_*  T1_Hints_Funcs;
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T1_Hints_OpenFunc
+   *
+   * @description:
+   *   A method of the @T1_Hints class used to prepare it for a new Type 1
+   *   hints recording session.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 1 hints recorder.
+   *
+   * @note:
+   *   You should always call the @T1_Hints_CloseFunc method in order to
+   *   close an opened recording session.
+   *
+   */
+  typedef void
+  (*T1_Hints_OpenFunc)( T1_Hints  hints );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T1_Hints_SetStemFunc
+   *
+   * @description:
+   *   A method of the @T1_Hints class used to record a new horizontal or
+   *   vertical stem.  This corresponds to the Type 1 `hstem' and `vstem'
+   *   operators.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 1 hints recorder.
+   *
+   *   dimension ::
+   *     0 for horizontal stems (hstem), 1 for vertical ones (vstem).
+   *
+   *   coords ::
+   *     Array of 2 coordinates in 16.16 format, used as (position,length)
+   *     stem descriptor.
+   *
+   * @note:
+   *   Use vertical coordinates (y) for horizontal stems (dim=0).  Use
+   *   horizontal coordinates (x) for vertical stems (dim=1).
+   *
+   *   `coords[0]' is the absolute stem position (lowest coordinate);
+   *   `coords[1]' is the length.
+   *
+   *   The length can be negative, in which case it must be either -20 or
+   *   -21.  It is interpreted as a `ghost' stem, according to the Type 1
+   *   specification.
+   *
+   *   If the length is -21 (corresponding to a bottom ghost stem), then
+   *   the real stem position is `coords[0]+coords[1]'.
+   *
+   */
+  typedef void
+  (*T1_Hints_SetStemFunc)( T1_Hints   hints,
+                           FT_UInt    dimension,
+                           FT_Fixed*  coords );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T1_Hints_SetStem3Func
+   *
+   * @description:
+   *   A method of the @T1_Hints class used to record three
+   *   counter-controlled horizontal or vertical stems at once.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 1 hints recorder.
+   *
+   *   dimension ::
+   *     0 for horizontal stems, 1 for vertical ones.
+   *
+   *   coords ::
+   *     An array of 6 values in 16.16 format, holding 3 (position,length)
+   *     pairs for the counter-controlled stems.
+   *
+   * @note:
+   *   Use vertical coordinates (y) for horizontal stems (dim=0).  Use
+   *   horizontal coordinates (x) for vertical stems (dim=1).
+   *
+   *   The lengths cannot be negative (ghost stems are never
+   *   counter-controlled).
+   *
+   */
+  typedef void
+  (*T1_Hints_SetStem3Func)( T1_Hints   hints,
+                            FT_UInt    dimension,
+                            FT_Fixed*  coords );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T1_Hints_ResetFunc
+   *
+   * @description:
+   *   A method of the @T1_Hints class used to reset the stems hints in a
+   *   recording session.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 1 hints recorder.
+   *
+   *   end_point ::
+   *     The index of the last point in the input glyph in which the
+   *     previously defined hints apply.
+   *
+   */
+  typedef void
+  (*T1_Hints_ResetFunc)( T1_Hints  hints,
+                         FT_UInt   end_point );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T1_Hints_CloseFunc
+   *
+   * @description:
+   *   A method of the @T1_Hints class used to close a hint recording
+   *   session.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 1 hints recorder.
+   *
+   *   end_point ::
+   *     The index of the last point in the input glyph.
+   *
+   * @return:
+   *   FreeType error code.  0 means success.
+   *
+   * @note:
+   *   The error code is set to indicate that an error occurred during the
+   *   recording session.
+   *
+   */
+  typedef FT_Error
+  (*T1_Hints_CloseFunc)( T1_Hints  hints,
+                         FT_UInt   end_point );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T1_Hints_ApplyFunc
+   *
+   * @description:
+   *   A method of the @T1_Hints class used to apply hints to the
+   *   corresponding glyph outline.  Must be called once all hints have been
+   *   recorded.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 1 hints recorder.
+   *
+   *   outline ::
+   *     A pointer to the target outline descriptor.
+   *
+   *   globals ::
+   *     The hinter globals for this font.
+   *
+   *   hint_mode ::
+   *     Hinting information.
+   *
+   * @return:
+   *   FreeType error code.  0 means success.
+   *
+   * @note:
+   *   On input, all points within the outline are in font coordinates. On
+   *   output, they are in 1/64th of pixels.
+   *
+   *   The scaling transformation is taken from the `globals' object which
+   *   must correspond to the same font as the glyph.
+   *
+   */
+  typedef FT_Error
+  (*T1_Hints_ApplyFunc)( T1_Hints        hints,
+                         FT_Outline*     outline,
+                         PSH_Globals     globals,
+                         FT_Render_Mode  hint_mode );
+
+
+  /*************************************************************************
+   *
+   * @struct:
+   *   T1_Hints_FuncsRec
+   *
+   * @description:
+   *   The structure used to provide the API to @T1_Hints objects.
+   *
+   * @fields:
+   *   hints ::
+   *     A handle to the T1 Hints recorder.
+   *
+   *   open ::
+   *     The function to open a recording session.
+   *
+   *   close ::
+   *     The function to close a recording session.
+   *
+   *   stem ::
+   *     The function to set a simple stem.
+   *
+   *   stem3 ::
+   *     The function to set counter-controlled stems.
+   *
+   *   reset ::
+   *     The function to reset stem hints.
+   *
+   *   apply ::
+   *     The function to apply the hints to the corresponding glyph outline.
+   *
+   */
+  typedef struct  T1_Hints_FuncsRec_
+  {
+    T1_Hints               hints;
+    T1_Hints_OpenFunc      open;
+    T1_Hints_CloseFunc     close;
+    T1_Hints_SetStemFunc   stem;
+    T1_Hints_SetStem3Func  stem3;
+    T1_Hints_ResetFunc     reset;
+    T1_Hints_ApplyFunc     apply;
+
+  } T1_Hints_FuncsRec;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****                  PUBLIC TYPE 2 HINTS RECORDER                 *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************
+   *
+   * @type:
+   *   T2_Hints
+   *
+   * @description:
+   *   This is a handle to an opaque structure used to record glyph hints
+   *   from a Type 2 character glyph character string.
+   *
+   *   The methods used to operate on this object are defined by the
+   *   @T2_Hints_FuncsRec structure.  Recording glyph hints is normally
+   *   achieved through the following scheme:
+   *
+   *   - Open a new hint recording session by calling the `open' method.
+   *     This rewinds the recorder and prepare it for new input.
+   *
+   *   - For each hint found in the glyph charstring, call the corresponding
+   *     method (`stems', `hintmask', `counters').  Note that these
+   *     functions do not return an error code.
+   *
+   *   - Close the recording session by calling the `close' method.  It
+   *     returns an error code if the hints were invalid or something
+   *     strange happened (e.g., memory shortage).
+   *
+   *   The hints accumulated in the object can later be used by the
+   *   Postscript hinter.
+   *
+   */
+  typedef struct T2_HintsRec_*  T2_Hints;
+
+
+  /*************************************************************************
+   *
+   * @type:
+   *   T2_Hints_Funcs
+   *
+   * @description:
+   *   A pointer to the @T2_Hints_FuncsRec structure that defines the API of
+   *   a given @T2_Hints object.
+   *
+   */
+  typedef const struct T2_Hints_FuncsRec_*  T2_Hints_Funcs;
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T2_Hints_OpenFunc
+   *
+   * @description:
+   *   A method of the @T2_Hints class used to prepare it for a new Type 2
+   *   hints recording session.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 2 hints recorder.
+   *
+   * @note:
+   *   You should always call the @T2_Hints_CloseFunc method in order to
+   *   close an opened recording session.
+   *
+   */
+  typedef void
+  (*T2_Hints_OpenFunc)( T2_Hints  hints );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T2_Hints_StemsFunc
+   *
+   * @description:
+   *   A method of the @T2_Hints class used to set the table of stems in
+   *   either the vertical or horizontal dimension.  Equivalent to the
+   *   `hstem', `vstem', `hstemhm', and `vstemhm' Type 2 operators.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 2 hints recorder.
+   *
+   *   dimension ::
+   *     0 for horizontal stems (hstem), 1 for vertical ones (vstem).
+   *
+   *   count ::
+   *     The number of stems.
+   *
+   *   coords ::
+   *     An array of `count' (position,length) pairs in 16.16 format.
+   *
+   * @note:
+   *   Use vertical coordinates (y) for horizontal stems (dim=0).  Use
+   *   horizontal coordinates (x) for vertical stems (dim=1).
+   *
+   *   There are `2*count' elements in the `coords' array.  Each even
+   *   element is an absolute position in font units, each odd element is a
+   *   length in font units.
+   *
+   *   A length can be negative, in which case it must be either -20 or
+   *   -21.  It is interpreted as a `ghost' stem, according to the Type 1
+   *   specification.
+   *
+   */
+  typedef void
+  (*T2_Hints_StemsFunc)( T2_Hints   hints,
+                         FT_UInt    dimension,
+                         FT_UInt    count,
+                         FT_Fixed*  coordinates );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T2_Hints_MaskFunc
+   *
+   * @description:
+   *   A method of the @T2_Hints class used to set a given hintmask (this
+   *   corresponds to the `hintmask' Type 2 operator).
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 2 hints recorder.
+   *
+   *   end_point ::
+   *     The glyph index of the last point to which the previously defined
+   *     or activated hints apply.
+   *
+   *   bit_count ::
+   *     The number of bits in the hint mask.
+   *
+   *   bytes ::
+   *     An array of bytes modelling the hint mask.
+   *
+   * @note:
+   *   If the hintmask starts the charstring (before any glyph point
+   *   definition), the value of `end_point' should be 0.
+   *
+   *   `bit_count' is the number of meaningful bits in the `bytes' array; it
+   *   must be equal to the total number of hints defined so far (i.e.,
+   *   horizontal+verticals).
+   *
+   *   The `bytes' array can come directly from the Type 2 charstring and
+   *   respects the same format.
+   *
+   */
+  typedef void
+  (*T2_Hints_MaskFunc)( T2_Hints        hints,
+                        FT_UInt         end_point,
+                        FT_UInt         bit_count,
+                        const FT_Byte*  bytes );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T2_Hints_CounterFunc
+   *
+   * @description:
+   *   A method of the @T2_Hints class used to set a given counter mask
+   *   (this corresponds to the `hintmask' Type 2 operator).
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 2 hints recorder.
+   *
+   *   end_point ::
+   *     A glyph index of the last point to which the previously defined or
+   *     active hints apply.
+   *
+   *   bit_count ::
+   *     The number of bits in the hint mask.
+   *
+   *   bytes ::
+   *     An array of bytes modelling the hint mask.
+   *
+   * @note:
+   *   If the hintmask starts the charstring (before any glyph point
+   *   definition), the value of `end_point' should be 0.
+   *
+   *   `bit_count' is the number of meaningful bits in the `bytes' array; it
+   *   must be equal to the total number of hints defined so far (i.e.,
+   *   horizontal+verticals).
+   *
+   *    The `bytes' array can come directly from the Type 2 charstring and
+   *    respects the same format.
+   *
+   */
+  typedef void
+  (*T2_Hints_CounterFunc)( T2_Hints        hints,
+                           FT_UInt         bit_count,
+                           const FT_Byte*  bytes );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T2_Hints_CloseFunc
+   *
+   * @description:
+   *   A method of the @T2_Hints class used to close a hint recording
+   *   session.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 2 hints recorder.
+   *
+   *   end_point ::
+   *     The index of the last point in the input glyph.
+   *
+   * @return:
+   *   FreeType error code.  0 means success.
+   *
+   * @note:
+   *   The error code is set to indicate that an error occurred during the
+   *   recording session.
+   *
+   */
+  typedef FT_Error
+  (*T2_Hints_CloseFunc)( T2_Hints  hints,
+                         FT_UInt   end_point );
+
+
+  /*************************************************************************
+   *
+   * @functype:
+   *   T2_Hints_ApplyFunc
+   *
+   * @description:
+   *   A method of the @T2_Hints class used to apply hints to the
+   *   corresponding glyph outline.  Must be called after the `close'
+   *   method.
+   *
+   * @input:
+   *   hints ::
+   *     A handle to the Type 2 hints recorder.
+   *
+   *   outline ::
+   *     A pointer to the target outline descriptor.
+   *
+   *   globals ::
+   *     The hinter globals for this font.
+   *
+   *   hint_mode ::
+   *     Hinting information.
+   *
+   * @return:
+   *   FreeType error code.  0 means success.
+   *
+   * @note:
+   *   On input, all points within the outline are in font coordinates. On
+   *   output, they are in 1/64th of pixels.
+   *
+   *   The scaling transformation is taken from the `globals' object which
+   *   must correspond to the same font than the glyph.
+   *
+   */
+  typedef FT_Error
+  (*T2_Hints_ApplyFunc)( T2_Hints        hints,
+                         FT_Outline*     outline,
+                         PSH_Globals     globals,
+                         FT_Render_Mode  hint_mode );
+
+
+  /*************************************************************************
+   *
+   * @struct:
+   *   T2_Hints_FuncsRec
+   *
+   * @description:
+   *   The structure used to provide the API to @T2_Hints objects.
+   *
+   * @fields:
+   *   hints ::
+   *     A handle to the T2 hints recorder object.
+   *
+   *   open ::
+   *     The function to open a recording session.
+   *
+   *   close ::
+   *     The function to close a recording session.
+   *
+   *   stems ::
+   *     The function to set the dimension's stems table.
+   *
+   *   hintmask ::
+   *     The function to set hint masks.
+   *
+   *   counter ::
+   *     The function to set counter masks.
+   *
+   *   apply ::
+   *     The function to apply the hints on the corresponding glyph outline.
+   *
+   */
+  typedef struct  T2_Hints_FuncsRec_
+  {
+    T2_Hints              hints;
+    T2_Hints_OpenFunc     open;
+    T2_Hints_CloseFunc    close;
+    T2_Hints_StemsFunc    stems;
+    T2_Hints_MaskFunc     hintmask;
+    T2_Hints_CounterFunc  counter;
+    T2_Hints_ApplyFunc    apply;
+
+  } T2_Hints_FuncsRec;
+
+
+  /* */
+
+
+  typedef struct  PSHinter_Interface_
+  {
+    PSH_Globals_Funcs  (*get_globals_funcs)( FT_Module  module );
+    T1_Hints_Funcs     (*get_t1_funcs)     ( FT_Module  module );
+    T2_Hints_Funcs     (*get_t2_funcs)     ( FT_Module  module );
+
+  } PSHinter_Interface;
+
+  typedef PSHinter_Interface*  PSHinter_Service;
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_PSHINTER_INTERFACE(        \
+          class_,                            \
+          get_globals_funcs_,                \
+          get_t1_funcs_,                     \
+          get_t2_funcs_ )                    \
+  static const PSHinter_Interface  class_ =  \
+  {                                          \
+    get_globals_funcs_,                      \
+    get_t1_funcs_,                           \
+    get_t2_funcs_                            \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_PSHINTER_INTERFACE(                      \
+          class_,                                          \
+          get_globals_funcs_,                              \
+          get_t1_funcs_,                                   \
+          get_t2_funcs_ )                                  \
+  void                                                     \
+  FT_Init_Class_ ## class_( FT_Library           library,  \
+                            PSHinter_Interface*  clazz )   \
+  {                                                        \
+    FT_UNUSED( library );                                  \
+                                                           \
+    clazz->get_globals_funcs = get_globals_funcs_;         \
+    clazz->get_t1_funcs      = get_t1_funcs_;              \
+    clazz->get_t2_funcs      = get_t2_funcs_;              \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+FT_END_HEADER
+
+#endif /* __PSHINTS_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svbdf.h b/include/freetype/internal/services/svbdf.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svbdf.h
@@ -0,0 +1,82 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svbdf.h                                                                */
+/*                                                                         */
+/*    The FreeType BDF services (specification).                           */
+/*                                                                         */
+/*  Copyright 2003, 2009, 2012 by                                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVBDF_H__
+#define __SVBDF_H__
+
+#include FT_BDF_H
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_BDF  "bdf"
+
+  typedef FT_Error
+  (*FT_BDF_GetCharsetIdFunc)( FT_Face       face,
+                              const char*  *acharset_encoding,
+                              const char*  *acharset_registry );
+
+  typedef FT_Error
+  (*FT_BDF_GetPropertyFunc)( FT_Face           face,
+                             const char*       prop_name,
+                             BDF_PropertyRec  *aproperty );
+
+
+  FT_DEFINE_SERVICE( BDF )
+  {
+    FT_BDF_GetCharsetIdFunc  get_charset_id;
+    FT_BDF_GetPropertyFunc   get_property;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_BDFRec( class_,                                \
+                                  get_charset_id_,                       \
+                                  get_property_ )                        \
+  static const FT_Service_BDFRec  class_ =                               \
+  {                                                                      \
+    get_charset_id_, get_property_                                       \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_BDFRec( class_,                                \
+                                  get_charset_id_,                       \
+                                  get_property_ )                        \
+  void                                                                   \
+  FT_Init_Class_ ## class_( FT_Service_BDFRec*  clazz )                  \
+  {                                                                      \
+    clazz->get_charset_id = get_charset_id_;                             \
+    clazz->get_property   = get_property_;                               \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVBDF_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svcid.h b/include/freetype/internal/services/svcid.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svcid.h
@@ -0,0 +1,89 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svcid.h                                                                */
+/*                                                                         */
+/*    The FreeType CID font services (specification).                      */
+/*                                                                         */
+/*  Copyright 2007, 2009, 2012 by Derek Clegg, Michael Toftdal.            */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVCID_H__
+#define __SVCID_H__
+
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_CID  "CID"
+
+  typedef FT_Error
+  (*FT_CID_GetRegistryOrderingSupplementFunc)( FT_Face       face,
+                                               const char*  *registry,
+                                               const char*  *ordering,
+                                               FT_Int       *supplement );
+  typedef FT_Error
+  (*FT_CID_GetIsInternallyCIDKeyedFunc)( FT_Face   face,
+                                         FT_Bool  *is_cid );
+  typedef FT_Error
+  (*FT_CID_GetCIDFromGlyphIndexFunc)( FT_Face   face,
+                                      FT_UInt   glyph_index,
+                                      FT_UInt  *cid );
+
+  FT_DEFINE_SERVICE( CID )
+  {
+    FT_CID_GetRegistryOrderingSupplementFunc  get_ros;
+    FT_CID_GetIsInternallyCIDKeyedFunc        get_is_cid;
+    FT_CID_GetCIDFromGlyphIndexFunc           get_cid_from_glyph_index;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_CIDREC( class_,                                   \
+                                  get_ros_,                                 \
+                                  get_is_cid_,                              \
+                                  get_cid_from_glyph_index_ )               \
+  static const FT_Service_CIDRec class_ =                                   \
+  {                                                                         \
+    get_ros_, get_is_cid_, get_cid_from_glyph_index_                        \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_CIDREC( class_,                                   \
+                                  get_ros_,                                 \
+                                  get_is_cid_,                              \
+                                  get_cid_from_glyph_index_ )               \
+  void                                                                      \
+  FT_Init_Class_ ## class_( FT_Library          library,                    \
+                            FT_Service_CIDRec*  clazz )                     \
+  {                                                                         \
+    FT_UNUSED( library );                                                   \
+                                                                            \
+    clazz->get_ros                  = get_ros_;                             \
+    clazz->get_is_cid               = get_is_cid_;                          \
+    clazz->get_cid_from_glyph_index = get_cid_from_glyph_index_;            \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVCID_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svgldict.h b/include/freetype/internal/services/svgldict.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svgldict.h
@@ -0,0 +1,88 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svgldict.h                                                             */
+/*                                                                         */
+/*    The FreeType glyph dictionary services (specification).              */
+/*                                                                         */
+/*  Copyright 2003, 2009, 2012 by                                          */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVGLDICT_H__
+#define __SVGLDICT_H__
+
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*
+   *  A service used to retrieve glyph names, as well as to find the
+   *  index of a given glyph name in a font.
+   *
+   */
+
+#define FT_SERVICE_ID_GLYPH_DICT  "glyph-dict"
+
+
+  typedef FT_Error
+  (*FT_GlyphDict_GetNameFunc)( FT_Face     face,
+                               FT_UInt     glyph_index,
+                               FT_Pointer  buffer,
+                               FT_UInt     buffer_max );
+
+  typedef FT_UInt
+  (*FT_GlyphDict_NameIndexFunc)( FT_Face     face,
+                                 FT_String*  glyph_name );
+
+
+  FT_DEFINE_SERVICE( GlyphDict )
+  {
+    FT_GlyphDict_GetNameFunc    get_name;
+    FT_GlyphDict_NameIndexFunc  name_index;  /* optional */
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_GLYPHDICTREC( class_,                        \
+                                        get_name_,                     \
+                                        name_index_)                   \
+  static const FT_Service_GlyphDictRec  class_ =                       \
+  {                                                                    \
+    get_name_, name_index_                                             \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_GLYPHDICTREC( class_,                        \
+                                        get_name_,                     \
+                                        name_index_)                   \
+  void                                                                 \
+  FT_Init_Class_ ## class_( FT_Library                library,         \
+                            FT_Service_GlyphDictRec*  clazz )          \
+  {                                                                    \
+    FT_UNUSED( library );                                              \
+                                                                       \
+    clazz->get_name   = get_name_;                                     \
+    clazz->name_index = name_index_;                                   \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVGLDICT_H__ */
diff --git a/include/freetype/internal/services/svgxval.h b/include/freetype/internal/services/svgxval.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svgxval.h
@@ -0,0 +1,72 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svgxval.h                                                              */
+/*                                                                         */
+/*    FreeType API for validating TrueTypeGX/AAT tables (specification).   */
+/*                                                                         */
+/*  Copyright 2004, 2005 by                                                */
+/*  Masatake YAMATO, Red Hat K.K.,                                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+/***************************************************************************/
+/*                                                                         */
+/* gxvalid is derived from both gxlayout module and otvalid module.        */
+/* Development of gxlayout is supported by the Information-technology      */
+/* Promotion Agency(IPA), Japan.                                           */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVGXVAL_H__
+#define __SVGXVAL_H__
+
+#include FT_GX_VALIDATE_H
+#include FT_INTERNAL_VALIDATE_H
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_GX_VALIDATE           "truetypegx-validate"
+#define FT_SERVICE_ID_CLASSICKERN_VALIDATE  "classickern-validate"
+
+  typedef FT_Error
+  (*gxv_validate_func)( FT_Face   face,
+                        FT_UInt   gx_flags,
+                        FT_Bytes  tables[FT_VALIDATE_GX_LENGTH],
+                        FT_UInt   table_length );
+
+
+  typedef FT_Error
+  (*ckern_validate_func)( FT_Face   face,
+                          FT_UInt   ckern_flags,
+                          FT_Bytes  *ckern_table );
+
+
+  FT_DEFINE_SERVICE( GXvalidate )
+  {
+    gxv_validate_func  validate;
+  };
+
+  FT_DEFINE_SERVICE( CKERNvalidate )
+  {
+    ckern_validate_func  validate;
+  };
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVGXVAL_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svkern.h b/include/freetype/internal/services/svkern.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svkern.h
@@ -0,0 +1,51 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svkern.h                                                               */
+/*                                                                         */
+/*    The FreeType Kerning service (specification).                        */
+/*                                                                         */
+/*  Copyright 2006 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVKERN_H__
+#define __SVKERN_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_TRUETYPE_TABLES_H
+
+
+FT_BEGIN_HEADER
+
+#define FT_SERVICE_ID_KERNING  "kerning"
+
+
+  typedef FT_Error
+  (*FT_Kerning_TrackGetFunc)( FT_Face    face,
+                              FT_Fixed   point_size,
+                              FT_Int     degree,
+                              FT_Fixed*  akerning );
+
+  FT_DEFINE_SERVICE( Kerning )
+  {
+    FT_Kerning_TrackGetFunc  get_track;
+  };
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVKERN_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svmm.h b/include/freetype/internal/services/svmm.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svmm.h
@@ -0,0 +1,113 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svmm.h                                                                 */
+/*                                                                         */
+/*    The FreeType Multiple Masters and GX var services (specification).   */
+/*                                                                         */
+/*  Copyright 2003, 2004, 2009, 2012 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVMM_H__
+#define __SVMM_H__
+
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*
+   *  A service used to manage multiple-masters data in a given face.
+   *
+   *  See the related APIs in `ftmm.h' (FT_MULTIPLE_MASTERS_H).
+   *
+   */
+
+#define FT_SERVICE_ID_MULTI_MASTERS  "multi-masters"
+
+
+  typedef FT_Error
+  (*FT_Get_MM_Func)( FT_Face           face,
+                     FT_Multi_Master*  master );
+
+  typedef FT_Error
+  (*FT_Get_MM_Var_Func)( FT_Face      face,
+                         FT_MM_Var*  *master );
+
+  typedef FT_Error
+  (*FT_Set_MM_Design_Func)( FT_Face   face,
+                            FT_UInt   num_coords,
+                            FT_Long*  coords );
+
+  typedef FT_Error
+  (*FT_Set_Var_Design_Func)( FT_Face    face,
+                             FT_UInt    num_coords,
+                             FT_Fixed*  coords );
+
+  typedef FT_Error
+  (*FT_Set_MM_Blend_Func)( FT_Face   face,
+                           FT_UInt   num_coords,
+                           FT_Long*  coords );
+
+
+  FT_DEFINE_SERVICE( MultiMasters )
+  {
+    FT_Get_MM_Func          get_mm;
+    FT_Set_MM_Design_Func   set_mm_design;
+    FT_Set_MM_Blend_Func    set_mm_blend;
+    FT_Get_MM_Var_Func      get_mm_var;
+    FT_Set_Var_Design_Func  set_var_design;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_MULTIMASTERSREC( class_,                          \
+                                           get_mm_,                         \
+                                           set_mm_design_,                  \
+                                           set_mm_blend_,                   \
+                                           get_mm_var_,                     \
+                                           set_var_design_ )                \
+  static const FT_Service_MultiMastersRec  class_ =                         \
+  {                                                                         \
+    get_mm_, set_mm_design_, set_mm_blend_, get_mm_var_, set_var_design_    \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_MULTIMASTERSREC( class_,                          \
+                                           get_mm_,                         \
+                                           set_mm_design_,                  \
+                                           set_mm_blend_,                   \
+                                           get_mm_var_,                     \
+                                           set_var_design_ )                \
+  void                                                                      \
+  FT_Init_Class_ ## class_( FT_Service_MultiMastersRec*  clazz )            \
+  {                                                                         \
+    clazz->get_mm         = get_mm_;                                        \
+    clazz->set_mm_design  = set_mm_design_;                                 \
+    clazz->set_mm_blend   = set_mm_blend_;                                  \
+    clazz->get_mm_var     = get_mm_var_;                                    \
+    clazz->set_var_design = set_var_design_;                                \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __SVMM_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svotval.h b/include/freetype/internal/services/svotval.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svotval.h
@@ -0,0 +1,55 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svotval.h                                                              */
+/*                                                                         */
+/*    The FreeType OpenType validation service (specification).            */
+/*                                                                         */
+/*  Copyright 2004, 2006 by                                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVOTVAL_H__
+#define __SVOTVAL_H__
+
+#include FT_OPENTYPE_VALIDATE_H
+#include FT_INTERNAL_VALIDATE_H
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_OPENTYPE_VALIDATE  "opentype-validate"
+
+
+  typedef FT_Error
+  (*otv_validate_func)( FT_Face volatile  face,
+                        FT_UInt           ot_flags,
+                        FT_Bytes         *base,
+                        FT_Bytes         *gdef,
+                        FT_Bytes         *gpos,
+                        FT_Bytes         *gsub,
+                        FT_Bytes         *jstf );
+
+
+  FT_DEFINE_SERVICE( OTvalidate )
+  {
+    otv_validate_func  validate;
+  };
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVOTVAL_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svpfr.h b/include/freetype/internal/services/svpfr.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svpfr.h
@@ -0,0 +1,66 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svpfr.h                                                                */
+/*                                                                         */
+/*    Internal PFR service functions (specification).                      */
+/*                                                                         */
+/*  Copyright 2003, 2006 by                                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVPFR_H__
+#define __SVPFR_H__
+
+#include FT_PFR_H
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_PFR_METRICS  "pfr-metrics"
+
+
+  typedef FT_Error
+  (*FT_PFR_GetMetricsFunc)( FT_Face    face,
+                            FT_UInt   *aoutline,
+                            FT_UInt   *ametrics,
+                            FT_Fixed  *ax_scale,
+                            FT_Fixed  *ay_scale );
+
+  typedef FT_Error
+  (*FT_PFR_GetKerningFunc)( FT_Face     face,
+                            FT_UInt     left,
+                            FT_UInt     right,
+                            FT_Vector  *avector );
+
+  typedef FT_Error
+  (*FT_PFR_GetAdvanceFunc)( FT_Face   face,
+                            FT_UInt   gindex,
+                            FT_Pos   *aadvance );
+
+
+  FT_DEFINE_SERVICE( PfrMetrics )
+  {
+    FT_PFR_GetMetricsFunc  get_metrics;
+    FT_PFR_GetKerningFunc  get_kerning;
+    FT_PFR_GetAdvanceFunc  get_advance;
+
+  };
+
+ /* */
+
+FT_END_HEADER
+
+#endif /* __SVPFR_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svpostnm.h b/include/freetype/internal/services/svpostnm.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svpostnm.h
@@ -0,0 +1,81 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svpostnm.h                                                             */
+/*                                                                         */
+/*    The FreeType PostScript name services (specification).               */
+/*                                                                         */
+/*  Copyright 2003, 2007, 2009, 2012 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVPOSTNM_H__
+#define __SVPOSTNM_H__
+
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+  /*
+   *  A trivial service used to retrieve the PostScript name of a given
+   *  font when available.  The `get_name' field should never be NULL.
+   *
+   *  The corresponding function can return NULL to indicate that the
+   *  PostScript name is not available.
+   *
+   *  The name is owned by the face and will be destroyed with it.
+   */
+
+#define FT_SERVICE_ID_POSTSCRIPT_FONT_NAME  "postscript-font-name"
+
+
+  typedef const char*
+  (*FT_PsName_GetFunc)( FT_Face  face );
+
+
+  FT_DEFINE_SERVICE( PsFontName )
+  {
+    FT_PsName_GetFunc  get_ps_font_name;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_PSFONTNAMEREC( class_, get_ps_font_name_ ) \
+  static const FT_Service_PsFontNameRec  class_ =                    \
+  {                                                                  \
+    get_ps_font_name_                                                \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_PSFONTNAMEREC( class_, get_ps_font_name_ ) \
+  void                                                               \
+  FT_Init_Class_ ## class_( FT_Library                 library,      \
+                            FT_Service_PsFontNameRec*  clazz )       \
+  {                                                                  \
+    FT_UNUSED( library );                                            \
+                                                                     \
+    clazz->get_ps_font_name = get_ps_font_name_;                     \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVPOSTNM_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svprop.h b/include/freetype/internal/services/svprop.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svprop.h
@@ -0,0 +1,81 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svprop.h                                                               */
+/*                                                                         */
+/*    The FreeType property service (specification).                       */
+/*                                                                         */
+/*  Copyright 2012 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVPROP_H__
+#define __SVPROP_H__
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_PROPERTIES  "properties"
+
+
+  typedef FT_Error
+  (*FT_Properties_SetFunc)( FT_Module    module,
+                            const char*  property_name,
+                            const void*  value );
+
+  typedef FT_Error
+  (*FT_Properties_GetFunc)( FT_Module    module,
+                            const char*  property_name,
+                            void*        value );
+
+
+  FT_DEFINE_SERVICE( Properties )
+  {
+    FT_Properties_SetFunc  set_property;
+    FT_Properties_GetFunc  get_property;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_PROPERTIESREC( class_,          \
+                                         set_property_,   \
+                                         get_property_ )  \
+  static const FT_Service_PropertiesRec  class_ =         \
+  {                                                       \
+    set_property_,                                        \
+    get_property_                                         \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_PROPERTIESREC( class_,                \
+                                         set_property_,         \
+                                         get_property_ )        \
+  void                                                          \
+  FT_Init_Class_ ## class_( FT_Service_PropertiesRec*  clazz )  \
+  {                                                             \
+    clazz->set_property = set_property_;                        \
+    clazz->get_property = get_property_;                        \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVPROP_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svpscmap.h b/include/freetype/internal/services/svpscmap.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svpscmap.h
@@ -0,0 +1,177 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svpscmap.h                                                             */
+/*                                                                         */
+/*    The FreeType PostScript charmap service (specification).             */
+/*                                                                         */
+/*  Copyright 2003, 2006, 2009, 2012 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVPSCMAP_H__
+#define __SVPSCMAP_H__
+
+#include FT_INTERNAL_OBJECTS_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_POSTSCRIPT_CMAPS  "postscript-cmaps"
+
+
+  /*
+   *  Adobe glyph name to unicode value.
+   */
+  typedef FT_UInt32
+  (*PS_Unicode_ValueFunc)( const char*  glyph_name );
+
+  /*
+   *  Macintosh name id to glyph name.  NULL if invalid index.
+   */
+  typedef const char*
+  (*PS_Macintosh_NameFunc)( FT_UInt  name_index );
+
+  /*
+   *  Adobe standard string ID to glyph name.  NULL if invalid index.
+   */
+  typedef const char*
+  (*PS_Adobe_Std_StringsFunc)( FT_UInt  string_index );
+
+
+  /*
+   *  Simple unicode -> glyph index charmap built from font glyph names
+   *  table.
+   */
+  typedef struct  PS_UniMap_
+  {
+    FT_UInt32  unicode;      /* bit 31 set: is glyph variant */
+    FT_UInt    glyph_index;
+
+  } PS_UniMap;
+
+
+  typedef struct PS_UnicodesRec_*  PS_Unicodes;
+
+  typedef struct  PS_UnicodesRec_
+  {
+    FT_CMapRec  cmap;
+    FT_UInt     num_maps;
+    PS_UniMap*  maps;
+
+  } PS_UnicodesRec;
+
+
+  /*
+   *  A function which returns a glyph name for a given index.  Returns
+   *  NULL if invalid index.
+   */
+  typedef const char*
+  (*PS_GetGlyphNameFunc)( FT_Pointer  data,
+                          FT_UInt     string_index );
+
+  /*
+   *  A function used to release the glyph name returned by
+   *  PS_GetGlyphNameFunc, when needed
+   */
+  typedef void
+  (*PS_FreeGlyphNameFunc)( FT_Pointer  data,
+                           const char*  name );
+
+  typedef FT_Error
+  (*PS_Unicodes_InitFunc)( FT_Memory             memory,
+                           PS_Unicodes           unicodes,
+                           FT_UInt               num_glyphs,
+                           PS_GetGlyphNameFunc   get_glyph_name,
+                           PS_FreeGlyphNameFunc  free_glyph_name,
+                           FT_Pointer            glyph_data );
+
+  typedef FT_UInt
+  (*PS_Unicodes_CharIndexFunc)( PS_Unicodes  unicodes,
+                                FT_UInt32    unicode );
+
+  typedef FT_UInt32
+  (*PS_Unicodes_CharNextFunc)( PS_Unicodes  unicodes,
+                               FT_UInt32   *unicode );
+
+
+  FT_DEFINE_SERVICE( PsCMaps )
+  {
+    PS_Unicode_ValueFunc       unicode_value;
+
+    PS_Unicodes_InitFunc       unicodes_init;
+    PS_Unicodes_CharIndexFunc  unicodes_char_index;
+    PS_Unicodes_CharNextFunc   unicodes_char_next;
+
+    PS_Macintosh_NameFunc      macintosh_name;
+    PS_Adobe_Std_StringsFunc   adobe_std_strings;
+    const unsigned short*      adobe_std_encoding;
+    const unsigned short*      adobe_expert_encoding;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_PSCMAPSREC( class_,                               \
+                                      unicode_value_,                       \
+                                      unicodes_init_,                       \
+                                      unicodes_char_index_,                 \
+                                      unicodes_char_next_,                  \
+                                      macintosh_name_,                      \
+                                      adobe_std_strings_,                   \
+                                      adobe_std_encoding_,                  \
+                                      adobe_expert_encoding_ )              \
+  static const FT_Service_PsCMapsRec  class_ =                              \
+  {                                                                         \
+    unicode_value_, unicodes_init_,                                         \
+    unicodes_char_index_, unicodes_char_next_, macintosh_name_,             \
+    adobe_std_strings_, adobe_std_encoding_, adobe_expert_encoding_         \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_PSCMAPSREC( class_,                               \
+                                      unicode_value_,                       \
+                                      unicodes_init_,                       \
+                                      unicodes_char_index_,                 \
+                                      unicodes_char_next_,                  \
+                                      macintosh_name_,                      \
+                                      adobe_std_strings_,                   \
+                                      adobe_std_encoding_,                  \
+                                      adobe_expert_encoding_ )              \
+  void                                                                      \
+  FT_Init_Class_ ## class_( FT_Library              library,                \
+                            FT_Service_PsCMapsRec*  clazz )                 \
+  {                                                                         \
+    FT_UNUSED( library );                                                   \
+                                                                            \
+    clazz->unicode_value         = unicode_value_;                          \
+    clazz->unicodes_init         = unicodes_init_;                          \
+    clazz->unicodes_char_index   = unicodes_char_index_;                    \
+    clazz->unicodes_char_next    = unicodes_char_next_;                     \
+    clazz->macintosh_name        = macintosh_name_;                         \
+    clazz->adobe_std_strings     = adobe_std_strings_;                      \
+    clazz->adobe_std_encoding    = adobe_std_encoding_;                     \
+    clazz->adobe_expert_encoding = adobe_expert_encoding_;                  \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVPSCMAP_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svpsinfo.h b/include/freetype/internal/services/svpsinfo.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svpsinfo.h
@@ -0,0 +1,111 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svpsinfo.h                                                             */
+/*                                                                         */
+/*    The FreeType PostScript info service (specification).                */
+/*                                                                         */
+/*  Copyright 2003, 2004, 2009, 2011, 2012 by                              */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVPSINFO_H__
+#define __SVPSINFO_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_INTERNAL_TYPE1_TYPES_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_POSTSCRIPT_INFO  "postscript-info"
+
+
+  typedef FT_Error
+  (*PS_GetFontInfoFunc)( FT_Face          face,
+                         PS_FontInfoRec*  afont_info );
+
+  typedef FT_Error
+  (*PS_GetFontExtraFunc)( FT_Face           face,
+                          PS_FontExtraRec*  afont_extra );
+
+  typedef FT_Int
+  (*PS_HasGlyphNamesFunc)( FT_Face  face );
+
+  typedef FT_Error
+  (*PS_GetFontPrivateFunc)( FT_Face         face,
+                            PS_PrivateRec*  afont_private );
+
+  typedef FT_Long
+  (*PS_GetFontValueFunc)( FT_Face       face,
+                          PS_Dict_Keys  key,
+                          FT_UInt       idx,
+                          void         *value,
+                          FT_Long       value_len );
+
+
+  FT_DEFINE_SERVICE( PsInfo )
+  {
+    PS_GetFontInfoFunc     ps_get_font_info;
+    PS_GetFontExtraFunc    ps_get_font_extra;
+    PS_HasGlyphNamesFunc   ps_has_glyph_names;
+    PS_GetFontPrivateFunc  ps_get_font_private;
+    PS_GetFontValueFunc    ps_get_font_value;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_PSINFOREC( class_,                     \
+                                     get_font_info_,             \
+                                     ps_get_font_extra_,         \
+                                     has_glyph_names_,           \
+                                     get_font_private_,          \
+                                     get_font_value_ )           \
+  static const FT_Service_PsInfoRec  class_ =                    \
+  {                                                              \
+    get_font_info_, ps_get_font_extra_, has_glyph_names_,        \
+    get_font_private_, get_font_value_                           \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_PSINFOREC( class_,                     \
+                                     get_font_info_,             \
+                                     ps_get_font_extra_,         \
+                                     has_glyph_names_,           \
+                                     get_font_private_,          \
+                                     get_font_value_ )           \
+  void                                                           \
+  FT_Init_Class_ ## class_( FT_Library             library,      \
+                            FT_Service_PsInfoRec*  clazz )       \
+  {                                                              \
+    FT_UNUSED( library );                                        \
+                                                                 \
+    clazz->ps_get_font_info    = get_font_info_;                 \
+    clazz->ps_get_font_extra   = ps_get_font_extra_;             \
+    clazz->ps_has_glyph_names  = has_glyph_names_;               \
+    clazz->ps_get_font_private = get_font_private_;              \
+    clazz->ps_get_font_value   = get_font_value_;                \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVPSINFO_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svsfnt.h b/include/freetype/internal/services/svsfnt.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svsfnt.h
@@ -0,0 +1,103 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svsfnt.h                                                               */
+/*                                                                         */
+/*    The FreeType SFNT table loading service (specification).             */
+/*                                                                         */
+/*  Copyright 2003, 2004, 2009, 2012 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVSFNT_H__
+#define __SVSFNT_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_TRUETYPE_TABLES_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*
+   *  SFNT table loading service.
+   */
+
+#define FT_SERVICE_ID_SFNT_TABLE  "sfnt-table"
+
+
+  /*
+   * Used to implement FT_Load_Sfnt_Table().
+   */
+  typedef FT_Error
+  (*FT_SFNT_TableLoadFunc)( FT_Face    face,
+                            FT_ULong   tag,
+                            FT_Long    offset,
+                            FT_Byte*   buffer,
+                            FT_ULong*  length );
+
+  /*
+   * Used to implement FT_Get_Sfnt_Table().
+   */
+  typedef void*
+  (*FT_SFNT_TableGetFunc)( FT_Face      face,
+                           FT_Sfnt_Tag  tag );
+
+
+  /*
+   * Used to implement FT_Sfnt_Table_Info().
+   */
+  typedef FT_Error
+  (*FT_SFNT_TableInfoFunc)( FT_Face    face,
+                            FT_UInt    idx,
+                            FT_ULong  *tag,
+                            FT_ULong  *offset,
+                            FT_ULong  *length );
+
+
+  FT_DEFINE_SERVICE( SFNT_Table )
+  {
+    FT_SFNT_TableLoadFunc  load_table;
+    FT_SFNT_TableGetFunc   get_table;
+    FT_SFNT_TableInfoFunc  table_info;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_SFNT_TABLEREC( class_, load_, get_, info_ )  \
+  static const FT_Service_SFNT_TableRec  class_ =                      \
+  {                                                                    \
+    load_, get_, info_                                                 \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_SFNT_TABLEREC( class_, load_, get_, info_ ) \
+  void                                                                \
+  FT_Init_Class_ ## class_( FT_Service_SFNT_TableRec*  clazz )        \
+  {                                                                   \
+    clazz->load_table = load_;                                        \
+    clazz->get_table  = get_;                                         \
+    clazz->table_info = info_;                                        \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVSFNT_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svttcmap.h b/include/freetype/internal/services/svttcmap.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svttcmap.h
@@ -0,0 +1,107 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svttcmap.h                                                             */
+/*                                                                         */
+/*    The FreeType TrueType/sfnt cmap extra information service.           */
+/*                                                                         */
+/*  Copyright 2003 by                                                      */
+/*  Masatake YAMATO, Redhat K.K.                                           */
+/*                                                                         */
+/*  Copyright 2003, 2008, 2009, 2012 by                                    */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+/* Development of this service is support of
+   Information-technology Promotion Agency, Japan. */
+
+#ifndef __SVTTCMAP_H__
+#define __SVTTCMAP_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_TRUETYPE_TABLES_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_TT_CMAP  "tt-cmaps"
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_CMapInfo                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to store TrueType/sfnt specific cmap information  */
+  /*    which is not covered by the generic @FT_CharMap structure.  This   */
+  /*    structure can be accessed with the @FT_Get_TT_CMap_Info function.  */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    language ::                                                        */
+  /*      The language ID used in Mac fonts.  Definitions of values are in */
+  /*      freetype/ttnameid.h.                                             */
+  /*                                                                       */
+  /*    format ::                                                          */
+  /*      The cmap format.  OpenType 1.5 defines the formats 0 (byte       */
+  /*      encoding table), 2~(high-byte mapping through table), 4~(segment */
+  /*      mapping to delta values), 6~(trimmed table mapping), 8~(mixed    */
+  /*      16-bit and 32-bit coverage), 10~(trimmed array), 12~(segmented   */
+  /*      coverage), and 14 (Unicode Variation Sequences).                 */
+  /*                                                                       */
+  typedef struct  TT_CMapInfo_
+  {
+    FT_ULong  language;
+    FT_Long   format;
+
+  } TT_CMapInfo;
+
+
+  typedef FT_Error
+  (*TT_CMap_Info_GetFunc)( FT_CharMap    charmap,
+                           TT_CMapInfo  *cmap_info );
+
+
+  FT_DEFINE_SERVICE( TTCMaps )
+  {
+    TT_CMap_Info_GetFunc  get_cmap_info;
+  };
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_TTCMAPSREC( class_, get_cmap_info_ )  \
+  static const FT_Service_TTCMapsRec  class_ =                  \
+  {                                                             \
+    get_cmap_info_                                              \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_TTCMAPSREC( class_, get_cmap_info_ )  \
+  void                                                          \
+  FT_Init_Class_ ## class_( FT_Library              library,    \
+                            FT_Service_TTCMapsRec*  clazz )     \
+  {                                                             \
+    FT_UNUSED( library );                                       \
+                                                                \
+    clazz->get_cmap_info = get_cmap_info_;                      \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __SVTTCMAP_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svtteng.h b/include/freetype/internal/services/svtteng.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svtteng.h
@@ -0,0 +1,53 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svtteng.h                                                              */
+/*                                                                         */
+/*    The FreeType TrueType engine query service (specification).          */
+/*                                                                         */
+/*  Copyright 2006 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVTTENG_H__
+#define __SVTTENG_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_MODULE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*
+   *  SFNT table loading service.
+   */
+
+#define FT_SERVICE_ID_TRUETYPE_ENGINE  "truetype-engine"
+
+  /*
+   * Used to implement FT_Get_TrueType_Engine_Type
+   */
+
+  FT_DEFINE_SERVICE( TrueTypeEngine )
+  {
+    FT_TrueTypeEngineType  engine_type;
+  };
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVTTENG_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svttglyf.h b/include/freetype/internal/services/svttglyf.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svttglyf.h
@@ -0,0 +1,68 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svttglyf.h                                                             */
+/*                                                                         */
+/*    The FreeType TrueType glyph service.                                 */
+/*                                                                         */
+/*  Copyright 2007, 2009, 2012 by David Turner.                            */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+#ifndef __SVTTGLYF_H__
+#define __SVTTGLYF_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_TRUETYPE_TABLES_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_TT_GLYF  "tt-glyf"
+
+
+  typedef FT_ULong
+  (*TT_Glyf_GetLocationFunc)( FT_Face    face,
+                              FT_UInt    gindex,
+                              FT_ULong  *psize );
+
+  FT_DEFINE_SERVICE( TTGlyf )
+  {
+    TT_Glyf_GetLocationFunc  get_location;
+  };
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#define FT_DEFINE_SERVICE_TTGLYFREC( class_, get_location_ )  \
+  static const FT_Service_TTGlyfRec  class_ =                 \
+  {                                                           \
+    get_location_                                             \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#define FT_DEFINE_SERVICE_TTGLYFREC( class_, get_location_ )  \
+  void                                                        \
+  FT_Init_Class_ ## class_( FT_Service_TTGlyfRec*  clazz )    \
+  {                                                           \
+    clazz->get_location = get_location_;                      \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __SVTTGLYF_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svwinfnt.h b/include/freetype/internal/services/svwinfnt.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svwinfnt.h
@@ -0,0 +1,50 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svwinfnt.h                                                             */
+/*                                                                         */
+/*    The FreeType Windows FNT/FONT service (specification).               */
+/*                                                                         */
+/*  Copyright 2003 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVWINFNT_H__
+#define __SVWINFNT_H__
+
+#include FT_INTERNAL_SERVICE_H
+#include FT_WINFONTS_H
+
+
+FT_BEGIN_HEADER
+
+
+#define FT_SERVICE_ID_WINFNT  "winfonts"
+
+  typedef FT_Error
+  (*FT_WinFnt_GetHeaderFunc)( FT_Face               face,
+                              FT_WinFNT_HeaderRec  *aheader );
+
+
+  FT_DEFINE_SERVICE( WinFnt )
+  {
+    FT_WinFnt_GetHeaderFunc  get_header;
+  };
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVWINFNT_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/services/svxf86nm.h b/include/freetype/internal/services/svxf86nm.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/services/svxf86nm.h
@@ -0,0 +1,55 @@
+/***************************************************************************/
+/*                                                                         */
+/*  svxf86nm.h                                                             */
+/*                                                                         */
+/*    The FreeType XFree86 services (specification only).                  */
+/*                                                                         */
+/*  Copyright 2003 by                                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SVXF86NM_H__
+#define __SVXF86NM_H__
+
+#include FT_INTERNAL_SERVICE_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*
+   *  A trivial service used to return the name of a face's font driver,
+   *  according to the XFree86 nomenclature.  Note that the service data
+   *  is a simple constant string pointer.
+   */
+
+#define FT_SERVICE_ID_XF86_NAME  "xf86-driver-name"
+
+#define FT_XF86_FORMAT_TRUETYPE  "TrueType"
+#define FT_XF86_FORMAT_TYPE_1    "Type 1"
+#define FT_XF86_FORMAT_BDF       "BDF"
+#define FT_XF86_FORMAT_PCF       "PCF"
+#define FT_XF86_FORMAT_TYPE_42   "Type 42"
+#define FT_XF86_FORMAT_CID       "CID Type 1"
+#define FT_XF86_FORMAT_CFF       "CFF"
+#define FT_XF86_FORMAT_PFR       "PFR"
+#define FT_XF86_FORMAT_WINFNT    "Windows FNT"
+
+  /* */
+
+
+FT_END_HEADER
+
+
+#endif /* __SVXF86NM_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/sfnt.h b/include/freetype/internal/sfnt.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/sfnt.h
@@ -0,0 +1,974 @@
+/***************************************************************************/
+/*                                                                         */
+/*  sfnt.h                                                                 */
+/*                                                                         */
+/*    High-level `sfnt' driver interface (specification).                  */
+/*                                                                         */
+/*  Copyright 1996-2006, 2009, 2012 by                                     */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __SFNT_H__
+#define __SFNT_H__
+
+
+#include <ft2build.h>
+#include FT_INTERNAL_DRIVER_H
+#include FT_INTERNAL_TRUETYPE_TYPES_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Init_Face_Func                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    First part of the SFNT face object initialization.  This finds     */
+  /*    the face in a SFNT file or collection, and load its format tag in  */
+  /*    face->format_tag.                                                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    stream     :: The input stream.                                    */
+  /*                                                                       */
+  /*    face       :: A handle to the target face object.                  */
+  /*                                                                       */
+  /*    face_index :: The index of the TrueType font, if we are opening a  */
+  /*                  collection.                                          */
+  /*                                                                       */
+  /*    num_params :: The number of additional parameters.                 */
+  /*                                                                       */
+  /*    params     :: Optional additional parameters.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The stream cursor must be at the font file's origin.               */
+  /*                                                                       */
+  /*    This function recognizes fonts embedded in a `TrueType             */
+  /*    collection'.                                                       */
+  /*                                                                       */
+  /*    Once the format tag has been validated by the font driver, it      */
+  /*    should then call the TT_Load_Face_Func() callback to read the rest */
+  /*    of the SFNT tables in the object.                                  */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Init_Face_Func)( FT_Stream      stream,
+                        TT_Face        face,
+                        FT_Int         face_index,
+                        FT_Int         num_params,
+                        FT_Parameter*  params );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_Face_Func                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Second part of the SFNT face object initialization.  This loads    */
+  /*    the common SFNT tables (head, OS/2, maxp, metrics, etc.) in the    */
+  /*    face object.                                                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    stream     :: The input stream.                                    */
+  /*                                                                       */
+  /*    face       :: A handle to the target face object.                  */
+  /*                                                                       */
+  /*    face_index :: The index of the TrueType font, if we are opening a  */
+  /*                  collection.                                          */
+  /*                                                                       */
+  /*    num_params :: The number of additional parameters.                 */
+  /*                                                                       */
+  /*    params     :: Optional additional parameters.                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function must be called after TT_Init_Face_Func().            */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_Face_Func)( FT_Stream      stream,
+                        TT_Face        face,
+                        FT_Int         face_index,
+                        FT_Int         num_params,
+                        FT_Parameter*  params );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Done_Face_Func                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A callback used to delete the common SFNT data from a face.        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the target face object.                        */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function does NOT destroy the face object.                    */
+  /*                                                                       */
+  typedef void
+  (*TT_Done_Face_Func)( TT_Face  face );
+
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_SFNT_HeaderRec_Func                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Loads the header of a SFNT font file.  Supports collections.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face       :: A handle to the target face object.                  */
+  /*                                                                       */
+  /*    stream     :: The input stream.                                    */
+  /*                                                                       */
+  /*    face_index :: The index of the TrueType font, if we are opening a  */
+  /*                  collection.                                          */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    sfnt       :: The SFNT header.                                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The stream cursor must be at the font file's origin.               */
+  /*                                                                       */
+  /*    This function recognizes fonts embedded in a `TrueType             */
+  /*    collection'.                                                       */
+  /*                                                                       */
+  /*    This function checks that the header is valid by looking at the    */
+  /*    values of `search_range', `entry_selector', and `range_shift'.     */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_SFNT_HeaderRec_Func)( TT_Face      face,
+                                  FT_Stream    stream,
+                                  FT_Long      face_index,
+                                  SFNT_Header  sfnt );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_Directory_Func                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Loads the table directory into a face object.                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face   :: A handle to the target face object.                      */
+  /*                                                                       */
+  /*    stream :: The input stream.                                        */
+  /*                                                                       */
+  /*    sfnt   :: The SFNT header.                                         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The stream cursor must be on the first byte after the 4-byte font  */
+  /*    format tag.  This is the case just after a call to                 */
+  /*    TT_Load_Format_Tag().                                              */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_Directory_Func)( TT_Face      face,
+                             FT_Stream    stream,
+                             SFNT_Header  sfnt );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_Any_Func                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Load any font table into client memory.                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face   :: The face object to look for.                             */
+  /*                                                                       */
+  /*    tag    :: The tag of table to load.  Use the value 0 if you want   */
+  /*              to access the whole font file, else set this parameter   */
+  /*              to a valid TrueType table tag that you can forge with    */
+  /*              the MAKE_TT_TAG macro.                                   */
+  /*                                                                       */
+  /*    offset :: The starting offset in the table (or the file if         */
+  /*              tag == 0).                                               */
+  /*                                                                       */
+  /*    length :: The address of the decision variable:                    */
+  /*                                                                       */
+  /*                If length == NULL:                                     */
+  /*                  Loads the whole table.  Returns an error if          */
+  /*                  `offset' == 0!                                       */
+  /*                                                                       */
+  /*                If *length == 0:                                       */
+  /*                  Exits immediately; returning the length of the given */
+  /*                  table or of the font file, depending on the value of */
+  /*                  `tag'.                                               */
+  /*                                                                       */
+  /*                If *length != 0:                                       */
+  /*                  Loads the next `length' bytes of table or font,      */
+  /*                  starting at offset `offset' (in table or font too).  */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    buffer :: The address of target buffer.                            */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    TrueType error code.  0 means success.                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_Any_Func)( TT_Face    face,
+                       FT_ULong   tag,
+                       FT_Long    offset,
+                       FT_Byte   *buffer,
+                       FT_ULong*  length );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Find_SBit_Image_Func                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Check whether an embedded bitmap (an `sbit') exists for a given    */
+  /*    glyph, at a given strike.                                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face          :: The target face object.                           */
+  /*                                                                       */
+  /*    glyph_index   :: The glyph index.                                  */
+  /*                                                                       */
+  /*    strike_index  :: The current strike index.                         */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    arange        :: The SBit range containing the glyph index.        */
+  /*                                                                       */
+  /*    astrike       :: The SBit strike containing the glyph index.       */
+  /*                                                                       */
+  /*    aglyph_offset :: The offset of the glyph data in `EBDT' table.     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.  Returns                    */
+  /*    SFNT_Err_Invalid_Argument if no sbit exists for the requested      */
+  /*    glyph.                                                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Find_SBit_Image_Func)( TT_Face          face,
+                              FT_UInt          glyph_index,
+                              FT_ULong         strike_index,
+                              TT_SBit_Range   *arange,
+                              TT_SBit_Strike  *astrike,
+                              FT_ULong        *aglyph_offset );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_SBit_Metrics_Func                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Get the big metrics for a given embedded bitmap.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    stream      :: The input stream.                                   */
+  /*                                                                       */
+  /*    range       :: The SBit range containing the glyph.                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    big_metrics :: A big SBit metrics structure for the glyph.         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The stream cursor must be positioned at the glyph's offset within  */
+  /*    the `EBDT' table before the call.                                  */
+  /*                                                                       */
+  /*    If the image format uses variable metrics, the stream cursor is    */
+  /*    positioned just after the metrics header in the `EBDT' table on    */
+  /*    function exit.                                                     */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_SBit_Metrics_Func)( FT_Stream        stream,
+                                TT_SBit_Range    range,
+                                TT_SBit_Metrics  metrics );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_SBit_Image_Func                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Load a given glyph sbit image from the font resource.  This also   */
+  /*    returns its metrics.                                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face ::                                                            */
+  /*      The target face object.                                          */
+  /*                                                                       */
+  /*    strike_index ::                                                    */
+  /*      The strike index.                                                */
+  /*                                                                       */
+  /*    glyph_index ::                                                     */
+  /*      The current glyph index.                                         */
+  /*                                                                       */
+  /*    load_flags ::                                                      */
+  /*      The current load flags.                                          */
+  /*                                                                       */
+  /*    stream ::                                                          */
+  /*      The input stream.                                                */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    amap ::                                                            */
+  /*      The target pixmap.                                               */
+  /*                                                                       */
+  /*    ametrics ::                                                        */
+  /*      A big sbit metrics structure for the glyph image.                */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.  Returns an error if no     */
+  /*    glyph sbit exists for the index.                                   */
+  /*                                                                       */
+  /*  <Note>                                                               */
+  /*    The `map.buffer' field is always freed before the glyph is loaded. */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_SBit_Image_Func)( TT_Face              face,
+                              FT_ULong             strike_index,
+                              FT_UInt              glyph_index,
+                              FT_UInt              load_flags,
+                              FT_Stream            stream,
+                              FT_Bitmap           *amap,
+                              TT_SBit_MetricsRec  *ametrics );
+
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Set_SBit_Strike_OldFunc                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Select an sbit strike for a given size request.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face          :: The target face object.                           */
+  /*                                                                       */
+  /*    req           :: The size request.                                 */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    astrike_index :: The index of the sbit strike.                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.  Returns an error if no     */
+  /*    sbit strike exists for the selected ppem values.                   */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Set_SBit_Strike_OldFunc)( TT_Face    face,
+                                 FT_UInt    x_ppem,
+                                 FT_UInt    y_ppem,
+                                 FT_ULong*  astrike_index );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_CharMap_Load_Func                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Loads a given TrueType character map into memory.                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face   :: A handle to the parent face object.                      */
+  /*                                                                       */
+  /*    stream :: A handle to the current stream object.                   */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    cmap   :: A pointer to a cmap object.                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The function assumes that the stream is already in use (i.e.,      */
+  /*    opened).  In case of error, all partially allocated tables are     */
+  /*    released.                                                          */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_CharMap_Load_Func)( TT_Face    face,
+                           void*      cmap,
+                           FT_Stream  input );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_CharMap_Free_Func                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroys a character mapping table.                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the parent face object.                        */
+  /*                                                                       */
+  /*    cmap :: A handle to a cmap object.                                 */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_CharMap_Free_Func)( TT_Face       face,
+                           void*         cmap );
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Set_SBit_Strike_Func                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Select an sbit strike for a given size request.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face          :: The target face object.                           */
+  /*                                                                       */
+  /*    req           :: The size request.                                 */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    astrike_index :: The index of the sbit strike.                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.  Returns an error if no     */
+  /*    sbit strike exists for the selected ppem values.                   */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Set_SBit_Strike_Func)( TT_Face          face,
+                              FT_Size_Request  req,
+                              FT_ULong*        astrike_index );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_Strike_Metrics_Func                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Load the metrics of a given strike.                                */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face          :: The target face object.                           */
+  /*                                                                       */
+  /*    strike_index  :: The strike index.                                 */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    metrics       :: the metrics of the strike.                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.  Returns an error if no     */
+  /*    such sbit strike exists.                                           */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_Strike_Metrics_Func)( TT_Face           face,
+                                  FT_ULong          strike_index,
+                                  FT_Size_Metrics*  metrics );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Get_PS_Name_Func                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Get the PostScript glyph name of a glyph.                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    idx  :: The glyph index.                                           */
+  /*                                                                       */
+  /*    PSname :: The address of a string pointer.  Will be NULL in case   */
+  /*              of error, otherwise it is a pointer to the glyph name.   */
+  /*                                                                       */
+  /*              You must not modify the returned string!                 */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Get_PS_Name_Func)( TT_Face      face,
+                          FT_UInt      idx,
+                          FT_String**  PSname );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_Metrics_Func                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Load a metrics table, which is a table with a horizontal and a     */
+  /*    vertical version.                                                  */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face     :: A handle to the target face object.                    */
+  /*                                                                       */
+  /*    stream   :: The input stream.                                      */
+  /*                                                                       */
+  /*    vertical :: A boolean flag.  If set, load the vertical one.        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_Metrics_Func)( TT_Face    face,
+                           FT_Stream  stream,
+                           FT_Bool    vertical );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Get_Metrics_Func                                                */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Load the horizontal or vertical header in a face object.           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face     :: A handle to the target face object.                    */
+  /*                                                                       */
+  /*    stream   :: The input stream.                                      */
+  /*                                                                       */
+  /*    vertical :: A boolean flag.  If set, load vertical metrics.        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Get_Metrics_Func)( TT_Face     face,
+                          FT_Bool     vertical,
+                          FT_UInt     gindex,
+                          FT_Short*   abearing,
+                          FT_UShort*  aadvance );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Load_Table_Func                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Load a given TrueType table.                                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face   :: A handle to the target face object.                      */
+  /*                                                                       */
+  /*    stream :: The input stream.                                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The function uses `face->goto_table' to seek the stream to the     */
+  /*    start of the table, except while loading the font directory.       */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Load_Table_Func)( TT_Face    face,
+                         FT_Stream  stream );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Free_Table_Func                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Free a given TrueType table.                                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the target face object.                        */
+  /*                                                                       */
+  typedef void
+  (*TT_Free_Table_Func)( TT_Face  face );
+
+
+  /*
+   * @functype:
+   *    TT_Face_GetKerningFunc
+   *
+   * @description:
+   *    Return the horizontal kerning value between two glyphs.
+   *
+   * @input:
+   *    face        :: A handle to the source face object.
+   *    left_glyph  :: The left glyph index.
+   *    right_glyph :: The right glyph index.
+   *
+   * @return:
+   *    The kerning value in font units.
+   */
+  typedef FT_Int
+  (*TT_Face_GetKerningFunc)( TT_Face  face,
+                             FT_UInt  left_glyph,
+                             FT_UInt  right_glyph );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    SFNT_Interface                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure holds pointers to the functions used to load and    */
+  /*    free the basic tables that are required in a `sfnt' font file.     */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    Check the various xxx_Func() descriptions for details.             */
+  /*                                                                       */
+  typedef struct  SFNT_Interface_
+  {
+    TT_Loader_GotoTableFunc      goto_table;
+
+    TT_Init_Face_Func            init_face;
+    TT_Load_Face_Func            load_face;
+    TT_Done_Face_Func            done_face;
+    FT_Module_Requester          get_interface;
+
+    TT_Load_Any_Func             load_any;
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    TT_Load_SFNT_HeaderRec_Func  load_sfnt_header;
+    TT_Load_Directory_Func       load_directory;
+#endif
+
+    /* these functions are called by `load_face' but they can also  */
+    /* be called from external modules, if there is a need to do so */
+    TT_Load_Table_Func           load_head;
+    TT_Load_Metrics_Func         load_hhea;
+    TT_Load_Table_Func           load_cmap;
+    TT_Load_Table_Func           load_maxp;
+    TT_Load_Table_Func           load_os2;
+    TT_Load_Table_Func           load_post;
+
+    TT_Load_Table_Func           load_name;
+    TT_Free_Table_Func           free_name;
+
+    /* optional tables */
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    TT_Load_Table_Func           load_hdmx_stub;
+    TT_Free_Table_Func           free_hdmx_stub;
+#endif
+
+    /* this field was called `load_kerning' up to version 2.1.10 */
+    TT_Load_Table_Func           load_kern;
+
+    TT_Load_Table_Func           load_gasp;
+    TT_Load_Table_Func           load_pclt;
+
+    /* see `ttload.h'; this field was called `load_bitmap_header' up to */
+    /* version 2.1.10                                                   */
+    TT_Load_Table_Func           load_bhed;
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+    /* see `ttsbit.h' */
+    TT_Set_SBit_Strike_OldFunc   set_sbit_strike_stub;
+    TT_Load_Table_Func           load_sbits_stub;
+
+    /*
+     *  The following two fields appeared in version 2.1.8, and were placed
+     *  between `load_sbits' and `load_sbit_image'.  We support them as a
+     *  special exception since they are used by Xfont library within the
+     *  X.Org xserver, and because the probability that other rogue clients
+     *  use the other version 2.1.7 fields below is _extremely_ low.
+     *
+     *  Note that this forces us to disable an interesting memory-saving
+     *  optimization though...
+     */
+
+    TT_Find_SBit_Image_Func      find_sbit_image;
+    TT_Load_SBit_Metrics_Func    load_sbit_metrics;
+
+#endif
+
+    TT_Load_SBit_Image_Func      load_sbit_image;
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    TT_Free_Table_Func           free_sbits_stub;
+#endif
+
+    /* see `ttpost.h' */
+    TT_Get_PS_Name_Func          get_psname;
+    TT_Free_Table_Func           free_psnames;
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    TT_CharMap_Load_Func         load_charmap_stub;
+    TT_CharMap_Free_Func         free_charmap_stub;
+#endif
+
+    /* starting here, the structure differs from version 2.1.7 */
+
+    /* this field was introduced in version 2.1.8, named `get_psname' */
+    TT_Face_GetKerningFunc       get_kerning;
+
+    /* new elements introduced after version 2.1.10 */
+
+    /* load the font directory, i.e., the offset table and */
+    /* the table directory                                 */
+    TT_Load_Table_Func           load_font_dir;
+    TT_Load_Metrics_Func         load_hmtx;
+
+    TT_Load_Table_Func           load_eblc;
+    TT_Free_Table_Func           free_eblc;
+
+    TT_Set_SBit_Strike_Func      set_sbit_strike;
+    TT_Load_Strike_Metrics_Func  load_strike_metrics;
+
+    TT_Get_Metrics_Func          get_metrics;
+
+  } SFNT_Interface;
+
+
+  /* transitional */
+  typedef SFNT_Interface*   SFNT_Service;
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+#define FT_DEFINE_DRIVERS_OLD_INTERNAL( a )  \
+          a,
+#else
+#define FT_DEFINE_DRIVERS_OLD_INTERNAL( a )  /* empty */
+#endif
+
+#define FT_INTERNAL( a ) \
+          a,
+
+#define FT_DEFINE_SFNT_INTERFACE(                            \
+          class_,                                            \
+          goto_table_,                                       \
+          init_face_,                                        \
+          load_face_,                                        \
+          done_face_,                                        \
+          get_interface_,                                    \
+          load_any_,                                         \
+          load_sfnt_header_,                                 \
+          load_directory_,                                   \
+          load_head_,                                        \
+          load_hhea_,                                        \
+          load_cmap_,                                        \
+          load_maxp_,                                        \
+          load_os2_,                                         \
+          load_post_,                                        \
+          load_name_,                                        \
+          free_name_,                                        \
+          load_hdmx_stub_,                                   \
+          free_hdmx_stub_,                                   \
+          load_kern_,                                        \
+          load_gasp_,                                        \
+          load_pclt_,                                        \
+          load_bhed_,                                        \
+          set_sbit_strike_stub_,                             \
+          load_sbits_stub_,                                  \
+          find_sbit_image_,                                  \
+          load_sbit_metrics_,                                \
+          load_sbit_image_,                                  \
+          free_sbits_stub_,                                  \
+          get_psname_,                                       \
+          free_psnames_,                                     \
+          load_charmap_stub_,                                \
+          free_charmap_stub_,                                \
+          get_kerning_,                                      \
+          load_font_dir_,                                    \
+          load_hmtx_,                                        \
+          load_eblc_,                                        \
+          free_eblc_,                                        \
+          set_sbit_strike_,                                  \
+          load_strike_metrics_,                              \
+          get_metrics_ )                                     \
+  static const SFNT_Interface  class_ =                      \
+  {                                                          \
+    FT_INTERNAL( goto_table_ )                               \
+    FT_INTERNAL( init_face_ )                                \
+    FT_INTERNAL( load_face_ )                                \
+    FT_INTERNAL( done_face_ )                                \
+    FT_INTERNAL( get_interface_ )                            \
+    FT_INTERNAL( load_any_ )                                 \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_sfnt_header_ )      \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_directory_ )        \
+    FT_INTERNAL( load_head_ )                                \
+    FT_INTERNAL( load_hhea_ )                                \
+    FT_INTERNAL( load_cmap_ )                                \
+    FT_INTERNAL( load_maxp_ )                                \
+    FT_INTERNAL( load_os2_ )                                 \
+    FT_INTERNAL( load_post_ )                                \
+    FT_INTERNAL( load_name_ )                                \
+    FT_INTERNAL( free_name_ )                                \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_hdmx_stub_ )        \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( free_hdmx_stub_ )        \
+    FT_INTERNAL( load_kern_ )                                \
+    FT_INTERNAL( load_gasp_ )                                \
+    FT_INTERNAL( load_pclt_ )                                \
+    FT_INTERNAL( load_bhed_ )                                \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( set_sbit_strike_stub_ )  \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_sbits_stub_ )       \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( find_sbit_image_ )       \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_sbit_metrics_ )     \
+    FT_INTERNAL( load_sbit_image_ )                          \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( free_sbits_stub_ )       \
+    FT_INTERNAL( get_psname_ )                               \
+    FT_INTERNAL( free_psnames_ )                             \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_charmap_stub_ )     \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( free_charmap_stub_ )     \
+    FT_INTERNAL( get_kerning_ )                              \
+    FT_INTERNAL( load_font_dir_ )                            \
+    FT_INTERNAL( load_hmtx_ )                                \
+    FT_INTERNAL( load_eblc_ )                                \
+    FT_INTERNAL( free_eblc_ )                                \
+    FT_INTERNAL( set_sbit_strike_ )                          \
+    FT_INTERNAL( load_strike_metrics_ )                      \
+    FT_INTERNAL( get_metrics_ )                              \
+  };
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+#define FT_DEFINE_DRIVERS_OLD_INTERNAL( a, a_ )  \
+          clazz->a = a_;
+#else
+#define FT_DEFINE_DRIVERS_OLD_INTERNAL( a, a_ )  /* empty */
+#endif
+
+#define FT_INTERNAL( a, a_ )  \
+          clazz->a = a_;
+
+#define FT_DEFINE_SFNT_INTERFACE(                             \
+          class_,                                             \
+          goto_table_,                                        \
+          init_face_,                                         \
+          load_face_,                                         \
+          done_face_,                                         \
+          get_interface_,                                     \
+          load_any_,                                          \
+          load_sfnt_header_,                                  \
+          load_directory_,                                    \
+          load_head_,                                         \
+          load_hhea_,                                         \
+          load_cmap_,                                         \
+          load_maxp_,                                         \
+          load_os2_,                                          \
+          load_post_,                                         \
+          load_name_,                                         \
+          free_name_,                                         \
+          load_hdmx_stub_,                                    \
+          free_hdmx_stub_,                                    \
+          load_kern_,                                         \
+          load_gasp_,                                         \
+          load_pclt_,                                         \
+          load_bhed_,                                         \
+          set_sbit_strike_stub_,                              \
+          load_sbits_stub_,                                   \
+          find_sbit_image_,                                   \
+          load_sbit_metrics_,                                 \
+          load_sbit_image_,                                   \
+          free_sbits_stub_,                                   \
+          get_psname_,                                        \
+          free_psnames_,                                      \
+          load_charmap_stub_,                                 \
+          free_charmap_stub_,                                 \
+          get_kerning_,                                       \
+          load_font_dir_,                                     \
+          load_hmtx_,                                         \
+          load_eblc_,                                         \
+          free_eblc_,                                         \
+          set_sbit_strike_,                                   \
+          load_strike_metrics_,                               \
+          get_metrics_ )                                      \
+  void                                                        \
+  FT_Init_Class_ ## class_( FT_Library       library,         \
+                            SFNT_Interface*  clazz )          \
+  {                                                           \
+    FT_UNUSED( library );                                     \
+                                                              \
+    FT_INTERNAL( goto_table, goto_table_ )                    \
+    FT_INTERNAL( init_face, init_face_ )                      \
+    FT_INTERNAL( load_face, load_face_ )                      \
+    FT_INTERNAL( done_face, done_face_ )                      \
+    FT_INTERNAL( get_interface, get_interface_ )              \
+    FT_INTERNAL( load_any, load_any_ )                        \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_sfnt_header,         \
+                                    load_sfnt_header_ )       \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_directory,           \
+                                    load_directory_ )         \
+    FT_INTERNAL( load_head, load_head_ )                      \
+    FT_INTERNAL( load_hhea, load_hhea_ )                      \
+    FT_INTERNAL( load_cmap, load_cmap_ )                      \
+    FT_INTERNAL( load_maxp, load_maxp_ )                      \
+    FT_INTERNAL( load_os2, load_os2_ )                        \
+    FT_INTERNAL( load_post, load_post_ )                      \
+    FT_INTERNAL( load_name, load_name_ )                      \
+    FT_INTERNAL( free_name, free_name_ )                      \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_hdmx_stub,           \
+                                    load_hdmx_stub_ )         \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( free_hdmx_stub,           \
+                                    free_hdmx_stub_ )         \
+    FT_INTERNAL( load_kern, load_kern_ )                      \
+    FT_INTERNAL( load_gasp, load_gasp_ )                      \
+    FT_INTERNAL( load_pclt, load_pclt_ )                      \
+    FT_INTERNAL( load_bhed, load_bhed_ )                      \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( set_sbit_strike_stub,     \
+                                    set_sbit_strike_stub_ )   \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_sbits_stub,          \
+                                    load_sbits_stub_ )        \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( find_sbit_image,          \
+                                    find_sbit_image_ )        \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_sbit_metrics,        \
+                                    load_sbit_metrics_ )      \
+    FT_INTERNAL( load_sbit_image, load_sbit_image_ )          \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( free_sbits_stub,          \
+                                    free_sbits_stub_ )        \
+    FT_INTERNAL( get_psname, get_psname_ )                    \
+    FT_INTERNAL( free_psnames, free_psnames_ )                \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( load_charmap_stub,        \
+                                    load_charmap_stub_ )      \
+    FT_DEFINE_DRIVERS_OLD_INTERNAL( free_charmap_stub,        \
+                                    free_charmap_stub_ )      \
+    FT_INTERNAL( get_kerning, get_kerning_ )                  \
+    FT_INTERNAL( load_font_dir, load_font_dir_ )              \
+    FT_INTERNAL( load_hmtx, load_hmtx_ )                      \
+    FT_INTERNAL( load_eblc, load_eblc_ )                      \
+    FT_INTERNAL( free_eblc, free_eblc_ )                      \
+    FT_INTERNAL( set_sbit_strike, set_sbit_strike_ )          \
+    FT_INTERNAL( load_strike_metrics, load_strike_metrics_ )  \
+    FT_INTERNAL( get_metrics, get_metrics_ )                  \
+  }
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+FT_END_HEADER
+
+#endif /* __SFNT_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/t1types.h b/include/freetype/internal/t1types.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/t1types.h
@@ -0,0 +1,259 @@
+/***************************************************************************/
+/*                                                                         */
+/*  t1types.h                                                              */
+/*                                                                         */
+/*    Basic Type1/Type2 type definitions and interface (specification      */
+/*    only).                                                               */
+/*                                                                         */
+/*  Copyright 1996-2004, 2006, 2008, 2009, 2011 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __T1TYPES_H__
+#define __T1TYPES_H__
+
+
+#include <ft2build.h>
+#include FT_TYPE1_TABLES_H
+#include FT_INTERNAL_POSTSCRIPT_HINTS_H
+#include FT_INTERNAL_SERVICE_H
+#include FT_SERVICE_POSTSCRIPT_CMAPS_H
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***              REQUIRED TYPE1/TYPE2 TABLES DEFINITIONS              ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    T1_EncodingRec                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure modeling a custom encoding.                            */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    num_chars  :: The number of character codes in the encoding.       */
+  /*                  Usually 256.                                         */
+  /*                                                                       */
+  /*    code_first :: The lowest valid character code in the encoding.     */
+  /*                                                                       */
+  /*    code_last  :: The highest valid character code in the encoding     */
+  /*                  + 1. When equal to code_first there are no valid     */
+  /*                  character codes.                                     */
+  /*                                                                       */
+  /*    char_index :: An array of corresponding glyph indices.             */
+  /*                                                                       */
+  /*    char_name  :: An array of corresponding glyph names.               */
+  /*                                                                       */
+  typedef struct  T1_EncodingRecRec_
+  {
+    FT_Int       num_chars;
+    FT_Int       code_first;
+    FT_Int       code_last;
+
+    FT_UShort*   char_index;
+    FT_String**  char_name;
+
+  } T1_EncodingRec, *T1_Encoding;
+
+
+  /* used to hold extra data of PS_FontInfoRec that
+   * cannot be stored in the publicly defined structure.
+   *
+   * Note these can't be blended with multiple-masters.
+   */
+  typedef struct  PS_FontExtraRec_
+  {
+    FT_UShort  fs_type;
+
+  } PS_FontExtraRec;
+
+
+  typedef struct  T1_FontRec_
+  {
+    PS_FontInfoRec   font_info;         /* font info dictionary   */
+    PS_FontExtraRec  font_extra;        /* font info extra fields */
+    PS_PrivateRec    private_dict;      /* private dictionary     */
+    FT_String*       font_name;         /* top-level dictionary   */
+
+    T1_EncodingType  encoding_type;
+    T1_EncodingRec   encoding;
+
+    FT_Byte*         subrs_block;
+    FT_Byte*         charstrings_block;
+    FT_Byte*         glyph_names_block;
+
+    FT_Int           num_subrs;
+    FT_Byte**        subrs;
+    FT_PtrDist*      subrs_len;
+
+    FT_Int           num_glyphs;
+    FT_String**      glyph_names;       /* array of glyph names       */
+    FT_Byte**        charstrings;       /* array of glyph charstrings */
+    FT_PtrDist*      charstrings_len;
+
+    FT_Byte          paint_type;
+    FT_Byte          font_type;
+    FT_Matrix        font_matrix;
+    FT_Vector        font_offset;
+    FT_BBox          font_bbox;
+    FT_Long          font_id;
+
+    FT_Fixed         stroke_width;
+
+  } T1_FontRec, *T1_Font;
+
+
+  typedef struct  CID_SubrsRec_
+  {
+    FT_UInt    num_subrs;
+    FT_Byte**  code;
+
+  } CID_SubrsRec, *CID_Subrs;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***                AFM FONT INFORMATION STRUCTURES                    ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  typedef struct  AFM_TrackKernRec_
+  {
+    FT_Int    degree;
+    FT_Fixed  min_ptsize;
+    FT_Fixed  min_kern;
+    FT_Fixed  max_ptsize;
+    FT_Fixed  max_kern;
+
+  } AFM_TrackKernRec, *AFM_TrackKern;
+
+  typedef struct  AFM_KernPairRec_
+  {
+    FT_Int  index1;
+    FT_Int  index2;
+    FT_Int  x;
+    FT_Int  y;
+
+  } AFM_KernPairRec, *AFM_KernPair;
+
+  typedef struct  AFM_FontInfoRec_
+  {
+    FT_Bool        IsCIDFont;
+    FT_BBox        FontBBox;
+    FT_Fixed       Ascender;
+    FT_Fixed       Descender;
+    AFM_TrackKern  TrackKerns;   /* free if non-NULL */
+    FT_Int         NumTrackKern;
+    AFM_KernPair   KernPairs;    /* free if non-NULL */
+    FT_Int         NumKernPair;
+
+  } AFM_FontInfoRec, *AFM_FontInfo;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***                ORIGINAL T1_FACE CLASS DEFINITION                  ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  typedef struct T1_FaceRec_*   T1_Face;
+  typedef struct CID_FaceRec_*  CID_Face;
+
+
+  typedef struct  T1_FaceRec_
+  {
+    FT_FaceRec      root;
+    T1_FontRec      type1;
+    const void*     psnames;
+    const void*     psaux;
+    const void*     afm_data;
+    FT_CharMapRec   charmaprecs[2];
+    FT_CharMap      charmaps[2];
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    PS_Unicodes     unicode_map;
+#endif
+
+    /* support for Multiple Masters fonts */
+    PS_Blend        blend;
+
+    /* undocumented, optional: indices of subroutines that express      */
+    /* the NormalizeDesignVector and the ConvertDesignVector procedure, */
+    /* respectively, as Type 2 charstrings; -1 if keywords not present  */
+    FT_Int           ndv_idx;
+    FT_Int           cdv_idx;
+
+    /* undocumented, optional: has the same meaning as len_buildchar */
+    /* for Type 2 fonts; manipulated by othersubrs 19, 24, and 25    */
+    FT_UInt          len_buildchar;
+    FT_Long*         buildchar;
+
+    /* since version 2.1 - interface to PostScript hinter */
+    const void*     pshinter;
+
+  } T1_FaceRec;
+
+
+  typedef struct  CID_FaceRec_
+  {
+    FT_FaceRec       root;
+    void*            psnames;
+    void*            psaux;
+    CID_FaceInfoRec  cid;
+    PS_FontExtraRec  font_extra;
+#if 0
+    void*            afm_data;
+#endif
+    CID_Subrs        subrs;
+
+    /* since version 2.1 - interface to PostScript hinter */
+    void*            pshinter;
+
+    /* since version 2.1.8, but was originally positioned after `afm_data' */
+    FT_Byte*         binary_data; /* used if hex data has been converted */
+    FT_Stream        cid_stream;
+
+  } CID_FaceRec;
+
+
+FT_END_HEADER
+
+#endif /* __T1TYPES_H__ */
+
+
+/* END */
diff --git a/include/freetype/internal/tttypes.h b/include/freetype/internal/tttypes.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/internal/tttypes.h
@@ -0,0 +1,1543 @@
+/***************************************************************************/
+/*                                                                         */
+/*  tttypes.h                                                              */
+/*                                                                         */
+/*    Basic SFNT/TrueType type definitions and interface (specification    */
+/*    only).                                                               */
+/*                                                                         */
+/*  Copyright 1996-2002, 2004-2008, 2012 by                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __TTTYPES_H__
+#define __TTTYPES_H__
+
+
+#include <ft2build.h>
+#include FT_TRUETYPE_TABLES_H
+#include FT_INTERNAL_OBJECTS_H
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+#include FT_MULTIPLE_MASTERS_H
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***             REQUIRED TRUETYPE/OPENTYPE TABLES DEFINITIONS         ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TTC_HeaderRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    TrueType collection header.  This table contains the offsets of    */
+  /*    the font headers of each distinct TrueType face in the file.       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    tag     :: Must be `ttc ' to indicate a TrueType collection.       */
+  /*                                                                       */
+  /*    version :: The version number.                                     */
+  /*                                                                       */
+  /*    count   :: The number of faces in the collection.  The             */
+  /*               specification says this should be an unsigned long, but */
+  /*               we use a signed long since we need the value -1 for     */
+  /*               specific purposes.                                      */
+  /*                                                                       */
+  /*    offsets :: The offsets of the font headers, one per face.          */
+  /*                                                                       */
+  typedef struct  TTC_HeaderRec_
+  {
+    FT_ULong   tag;
+    FT_Fixed   version;
+    FT_Long    count;
+    FT_ULong*  offsets;
+
+  } TTC_HeaderRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    SFNT_HeaderRec                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    SFNT file format header.                                           */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    format_tag     :: The font format tag.                             */
+  /*                                                                       */
+  /*    num_tables     :: The number of tables in file.                    */
+  /*                                                                       */
+  /*    search_range   :: Must be `16 * (max power of 2 <= num_tables)'.   */
+  /*                                                                       */
+  /*    entry_selector :: Must be log2 of `search_range / 16'.             */
+  /*                                                                       */
+  /*    range_shift    :: Must be `num_tables * 16 - search_range'.        */
+  /*                                                                       */
+  typedef struct  SFNT_HeaderRec_
+  {
+    FT_ULong   format_tag;
+    FT_UShort  num_tables;
+    FT_UShort  search_range;
+    FT_UShort  entry_selector;
+    FT_UShort  range_shift;
+
+    FT_ULong   offset;  /* not in file */
+
+  } SFNT_HeaderRec, *SFNT_Header;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_TableRec                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This structure describes a given table of a TrueType font.         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    Tag      :: A four-bytes tag describing the table.                 */
+  /*                                                                       */
+  /*    CheckSum :: The table checksum.  This value can be ignored.        */
+  /*                                                                       */
+  /*    Offset   :: The offset of the table from the start of the TrueType */
+  /*                font in its resource.                                  */
+  /*                                                                       */
+  /*    Length   :: The table length (in bytes).                           */
+  /*                                                                       */
+  typedef struct  TT_TableRec_
+  {
+    FT_ULong  Tag;        /*        table type */
+    FT_ULong  CheckSum;   /*    table checksum */
+    FT_ULong  Offset;     /* table file offset */
+    FT_ULong  Length;     /*      table length */
+
+  } TT_TableRec, *TT_Table;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_LongMetricsRec                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure modeling the long metrics of the `hmtx' and `vmtx'     */
+  /*    TrueType tables.  The values are expressed in font units.          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    advance :: The advance width or height for the glyph.              */
+  /*                                                                       */
+  /*    bearing :: The left-side or top-side bearing for the glyph.        */
+  /*                                                                       */
+  typedef struct  TT_LongMetricsRec_
+  {
+    FT_UShort  advance;
+    FT_Short   bearing;
+
+  } TT_LongMetricsRec, *TT_LongMetrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    TT_ShortMetrics                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple type to model the short metrics of the `hmtx' and `vmtx'  */
+  /*    tables.                                                            */
+  /*                                                                       */
+  typedef FT_Short  TT_ShortMetrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_NameEntryRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure modeling TrueType name records.  Name records are used */
+  /*    to store important strings like family name, style name,           */
+  /*    copyright, etc. in _localized_ versions (i.e., language, encoding, */
+  /*    etc).                                                              */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    platformID   :: The ID of the name's encoding platform.            */
+  /*                                                                       */
+  /*    encodingID   :: The platform-specific ID for the name's encoding.  */
+  /*                                                                       */
+  /*    languageID   :: The platform-specific ID for the name's language.  */
+  /*                                                                       */
+  /*    nameID       :: The ID specifying what kind of name this is.       */
+  /*                                                                       */
+  /*    stringLength :: The length of the string in bytes.                 */
+  /*                                                                       */
+  /*    stringOffset :: The offset to the string in the `name' table.      */
+  /*                                                                       */
+  /*    string       :: A pointer to the string's bytes.  Note that these  */
+  /*                    are usually UTF-16 encoded characters.             */
+  /*                                                                       */
+  typedef struct  TT_NameEntryRec_
+  {
+    FT_UShort  platformID;
+    FT_UShort  encodingID;
+    FT_UShort  languageID;
+    FT_UShort  nameID;
+    FT_UShort  stringLength;
+    FT_ULong   stringOffset;
+
+    /* this last field is not defined in the spec */
+    /* but used by the FreeType engine            */
+
+    FT_Byte*   string;
+
+  } TT_NameEntryRec, *TT_NameEntry;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_NameTableRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure modeling the TrueType name table.                      */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    format         :: The format of the name table.                    */
+  /*                                                                       */
+  /*    numNameRecords :: The number of names in table.                    */
+  /*                                                                       */
+  /*    storageOffset  :: The offset of the name table in the `name'       */
+  /*                      TrueType table.                                  */
+  /*                                                                       */
+  /*    names          :: An array of name records.                        */
+  /*                                                                       */
+  /*    stream         :: the file's input stream.                         */
+  /*                                                                       */
+  typedef struct  TT_NameTableRec_
+  {
+    FT_UShort         format;
+    FT_UInt           numNameRecords;
+    FT_UInt           storageOffset;
+    TT_NameEntryRec*  names;
+    FT_Stream         stream;
+
+  } TT_NameTableRec, *TT_NameTable;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***             OPTIONAL TRUETYPE/OPENTYPE TABLES DEFINITIONS         ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_GaspRangeRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A tiny structure used to model a gasp range according to the       */
+  /*    TrueType specification.                                            */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    maxPPEM  :: The maximum ppem value to which `gaspFlag' applies.    */
+  /*                                                                       */
+  /*    gaspFlag :: A flag describing the grid-fitting and anti-aliasing   */
+  /*                modes to be used.                                      */
+  /*                                                                       */
+  typedef struct  TT_GaspRangeRec_
+  {
+    FT_UShort  maxPPEM;
+    FT_UShort  gaspFlag;
+
+  } TT_GaspRangeRec, *TT_GaspRange;
+
+
+#define TT_GASP_GRIDFIT  0x01
+#define TT_GASP_DOGRAY   0x02
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_GaspRec                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure modeling the TrueType `gasp' table used to specify     */
+  /*    grid-fitting and anti-aliasing behaviour.                          */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    version    :: The version number.                                  */
+  /*                                                                       */
+  /*    numRanges  :: The number of gasp ranges in table.                  */
+  /*                                                                       */
+  /*    gaspRanges :: An array of gasp ranges.                             */
+  /*                                                                       */
+  typedef struct  TT_Gasp_
+  {
+    FT_UShort     version;
+    FT_UShort     numRanges;
+    TT_GaspRange  gaspRanges;
+
+  } TT_GaspRec;
+
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_HdmxEntryRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A small structure used to model the pre-computed widths of a given */
+  /*    size.  They are found in the `hdmx' table.                         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    ppem      :: The pixels per EM value at which these metrics apply. */
+  /*                                                                       */
+  /*    max_width :: The maximum advance width for this metric.            */
+  /*                                                                       */
+  /*    widths    :: An array of widths.  Note: These are 8-bit bytes.     */
+  /*                                                                       */
+  typedef struct  TT_HdmxEntryRec_
+  {
+    FT_Byte   ppem;
+    FT_Byte   max_width;
+    FT_Byte*  widths;
+
+  } TT_HdmxEntryRec, *TT_HdmxEntry;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_HdmxRec                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model the `hdmx' table, which contains         */
+  /*    pre-computed widths for a set of given sizes/dimensions.           */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    version     :: The version number.                                 */
+  /*                                                                       */
+  /*    num_records :: The number of hdmx records.                         */
+  /*                                                                       */
+  /*    records     :: An array of hdmx records.                           */
+  /*                                                                       */
+  typedef struct  TT_HdmxRec_
+  {
+    FT_UShort     version;
+    FT_Short      num_records;
+    TT_HdmxEntry  records;
+
+  } TT_HdmxRec, *TT_Hdmx;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Kern0_PairRec                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a kerning pair for the kerning table     */
+  /*    format 0.  The engine now loads this table if it finds one in the  */
+  /*    font file.                                                         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    left  :: The index of the left glyph in pair.                      */
+  /*                                                                       */
+  /*    right :: The index of the right glyph in pair.                     */
+  /*                                                                       */
+  /*    value :: The kerning distance.  A positive value spaces the        */
+  /*             glyphs, a negative one makes them closer.                 */
+  /*                                                                       */
+  typedef struct  TT_Kern0_PairRec_
+  {
+    FT_UShort  left;   /* index of left  glyph in pair */
+    FT_UShort  right;  /* index of right glyph in pair */
+    FT_FWord   value;  /* kerning value                */
+
+  } TT_Kern0_PairRec, *TT_Kern0_Pair;
+
+#endif /* FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***                    EMBEDDED BITMAPS SUPPORT                       ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_MetricsRec                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to hold the big metrics of a given glyph bitmap   */
+  /*    in a TrueType or OpenType font.  These are usually found in the    */
+  /*    `EBDT' (Microsoft) or `bloc' (Apple) table.                        */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    height       :: The glyph height in pixels.                        */
+  /*                                                                       */
+  /*    width        :: The glyph width in pixels.                         */
+  /*                                                                       */
+  /*    horiBearingX :: The horizontal left bearing.                       */
+  /*                                                                       */
+  /*    horiBearingY :: The horizontal top bearing.                        */
+  /*                                                                       */
+  /*    horiAdvance  :: The horizontal advance.                            */
+  /*                                                                       */
+  /*    vertBearingX :: The vertical left bearing.                         */
+  /*                                                                       */
+  /*    vertBearingY :: The vertical top bearing.                          */
+  /*                                                                       */
+  /*    vertAdvance  :: The vertical advance.                              */
+  /*                                                                       */
+  typedef struct  TT_SBit_MetricsRec_
+  {
+    FT_Byte  height;
+    FT_Byte  width;
+
+    FT_Char  horiBearingX;
+    FT_Char  horiBearingY;
+    FT_Byte  horiAdvance;
+
+    FT_Char  vertBearingX;
+    FT_Char  vertBearingY;
+    FT_Byte  vertAdvance;
+
+  } TT_SBit_MetricsRec, *TT_SBit_Metrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_SmallMetricsRec                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to hold the small metrics of a given glyph bitmap */
+  /*    in a TrueType or OpenType font.  These are usually found in the    */
+  /*    `EBDT' (Microsoft) or the `bdat' (Apple) table.                    */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    height   :: The glyph height in pixels.                            */
+  /*                                                                       */
+  /*    width    :: The glyph width in pixels.                             */
+  /*                                                                       */
+  /*    bearingX :: The left-side bearing.                                 */
+  /*                                                                       */
+  /*    bearingY :: The top-side bearing.                                  */
+  /*                                                                       */
+  /*    advance  :: The advance width or height.                           */
+  /*                                                                       */
+  typedef struct  TT_SBit_Small_Metrics_
+  {
+    FT_Byte  height;
+    FT_Byte  width;
+
+    FT_Char  bearingX;
+    FT_Char  bearingY;
+    FT_Byte  advance;
+
+  } TT_SBit_SmallMetricsRec, *TT_SBit_SmallMetrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_LineMetricsRec                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to describe the text line metrics of a given      */
+  /*    bitmap strike, for either a horizontal or vertical layout.         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    ascender                :: The ascender in pixels.                 */
+  /*                                                                       */
+  /*    descender               :: The descender in pixels.                */
+  /*                                                                       */
+  /*    max_width               :: The maximum glyph width in pixels.      */
+  /*                                                                       */
+  /*    caret_slope_enumerator  :: Rise of the caret slope, typically set  */
+  /*                               to 1 for non-italic fonts.              */
+  /*                                                                       */
+  /*    caret_slope_denominator :: Rise of the caret slope, typically set  */
+  /*                               to 0 for non-italic fonts.              */
+  /*                                                                       */
+  /*    caret_offset            :: Offset in pixels to move the caret for  */
+  /*                               proper positioning.                     */
+  /*                                                                       */
+  /*    min_origin_SB           :: Minimum of horiBearingX (resp.          */
+  /*                               vertBearingY).                          */
+  /*    min_advance_SB          :: Minimum of                              */
+  /*                                                                       */
+  /*                                 horizontal advance -                  */
+  /*                                   ( horiBearingX + width )            */
+  /*                                                                       */
+  /*                               resp.                                   */
+  /*                                                                       */
+  /*                                 vertical advance -                    */
+  /*                                   ( vertBearingY + height )           */
+  /*                                                                       */
+  /*    max_before_BL           :: Maximum of horiBearingY (resp.          */
+  /*                               vertBearingY).                          */
+  /*                                                                       */
+  /*    min_after_BL            :: Minimum of                              */
+  /*                                                                       */
+  /*                                 horiBearingY - height                 */
+  /*                                                                       */
+  /*                               resp.                                   */
+  /*                                                                       */
+  /*                                 vertBearingX - width                  */
+  /*                                                                       */
+  /*    pads                    :: Unused (to make the size of the record  */
+  /*                               a multiple of 32 bits.                  */
+  /*                                                                       */
+  typedef struct  TT_SBit_LineMetricsRec_
+  {
+    FT_Char  ascender;
+    FT_Char  descender;
+    FT_Byte  max_width;
+    FT_Char  caret_slope_numerator;
+    FT_Char  caret_slope_denominator;
+    FT_Char  caret_offset;
+    FT_Char  min_origin_SB;
+    FT_Char  min_advance_SB;
+    FT_Char  max_before_BL;
+    FT_Char  min_after_BL;
+    FT_Char  pads[2];
+
+  } TT_SBit_LineMetricsRec, *TT_SBit_LineMetrics;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_RangeRec                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A TrueType/OpenType subIndexTable as defined in the `EBLC'         */
+  /*    (Microsoft) or `bloc' (Apple) tables.                              */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    first_glyph   :: The first glyph index in the range.               */
+  /*                                                                       */
+  /*    last_glyph    :: The last glyph index in the range.                */
+  /*                                                                       */
+  /*    index_format  :: The format of index table.  Valid values are 1    */
+  /*                     to 5.                                             */
+  /*                                                                       */
+  /*    image_format  :: The format of `EBDT' image data.                  */
+  /*                                                                       */
+  /*    image_offset  :: The offset to image data in `EBDT'.               */
+  /*                                                                       */
+  /*    image_size    :: For index formats 2 and 5.  This is the size in   */
+  /*                     bytes of each glyph bitmap.                       */
+  /*                                                                       */
+  /*    big_metrics   :: For index formats 2 and 5.  This is the big       */
+  /*                     metrics for each glyph bitmap.                    */
+  /*                                                                       */
+  /*    num_glyphs    :: For index formats 4 and 5.  This is the number of */
+  /*                     glyphs in the code array.                         */
+  /*                                                                       */
+  /*    glyph_offsets :: For index formats 1 and 3.                        */
+  /*                                                                       */
+  /*    glyph_codes   :: For index formats 4 and 5.                        */
+  /*                                                                       */
+  /*    table_offset  :: The offset of the index table in the `EBLC'       */
+  /*                     table.  Only used during strike loading.          */
+  /*                                                                       */
+  typedef struct  TT_SBit_RangeRec_
+  {
+    FT_UShort           first_glyph;
+    FT_UShort           last_glyph;
+
+    FT_UShort           index_format;
+    FT_UShort           image_format;
+    FT_ULong            image_offset;
+
+    FT_ULong            image_size;
+    TT_SBit_MetricsRec  metrics;
+    FT_ULong            num_glyphs;
+
+    FT_ULong*           glyph_offsets;
+    FT_UShort*          glyph_codes;
+
+    FT_ULong            table_offset;
+
+  } TT_SBit_RangeRec, *TT_SBit_Range;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_StrikeRec                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used describe a given bitmap strike in the `EBLC'      */
+  /*    (Microsoft) or `bloc' (Apple) tables.                              */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*   num_index_ranges :: The number of index ranges.                     */
+  /*                                                                       */
+  /*   index_ranges     :: An array of glyph index ranges.                 */
+  /*                                                                       */
+  /*   color_ref        :: Unused.  `color_ref' is put in for future       */
+  /*                       enhancements, but these fields are already      */
+  /*                       in use by other platforms (e.g. Newton).        */
+  /*                       For details, please see                         */
+  /*                                                                       */
+  /*                         http://fonts.apple.com/                       */
+  /*                                TTRefMan/RM06/Chap6bloc.html           */
+  /*                                                                       */
+  /*   hori             :: The line metrics for horizontal layouts.        */
+  /*                                                                       */
+  /*   vert             :: The line metrics for vertical layouts.          */
+  /*                                                                       */
+  /*   start_glyph      :: The lowest glyph index for this strike.         */
+  /*                                                                       */
+  /*   end_glyph        :: The highest glyph index for this strike.        */
+  /*                                                                       */
+  /*   x_ppem           :: The number of horizontal pixels per EM.         */
+  /*                                                                       */
+  /*   y_ppem           :: The number of vertical pixels per EM.           */
+  /*                                                                       */
+  /*   bit_depth        :: The bit depth.  Valid values are 1, 2, 4,       */
+  /*                       and 8.                                          */
+  /*                                                                       */
+  /*   flags            :: Is this a vertical or horizontal strike?  For   */
+  /*                       details, please see                             */
+  /*                                                                       */
+  /*                         http://fonts.apple.com/                       */
+  /*                                TTRefMan/RM06/Chap6bloc.html           */
+  /*                                                                       */
+  typedef struct  TT_SBit_StrikeRec_
+  {
+    FT_Int                  num_ranges;
+    TT_SBit_Range           sbit_ranges;
+    FT_ULong                ranges_offset;
+
+    FT_ULong                color_ref;
+
+    TT_SBit_LineMetricsRec  hori;
+    TT_SBit_LineMetricsRec  vert;
+
+    FT_UShort               start_glyph;
+    FT_UShort               end_glyph;
+
+    FT_Byte                 x_ppem;
+    FT_Byte                 y_ppem;
+
+    FT_Byte                 bit_depth;
+    FT_Char                 flags;
+
+  } TT_SBit_StrikeRec, *TT_SBit_Strike;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_ComponentRec                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A simple structure to describe a compound sbit element.            */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    glyph_code :: The element's glyph index.                           */
+  /*                                                                       */
+  /*    x_offset   :: The element's left bearing.                          */
+  /*                                                                       */
+  /*    y_offset   :: The element's top bearing.                           */
+  /*                                                                       */
+  typedef struct  TT_SBit_ComponentRec_
+  {
+    FT_UShort  glyph_code;
+    FT_Char    x_offset;
+    FT_Char    y_offset;
+
+  } TT_SBit_ComponentRec, *TT_SBit_Component;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_SBit_ScaleRec                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used describe a given bitmap scaling table, as defined */
+  /*    in the `EBSC' table.                                               */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    hori              :: The horizontal line metrics.                  */
+  /*                                                                       */
+  /*    vert              :: The vertical line metrics.                    */
+  /*                                                                       */
+  /*    x_ppem            :: The number of horizontal pixels per EM.       */
+  /*                                                                       */
+  /*    y_ppem            :: The number of vertical pixels per EM.         */
+  /*                                                                       */
+  /*    x_ppem_substitute :: Substitution x_ppem value.                    */
+  /*                                                                       */
+  /*    y_ppem_substitute :: Substitution y_ppem value.                    */
+  /*                                                                       */
+  typedef struct  TT_SBit_ScaleRec_
+  {
+    TT_SBit_LineMetricsRec  hori;
+    TT_SBit_LineMetricsRec  vert;
+
+    FT_Byte                 x_ppem;
+    FT_Byte                 y_ppem;
+
+    FT_Byte                 x_ppem_substitute;
+    FT_Byte                 y_ppem_substitute;
+
+  } TT_SBit_ScaleRec, *TT_SBit_Scale;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***                  POSTSCRIPT GLYPH NAMES SUPPORT                   ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Post_20Rec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Postscript names sub-table, format 2.0.  Stores the PS name of     */
+  /*    each glyph in the font face.                                       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    num_glyphs    :: The number of named glyphs in the table.          */
+  /*                                                                       */
+  /*    num_names     :: The number of PS names stored in the table.       */
+  /*                                                                       */
+  /*    glyph_indices :: The indices of the glyphs in the names arrays.    */
+  /*                                                                       */
+  /*    glyph_names   :: The PS names not in Mac Encoding.                 */
+  /*                                                                       */
+  typedef struct  TT_Post_20Rec_
+  {
+    FT_UShort   num_glyphs;
+    FT_UShort   num_names;
+    FT_UShort*  glyph_indices;
+    FT_Char**   glyph_names;
+
+  } TT_Post_20Rec, *TT_Post_20;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Post_25Rec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Postscript names sub-table, format 2.5.  Stores the PS name of     */
+  /*    each glyph in the font face.                                       */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    num_glyphs :: The number of glyphs in the table.                   */
+  /*                                                                       */
+  /*    offsets    :: An array of signed offsets in a normal Mac           */
+  /*                  Postscript name encoding.                            */
+  /*                                                                       */
+  typedef struct  TT_Post_25_
+  {
+    FT_UShort  num_glyphs;
+    FT_Char*   offsets;
+
+  } TT_Post_25Rec, *TT_Post_25;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Post_NamesRec                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Postscript names table, either format 2.0 or 2.5.                  */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    loaded    :: A flag to indicate whether the PS names are loaded.   */
+  /*                                                                       */
+  /*    format_20 :: The sub-table used for format 2.0.                    */
+  /*                                                                       */
+  /*    format_25 :: The sub-table used for format 2.5.                    */
+  /*                                                                       */
+  typedef struct  TT_Post_NamesRec_
+  {
+    FT_Bool  loaded;
+
+    union
+    {
+      TT_Post_20Rec  format_20;
+      TT_Post_25Rec  format_25;
+
+    } names;
+
+  } TT_Post_NamesRec, *TT_Post_Names;
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***                    GX VARIATION TABLE SUPPORT                     ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+  typedef struct GX_BlendRec_  *GX_Blend;
+#endif
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***              EMBEDDED BDF PROPERTIES TABLE SUPPORT                ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*
+   * These types are used to support a `BDF ' table that isn't part of the
+   * official TrueType specification.  It is mainly used in SFNT-based
+   * bitmap fonts that were generated from a set of BDF fonts.
+   *
+   * The format of the table is as follows.
+   *
+   *   USHORT   version      `BDF ' table version number, should be 0x0001.
+   *   USHORT   strikeCount  Number of strikes (bitmap sizes) in this table.
+   *   ULONG    stringTable  Offset (from start of BDF table) to string
+   *                         table.
+   *
+   * This is followed by an array of `strikeCount' descriptors, having the
+   * following format.
+   *
+   *   USHORT   ppem         Vertical pixels per EM for this strike.
+   *   USHORT   numItems     Number of items for this strike (properties and
+   *                         atoms).  Maximum is 255.
+   *
+   * This array in turn is followed by `strikeCount' value sets.  Each
+   * `value set' is an array of `numItems' items with the following format.
+   *
+   *   ULONG    item_name    Offset in string table to item name.
+   *   USHORT   item_type    The item type.  Possible values are
+   *                            0 => string (e.g., COMMENT)
+   *                            1 => atom   (e.g., FONT or even SIZE)
+   *                            2 => int32
+   *                            3 => uint32
+   *                         0x10 => A flag to indicate a properties.  This
+   *                                 is ORed with the above values.
+   *   ULONG    item_value   For strings  => Offset into string table without
+   *                                         the corresponding double quotes.
+   *                         For atoms    => Offset into string table.
+   *                         For integers => Direct value.
+   *
+   * All strings in the string table consist of bytes and are
+   * zero-terminated.
+   *
+   */
+
+#ifdef TT_CONFIG_OPTION_BDF
+
+  typedef struct  TT_BDFRec_
+  {
+    FT_Byte*   table;
+    FT_Byte*   table_end;
+    FT_Byte*   strings;
+    FT_ULong   strings_size;
+    FT_UInt    num_strikes;
+    FT_Bool    loaded;
+
+  } TT_BDFRec, *TT_BDF;
+
+#endif /* TT_CONFIG_OPTION_BDF */
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /***                  ORIGINAL TT_FACE CLASS DEFINITION                ***/
+  /***                                                                   ***/
+  /***                                                                   ***/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This structure/class is defined here because it is common to the      */
+  /* following formats: TTF, OpenType-TT, and OpenType-CFF.                */
+  /*                                                                       */
+  /* Note, however, that the classes TT_Size and TT_GlyphSlot are not      */
+  /* shared between font drivers, and are thus defined in `ttobjs.h'.      */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Type>                                                                */
+  /*    TT_Face                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a TrueType face/font object.  A TT_Face encapsulates   */
+  /*    the resolution and scaling independent parts of a TrueType font    */
+  /*    resource.                                                          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The TT_Face structure is also used as a `parent class' for the     */
+  /*    OpenType-CFF class (T2_Face).                                      */
+  /*                                                                       */
+  typedef struct TT_FaceRec_*  TT_Face;
+
+
+  /* a function type used for the truetype bytecode interpreter hooks */
+  typedef FT_Error
+  (*TT_Interpreter)( void*  exec_context );
+
+  /* forward declaration */
+  typedef struct TT_LoaderRec_*  TT_Loader;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Loader_GotoTableFunc                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Seeks a stream to the start of a given TrueType table.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face   :: A handle to the target face object.                      */
+  /*                                                                       */
+  /*    tag    :: A 4-byte tag used to name the table.                     */
+  /*                                                                       */
+  /*    stream :: The input stream.                                        */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    length :: The length of the table in bytes.  Set to 0 if not       */
+  /*              needed.                                                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The stream cursor must be at the font file's origin.               */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Loader_GotoTableFunc)( TT_Face    face,
+                              FT_ULong   tag,
+                              FT_Stream  stream,
+                              FT_ULong*  length );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Loader_StartGlyphFunc                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Seeks a stream to the start of a given glyph element, and opens a  */
+  /*    frame for it.                                                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    loader      :: The current TrueType glyph loader object.           */
+  /*                                                                       */
+  /*    glyph index :: The index of the glyph to access.                   */
+  /*                                                                       */
+  /*    offset      :: The offset of the glyph according to the            */
+  /*                   `locations' table.                                  */
+  /*                                                                       */
+  /*    byte_count  :: The size of the frame in bytes.                     */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This function is normally equivalent to FT_STREAM_SEEK(offset)     */
+  /*    followed by FT_FRAME_ENTER(byte_count) with the loader's stream,   */
+  /*    but alternative formats (e.g. compressed ones) might use something */
+  /*    different.                                                         */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Loader_StartGlyphFunc)( TT_Loader  loader,
+                               FT_UInt    glyph_index,
+                               FT_ULong   offset,
+                               FT_UInt    byte_count );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Loader_ReadGlyphFunc                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Reads one glyph element (its header, a simple glyph, or a          */
+  /*    composite) from the loader's current stream frame.                 */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    loader :: The current TrueType glyph loader object.                */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  typedef FT_Error
+  (*TT_Loader_ReadGlyphFunc)( TT_Loader  loader );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <FuncType>                                                            */
+  /*    TT_Loader_EndGlyphFunc                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Closes the current loader stream frame for the glyph.              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    loader :: The current TrueType glyph loader object.                */
+  /*                                                                       */
+  typedef void
+  (*TT_Loader_EndGlyphFunc)( TT_Loader  loader );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                         TrueType Face Type                            */
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Face                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The TrueType face class.  These objects model the resolution and   */
+  /*    point-size independent data found in a TrueType font file.         */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    root                 :: The base FT_Face structure, managed by the */
+  /*                            base layer.                                */
+  /*                                                                       */
+  /*    ttc_header           :: The TrueType collection header, used when  */
+  /*                            the file is a `ttc' rather than a `ttf'.   */
+  /*                            For ordinary font files, the field         */
+  /*                            `ttc_header.count' is set to 0.            */
+  /*                                                                       */
+  /*    format_tag           :: The font format tag.                       */
+  /*                                                                       */
+  /*    num_tables           :: The number of TrueType tables in this font */
+  /*                            file.                                      */
+  /*                                                                       */
+  /*    dir_tables           :: The directory of TrueType tables for this  */
+  /*                            font file.                                 */
+  /*                                                                       */
+  /*    header               :: The font's font header (`head' table).     */
+  /*                            Read on font opening.                      */
+  /*                                                                       */
+  /*    horizontal           :: The font's horizontal header (`hhea'       */
+  /*                            table).  This field also contains the      */
+  /*                            associated horizontal metrics table        */
+  /*                            (`hmtx').                                  */
+  /*                                                                       */
+  /*    max_profile          :: The font's maximum profile table.  Read on */
+  /*                            font opening.  Note that some maximum      */
+  /*                            values cannot be taken directly from this  */
+  /*                            table.  We thus define additional fields   */
+  /*                            below to hold the computed maxima.         */
+  /*                                                                       */
+  /*    vertical_info        :: A boolean which is set when the font file  */
+  /*                            contains vertical metrics.  If not, the    */
+  /*                            value of the `vertical' field is           */
+  /*                            undefined.                                 */
+  /*                                                                       */
+  /*    vertical             :: The font's vertical header (`vhea' table). */
+  /*                            This field also contains the associated    */
+  /*                            vertical metrics table (`vmtx'), if found. */
+  /*                            IMPORTANT: The contents of this field is   */
+  /*                            undefined if the `verticalInfo' field is   */
+  /*                            unset.                                     */
+  /*                                                                       */
+  /*    num_names            :: The number of name records within this     */
+  /*                            TrueType font.                             */
+  /*                                                                       */
+  /*    name_table           :: The table of name records (`name').        */
+  /*                                                                       */
+  /*    os2                  :: The font's OS/2 table (`OS/2').            */
+  /*                                                                       */
+  /*    postscript           :: The font's PostScript table (`post'        */
+  /*                            table).  The PostScript glyph names are    */
+  /*                            not loaded by the driver on face opening.  */
+  /*                            See the `ttpost' module for more details.  */
+  /*                                                                       */
+  /*    cmap_table           :: Address of the face's `cmap' SFNT table    */
+  /*                            in memory (it's an extracted frame).       */
+  /*                                                                       */
+  /*    cmap_size            :: The size in bytes of the `cmap_table'      */
+  /*                            described above.                           */
+  /*                                                                       */
+  /*    goto_table           :: A function called by each TrueType table   */
+  /*                            loader to position a stream's cursor to    */
+  /*                            the start of a given table according to    */
+  /*                            its tag.  It defaults to TT_Goto_Face but  */
+  /*                            can be different for strange formats (e.g. */
+  /*                            Type 42).                                  */
+  /*                                                                       */
+  /*    access_glyph_frame   :: A function used to access the frame of a   */
+  /*                            given glyph within the face's font file.   */
+  /*                                                                       */
+  /*    forget_glyph_frame   :: A function used to forget the frame of a   */
+  /*                            given glyph when all data has been loaded. */
+  /*                                                                       */
+  /*    read_glyph_header    :: A function used to read a glyph header.    */
+  /*                            It must be called between an `access' and  */
+  /*                            `forget'.                                  */
+  /*                                                                       */
+  /*    read_simple_glyph    :: A function used to read a simple glyph.    */
+  /*                            It must be called after the header was     */
+  /*                            read, and before the `forget'.             */
+  /*                                                                       */
+  /*    read_composite_glyph :: A function used to read a composite glyph. */
+  /*                            It must be called after the header was     */
+  /*                            read, and before the `forget'.             */
+  /*                                                                       */
+  /*    sfnt                 :: A pointer to the SFNT service.             */
+  /*                                                                       */
+  /*    psnames              :: A pointer to the PostScript names service. */
+  /*                                                                       */
+  /*    hdmx                 :: The face's horizontal device metrics       */
+  /*                            (`hdmx' table).  This table is optional in */
+  /*                            TrueType/OpenType fonts.                   */
+  /*                                                                       */
+  /*    gasp                 :: The grid-fitting and scaling properties    */
+  /*                            table (`gasp').  This table is optional in */
+  /*                            TrueType/OpenType fonts.                   */
+  /*                                                                       */
+  /*    pclt                 :: The `pclt' SFNT table.                     */
+  /*                                                                       */
+  /*    num_sbit_strikes     :: The number of sbit strikes, i.e., bitmap   */
+  /*                            sizes, embedded in this font.              */
+  /*                                                                       */
+  /*    sbit_strikes         :: An array of sbit strikes embedded in this  */
+  /*                            font.  This table is optional in a         */
+  /*                            TrueType/OpenType font.                    */
+  /*                                                                       */
+  /*    num_sbit_scales      :: The number of sbit scales for this font.   */
+  /*                                                                       */
+  /*    sbit_scales          :: Array of sbit scales embedded in this      */
+  /*                            font.  This table is optional in a         */
+  /*                            TrueType/OpenType font.                    */
+  /*                                                                       */
+  /*    postscript_names     :: A table used to store the Postscript names */
+  /*                            of  the glyphs for this font.  See the     */
+  /*                            file  `ttconfig.h' for comments on the     */
+  /*                            TT_CONFIG_OPTION_POSTSCRIPT_NAMES option.  */
+  /*                                                                       */
+  /*    num_locations        :: The number of glyph locations in this      */
+  /*                            TrueType file.  This should be             */
+  /*                            identical to the number of glyphs.         */
+  /*                            Ignored for Type 2 fonts.                  */
+  /*                                                                       */
+  /*    glyph_locations      :: An array of longs.  These are offsets to   */
+  /*                            glyph data within the `glyf' table.        */
+  /*                            Ignored for Type 2 font faces.             */
+  /*                                                                       */
+  /*    glyf_len             :: The length of the `glyf' table.  Needed    */
+  /*                            for malformed `loca' tables.               */
+  /*                                                                       */
+  /*    font_program_size    :: Size in bytecodes of the face's font       */
+  /*                            program.  0 if none defined.  Ignored for  */
+  /*                            Type 2 fonts.                              */
+  /*                                                                       */
+  /*    font_program         :: The face's font program (bytecode stream)  */
+  /*                            executed at load time, also used during    */
+  /*                            glyph rendering.  Comes from the `fpgm'    */
+  /*                            table.  Ignored for Type 2 font fonts.     */
+  /*                                                                       */
+  /*    cvt_program_size     :: The size in bytecodes of the face's cvt    */
+  /*                            program.  Ignored for Type 2 fonts.        */
+  /*                                                                       */
+  /*    cvt_program          :: The face's cvt program (bytecode stream)   */
+  /*                            executed each time an instance/size is     */
+  /*                            changed/reset.  Comes from the `prep'      */
+  /*                            table.  Ignored for Type 2 fonts.          */
+  /*                                                                       */
+  /*    cvt_size             :: Size of the control value table (in        */
+  /*                            entries).   Ignored for Type 2 fonts.      */
+  /*                                                                       */
+  /*    cvt                  :: The face's original control value table.   */
+  /*                            Coordinates are expressed in unscaled font */
+  /*                            units.  Comes from the `cvt ' table.       */
+  /*                            Ignored for Type 2 fonts.                  */
+  /*                                                                       */
+  /*    num_kern_pairs       :: The number of kerning pairs present in the */
+  /*                            font file.  The engine only loads the      */
+  /*                            first horizontal format 0 kern table it    */
+  /*                            finds in the font file.  Ignored for       */
+  /*                            Type 2 fonts.                              */
+  /*                                                                       */
+  /*    kern_table_index     :: The index of the kerning table in the font */
+  /*                            kerning directory.  Ignored for Type 2     */
+  /*                            fonts.                                     */
+  /*                                                                       */
+  /*    interpreter          :: A pointer to the TrueType bytecode         */
+  /*                            interpreters field is also used to hook    */
+  /*                            the debugger in `ttdebug'.                 */
+  /*                                                                       */
+  /*    unpatented_hinting   :: If true, use only unpatented methods in    */
+  /*                            the bytecode interpreter.                  */
+  /*                                                                       */
+  /*    doblend              :: A boolean which is set if the font should  */
+  /*                            be blended (this is for GX var).           */
+  /*                                                                       */
+  /*    blend                :: Contains the data needed to control GX     */
+  /*                            variation tables (rather like Multiple     */
+  /*                            Master data).                              */
+  /*                                                                       */
+  /*    extra                :: Reserved for third-party font drivers.     */
+  /*                                                                       */
+  /*    postscript_name      :: The PS name of the font.  Used by the      */
+  /*                            postscript name service.                   */
+  /*                                                                       */
+  typedef struct  TT_FaceRec_
+  {
+    FT_FaceRec            root;
+
+    TTC_HeaderRec         ttc_header;
+
+    FT_ULong              format_tag;
+    FT_UShort             num_tables;
+    TT_Table              dir_tables;
+
+    TT_Header             header;       /* TrueType header table          */
+    TT_HoriHeader         horizontal;   /* TrueType horizontal header     */
+
+    TT_MaxProfile         max_profile;
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    FT_ULong              max_components;  /* stubbed to 0 */
+#endif
+
+    FT_Bool               vertical_info;
+    TT_VertHeader         vertical;     /* TT Vertical header, if present */
+
+    FT_UShort             num_names;    /* number of name records  */
+    TT_NameTableRec       name_table;   /* name table              */
+
+    TT_OS2                os2;          /* TrueType OS/2 table            */
+    TT_Postscript         postscript;   /* TrueType Postscript table      */
+
+    FT_Byte*              cmap_table;   /* extracted `cmap' table */
+    FT_ULong              cmap_size;
+
+    TT_Loader_GotoTableFunc   goto_table;
+
+    TT_Loader_StartGlyphFunc  access_glyph_frame;
+    TT_Loader_EndGlyphFunc    forget_glyph_frame;
+    TT_Loader_ReadGlyphFunc   read_glyph_header;
+    TT_Loader_ReadGlyphFunc   read_simple_glyph;
+    TT_Loader_ReadGlyphFunc   read_composite_glyph;
+
+    /* a typeless pointer to the SFNT_Interface table used to load */
+    /* the basic TrueType tables in the face object                */
+    void*                 sfnt;
+
+    /* a typeless pointer to the FT_Service_PsCMapsRec table used to */
+    /* handle glyph names <-> unicode & Mac values                   */
+    void*                 psnames;
+
+
+    /***********************************************************************/
+    /*                                                                     */
+    /* Optional TrueType/OpenType tables                                   */
+    /*                                                                     */
+    /***********************************************************************/
+
+    /* horizontal device metrics */
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    TT_HdmxRec            hdmx;
+#endif
+
+    /* grid-fitting and scaling table */
+    TT_GaspRec            gasp;                 /* the `gasp' table */
+
+    /* PCL 5 table */
+    TT_PCLT               pclt;
+
+    /* embedded bitmaps support */
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    FT_ULong              num_sbit_strikes;
+    TT_SBit_Strike        sbit_strikes;
+#endif
+
+    FT_ULong              num_sbit_scales;
+    TT_SBit_Scale         sbit_scales;
+
+    /* postscript names table */
+    TT_Post_NamesRec      postscript_names;
+
+
+    /***********************************************************************/
+    /*                                                                     */
+    /* TrueType-specific fields (ignored by the OTF-Type2 driver)          */
+    /*                                                                     */
+    /***********************************************************************/
+
+    /* the glyph locations */
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    FT_UShort             num_locations_stub;
+    FT_Long*              glyph_locations_stub;
+#endif
+
+    /* the font program, if any */
+    FT_ULong              font_program_size;
+    FT_Byte*              font_program;
+
+    /* the cvt program, if any */
+    FT_ULong              cvt_program_size;
+    FT_Byte*              cvt_program;
+
+    /* the original, unscaled, control value table */
+    FT_ULong              cvt_size;
+    FT_Short*             cvt;
+
+#ifdef FT_CONFIG_OPTION_OLD_INTERNALS
+    /* the format 0 kerning table, if any */
+    FT_Int                num_kern_pairs;
+    FT_Int                kern_table_index;
+    TT_Kern0_Pair         kern_pairs;
+#endif
+
+    /* A pointer to the bytecode interpreter to use.  This is also */
+    /* used to hook the debugger for the `ttdebug' utility.        */
+    TT_Interpreter        interpreter;
+
+#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
+    /* Use unpatented hinting only. */
+    FT_Bool               unpatented_hinting;
+#endif
+
+    /***********************************************************************/
+    /*                                                                     */
+    /* Other tables or fields. This is used by derivative formats like     */
+    /* OpenType.                                                           */
+    /*                                                                     */
+    /***********************************************************************/
+
+    FT_Generic            extra;
+
+    const char*           postscript_name;
+
+    /* since version 2.1.8, but was originally placed after */
+    /* `glyph_locations_stub'                               */
+    FT_ULong              glyf_len;
+
+    /* since version 2.1.8, but was originally placed before `extra' */
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+    FT_Bool               doblend;
+    GX_Blend              blend;
+#endif
+
+    /* since version 2.2 */
+
+    FT_Byte*              horz_metrics;
+    FT_ULong              horz_metrics_size;
+
+    FT_Byte*              vert_metrics;
+    FT_ULong              vert_metrics_size;
+
+    FT_ULong              num_locations; /* in broken TTF, gid > 0xFFFF */
+    FT_Byte*              glyph_locations;
+
+    FT_Byte*              hdmx_table;
+    FT_ULong              hdmx_table_size;
+    FT_UInt               hdmx_record_count;
+    FT_ULong              hdmx_record_size;
+    FT_Byte*              hdmx_record_sizes;
+
+    FT_Byte*              sbit_table;
+    FT_ULong              sbit_table_size;
+    FT_UInt               sbit_num_strikes;
+
+    FT_Byte*              kern_table;
+    FT_ULong              kern_table_size;
+    FT_UInt               num_kern_tables;
+    FT_UInt32             kern_avail_bits;
+    FT_UInt32             kern_order_bits;
+
+#ifdef TT_CONFIG_OPTION_BDF
+    TT_BDFRec             bdf;
+#endif /* TT_CONFIG_OPTION_BDF */
+
+    /* since 2.3.0 */
+    FT_ULong              horz_metrics_offset;
+    FT_ULong              vert_metrics_offset;
+
+  } TT_FaceRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*  <Struct>                                                             */
+  /*     TT_GlyphZoneRec                                                   */
+  /*                                                                       */
+  /*  <Description>                                                        */
+  /*     A glyph zone is used to load, scale and hint glyph outline        */
+  /*     coordinates.                                                      */
+  /*                                                                       */
+  /*  <Fields>                                                             */
+  /*     memory       :: A handle to the memory manager.                   */
+  /*                                                                       */
+  /*     max_points   :: The maximum size in points of the zone.           */
+  /*                                                                       */
+  /*     max_contours :: Max size in links contours of the zone.           */
+  /*                                                                       */
+  /*     n_points     :: The current number of points in the zone.         */
+  /*                                                                       */
+  /*     n_contours   :: The current number of contours in the zone.       */
+  /*                                                                       */
+  /*     org          :: The original glyph coordinates (font              */
+  /*                     units/scaled).                                    */
+  /*                                                                       */
+  /*     cur          :: The current glyph coordinates (scaled/hinted).    */
+  /*                                                                       */
+  /*     tags         :: The point control tags.                           */
+  /*                                                                       */
+  /*     contours     :: The contours end points.                          */
+  /*                                                                       */
+  /*     first_point  :: Offset of the current subglyph's first point.     */
+  /*                                                                       */
+  typedef struct  TT_GlyphZoneRec_
+  {
+    FT_Memory   memory;
+    FT_UShort   max_points;
+    FT_UShort   max_contours;
+    FT_UShort   n_points;    /* number of points in zone    */
+    FT_Short    n_contours;  /* number of contours          */
+
+    FT_Vector*  org;         /* original point coordinates  */
+    FT_Vector*  cur;         /* current point coordinates   */
+    FT_Vector*  orus;        /* original (unscaled) point coordinates */
+
+    FT_Byte*    tags;        /* current touch flags         */
+    FT_UShort*  contours;    /* contour end points          */
+
+    FT_UShort   first_point; /* offset of first (#0) point  */
+
+  } TT_GlyphZoneRec, *TT_GlyphZone;
+
+
+  /* handle to execution context */
+  typedef struct TT_ExecContextRec_*  TT_ExecContext;
+
+  /* glyph loader structure */
+  typedef struct  TT_LoaderRec_
+  {
+    FT_Face          face;
+    FT_Size          size;
+    FT_GlyphSlot     glyph;
+    FT_GlyphLoader   gloader;
+
+    FT_ULong         load_flags;
+    FT_UInt          glyph_index;
+
+    FT_Stream        stream;
+    FT_Int           byte_len;
+
+    FT_Short         n_contours;
+    FT_BBox          bbox;
+    FT_Int           left_bearing;
+    FT_Int           advance;
+    FT_Int           linear;
+    FT_Bool          linear_def;
+    FT_Bool          preserve_pps;
+    FT_Vector        pp1;
+    FT_Vector        pp2;
+
+    FT_ULong         glyf_offset;
+
+    /* the zone where we load our glyphs */
+    TT_GlyphZoneRec  base;
+    TT_GlyphZoneRec  zone;
+
+    TT_ExecContext   exec;
+    FT_Byte*         instructions;
+    FT_ULong         ins_pos;
+
+    /* for possible extensibility in other formats */
+    void*            other;
+
+    /* since version 2.1.8 */
+    FT_Int           top_bearing;
+    FT_Int           vadvance;
+    FT_Vector        pp3;
+    FT_Vector        pp4;
+
+    /* since version 2.2.1 */
+    FT_Byte*         cursor;
+    FT_Byte*         limit;
+
+  } TT_LoaderRec;
+
+
+FT_END_HEADER
+
+#endif /* __TTTYPES_H__ */
+
+
+/* END */
diff --git a/include/freetype/t1tables.h b/include/freetype/t1tables.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/t1tables.h
@@ -0,0 +1,662 @@
+/***************************************************************************/
+/*                                                                         */
+/*  t1tables.h                                                             */
+/*                                                                         */
+/*    Basic Type 1/Type 2 tables definitions and interface (specification  */
+/*    only).                                                               */
+/*                                                                         */
+/*  Copyright 1996-2004, 2006, 2008, 2009, 2011 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __T1TABLES_H__
+#define __T1TABLES_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    type1_tables                                                       */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    Type 1 Tables                                                      */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    Type~1 (PostScript) specific font tables.                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the definition of Type 1-specific tables,    */
+  /*    including structures related to other PostScript font formats.     */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* Note that we separate font data in PS_FontInfoRec and PS_PrivateRec */
+  /* structures in order to support Multiple Master fonts.               */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_FontInfoRec                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a Type~1 or Type~2 FontInfo dictionary.  */
+  /*    Note that for Multiple Master fonts, each instance has its own     */
+  /*    FontInfo dictionary.                                               */
+  /*                                                                       */
+  typedef struct  PS_FontInfoRec_
+  {
+    FT_String*  version;
+    FT_String*  notice;
+    FT_String*  full_name;
+    FT_String*  family_name;
+    FT_String*  weight;
+    FT_Long     italic_angle;
+    FT_Bool     is_fixed_pitch;
+    FT_Short    underline_position;
+    FT_UShort   underline_thickness;
+
+  } PS_FontInfoRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_FontInfo                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a @PS_FontInfoRec structure.                           */
+  /*                                                                       */
+  typedef struct PS_FontInfoRec_*  PS_FontInfo;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    T1_FontInfo                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This type is equivalent to @PS_FontInfoRec.  It is deprecated but  */
+  /*    kept to maintain source compatibility between various versions of  */
+  /*    FreeType.                                                          */
+  /*                                                                       */
+  typedef PS_FontInfoRec  T1_FontInfo;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_PrivateRec                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a Type~1 or Type~2 private dictionary.   */
+  /*    Note that for Multiple Master fonts, each instance has its own     */
+  /*    Private dictionary.                                                */
+  /*                                                                       */
+  typedef struct  PS_PrivateRec_
+  {
+    FT_Int     unique_id;
+    FT_Int     lenIV;
+
+    FT_Byte    num_blue_values;
+    FT_Byte    num_other_blues;
+    FT_Byte    num_family_blues;
+    FT_Byte    num_family_other_blues;
+
+    FT_Short   blue_values[14];
+    FT_Short   other_blues[10];
+
+    FT_Short   family_blues      [14];
+    FT_Short   family_other_blues[10];
+
+    FT_Fixed   blue_scale;
+    FT_Int     blue_shift;
+    FT_Int     blue_fuzz;
+
+    FT_UShort  standard_width[1];
+    FT_UShort  standard_height[1];
+
+    FT_Byte    num_snap_widths;
+    FT_Byte    num_snap_heights;
+    FT_Bool    force_bold;
+    FT_Bool    round_stem_up;
+
+    FT_Short   snap_widths [13];  /* including std width  */
+    FT_Short   snap_heights[13];  /* including std height */
+
+    FT_Fixed   expansion_factor;
+
+    FT_Long    language_group;
+    FT_Long    password;
+
+    FT_Short   min_feature[2];
+
+  } PS_PrivateRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    PS_Private                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a @PS_PrivateRec structure.                            */
+  /*                                                                       */
+  typedef struct PS_PrivateRec_*  PS_Private;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    T1_Private                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*   This type is equivalent to @PS_PrivateRec.  It is deprecated but    */
+  /*   kept to maintain source compatibility between various versions of   */
+  /*   FreeType.                                                           */
+  /*                                                                       */
+  typedef PS_PrivateRec  T1_Private;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    T1_Blend_Flags                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A set of flags used to indicate which fields are present in a      */
+  /*    given blend dictionary (font info or private).  Used to support    */
+  /*    Multiple Masters fonts.                                            */
+  /*                                                                       */
+  typedef enum  T1_Blend_Flags_
+  {
+    /*# required fields in a FontInfo blend dictionary */
+    T1_BLEND_UNDERLINE_POSITION = 0,
+    T1_BLEND_UNDERLINE_THICKNESS,
+    T1_BLEND_ITALIC_ANGLE,
+
+    /*# required fields in a Private blend dictionary */
+    T1_BLEND_BLUE_VALUES,
+    T1_BLEND_OTHER_BLUES,
+    T1_BLEND_STANDARD_WIDTH,
+    T1_BLEND_STANDARD_HEIGHT,
+    T1_BLEND_STEM_SNAP_WIDTHS,
+    T1_BLEND_STEM_SNAP_HEIGHTS,
+    T1_BLEND_BLUE_SCALE,
+    T1_BLEND_BLUE_SHIFT,
+    T1_BLEND_FAMILY_BLUES,
+    T1_BLEND_FAMILY_OTHER_BLUES,
+    T1_BLEND_FORCE_BOLD,
+
+    /*# never remove */
+    T1_BLEND_MAX
+
+  } T1_Blend_Flags;
+
+  /* */
+
+
+  /*# backwards compatible definitions */
+#define t1_blend_underline_position   T1_BLEND_UNDERLINE_POSITION
+#define t1_blend_underline_thickness  T1_BLEND_UNDERLINE_THICKNESS
+#define t1_blend_italic_angle         T1_BLEND_ITALIC_ANGLE
+#define t1_blend_blue_values          T1_BLEND_BLUE_VALUES
+#define t1_blend_other_blues          T1_BLEND_OTHER_BLUES
+#define t1_blend_standard_widths      T1_BLEND_STANDARD_WIDTH
+#define t1_blend_standard_height      T1_BLEND_STANDARD_HEIGHT
+#define t1_blend_stem_snap_widths     T1_BLEND_STEM_SNAP_WIDTHS
+#define t1_blend_stem_snap_heights    T1_BLEND_STEM_SNAP_HEIGHTS
+#define t1_blend_blue_scale           T1_BLEND_BLUE_SCALE
+#define t1_blend_blue_shift           T1_BLEND_BLUE_SHIFT
+#define t1_blend_family_blues         T1_BLEND_FAMILY_BLUES
+#define t1_blend_family_other_blues   T1_BLEND_FAMILY_OTHER_BLUES
+#define t1_blend_force_bold           T1_BLEND_FORCE_BOLD
+#define t1_blend_max                  T1_BLEND_MAX
+
+
+  /* maximum number of Multiple Masters designs, as defined in the spec */
+#define T1_MAX_MM_DESIGNS     16
+
+  /* maximum number of Multiple Masters axes, as defined in the spec */
+#define T1_MAX_MM_AXIS        4
+
+  /* maximum number of elements in a design map */
+#define T1_MAX_MM_MAP_POINTS  20
+
+
+  /* this structure is used to store the BlendDesignMap entry for an axis */
+  typedef struct  PS_DesignMap_
+  {
+    FT_Byte    num_points;
+    FT_Long*   design_points;
+    FT_Fixed*  blend_points;
+
+  } PS_DesignMapRec, *PS_DesignMap;
+
+  /* backwards-compatible definition */
+  typedef PS_DesignMapRec  T1_DesignMap;
+
+
+  typedef struct  PS_BlendRec_
+  {
+    FT_UInt          num_designs;
+    FT_UInt          num_axis;
+
+    FT_String*       axis_names[T1_MAX_MM_AXIS];
+    FT_Fixed*        design_pos[T1_MAX_MM_DESIGNS];
+    PS_DesignMapRec  design_map[T1_MAX_MM_AXIS];
+
+    FT_Fixed*        weight_vector;
+    FT_Fixed*        default_weight_vector;
+
+    PS_FontInfo      font_infos[T1_MAX_MM_DESIGNS + 1];
+    PS_Private       privates  [T1_MAX_MM_DESIGNS + 1];
+
+    FT_ULong         blend_bitflags;
+
+    FT_BBox*         bboxes    [T1_MAX_MM_DESIGNS + 1];
+
+    /* since 2.3.0 */
+
+    /* undocumented, optional: the default design instance;   */
+    /* corresponds to default_weight_vector --                */
+    /* num_default_design_vector == 0 means it is not present */
+    /* in the font and associated metrics files               */
+    FT_UInt          default_design_vector[T1_MAX_MM_DESIGNS];
+    FT_UInt          num_default_design_vector;
+
+  } PS_BlendRec, *PS_Blend;
+
+
+  /* backwards-compatible definition */
+  typedef PS_BlendRec  T1_Blend;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    CID_FaceDictRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to represent data in a CID top-level dictionary.  */
+  /*                                                                       */
+  typedef struct  CID_FaceDictRec_
+  {
+    PS_PrivateRec  private_dict;
+
+    FT_UInt        len_buildchar;
+    FT_Fixed       forcebold_threshold;
+    FT_Pos         stroke_width;
+    FT_Fixed       expansion_factor;
+
+    FT_Byte        paint_type;
+    FT_Byte        font_type;
+    FT_Matrix      font_matrix;
+    FT_Vector      font_offset;
+
+    FT_UInt        num_subrs;
+    FT_ULong       subrmap_offset;
+    FT_Int         sd_bytes;
+
+  } CID_FaceDictRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    CID_FaceDict                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a @CID_FaceDictRec structure.                          */
+  /*                                                                       */
+  typedef struct CID_FaceDictRec_*  CID_FaceDict;
+
+  /* */
+
+
+  /* backwards-compatible definition */
+  typedef CID_FaceDictRec  CID_FontDict;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    CID_FaceInfoRec                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to represent CID Face information.                */
+  /*                                                                       */
+  typedef struct  CID_FaceInfoRec_
+  {
+    FT_String*      cid_font_name;
+    FT_Fixed        cid_version;
+    FT_Int          cid_font_type;
+
+    FT_String*      registry;
+    FT_String*      ordering;
+    FT_Int          supplement;
+
+    PS_FontInfoRec  font_info;
+    FT_BBox         font_bbox;
+    FT_ULong        uid_base;
+
+    FT_Int          num_xuid;
+    FT_ULong        xuid[16];
+
+    FT_ULong        cidmap_offset;
+    FT_Int          fd_bytes;
+    FT_Int          gd_bytes;
+    FT_ULong        cid_count;
+
+    FT_Int          num_dicts;
+    CID_FaceDict    font_dicts;
+
+    FT_ULong        data_offset;
+
+  } CID_FaceInfoRec;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    CID_FaceInfo                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A handle to a @CID_FaceInfoRec structure.                          */
+  /*                                                                       */
+  typedef struct CID_FaceInfoRec_*  CID_FaceInfo;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    CID_Info                                                           */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*   This type is equivalent to @CID_FaceInfoRec.  It is deprecated but  */
+  /*   kept to maintain source compatibility between various versions of   */
+  /*   FreeType.                                                           */
+  /*                                                                       */
+  typedef CID_FaceInfoRec  CID_Info;
+
+
+  /************************************************************************
+   *
+   * @function:
+   *    FT_Has_PS_Glyph_Names
+   *
+   * @description:
+   *    Return true if a given face provides reliable PostScript glyph
+   *    names.  This is similar to using the @FT_HAS_GLYPH_NAMES macro,
+   *    except that certain fonts (mostly TrueType) contain incorrect
+   *    glyph name tables.
+   *
+   *    When this function returns true, the caller is sure that the glyph
+   *    names returned by @FT_Get_Glyph_Name are reliable.
+   *
+   * @input:
+   *    face ::
+   *       face handle
+   *
+   * @return:
+   *    Boolean.  True if glyph names are reliable.
+   *
+   */
+  FT_EXPORT( FT_Int )
+  FT_Has_PS_Glyph_Names( FT_Face  face );
+
+
+  /************************************************************************
+   *
+   * @function:
+   *    FT_Get_PS_Font_Info
+   *
+   * @description:
+   *    Retrieve the @PS_FontInfoRec structure corresponding to a given
+   *    PostScript font.
+   *
+   * @input:
+   *    face ::
+   *       PostScript face handle.
+   *
+   * @output:
+   *    afont_info ::
+   *       Output font info structure pointer.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *    The string pointers within the font info structure are owned by
+   *    the face and don't need to be freed by the caller.
+   *
+   *    If the font's format is not PostScript-based, this function will
+   *    return the `FT_Err_Invalid_Argument' error code.
+   *
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_PS_Font_Info( FT_Face      face,
+                       PS_FontInfo  afont_info );
+
+
+  /************************************************************************
+   *
+   * @function:
+   *    FT_Get_PS_Font_Private
+   *
+   * @description:
+   *    Retrieve the @PS_PrivateRec structure corresponding to a given
+   *    PostScript font.
+   *
+   * @input:
+   *    face ::
+   *       PostScript face handle.
+   *
+   * @output:
+   *    afont_private ::
+   *       Output private dictionary structure pointer.
+   *
+   * @return:
+   *    FreeType error code.  0~means success.
+   *
+   * @note:
+   *    The string pointers within the @PS_PrivateRec structure are owned by
+   *    the face and don't need to be freed by the caller.
+   *
+   *    If the font's format is not PostScript-based, this function returns
+   *    the `FT_Err_Invalid_Argument' error code.
+   *
+   */
+  FT_EXPORT( FT_Error )
+  FT_Get_PS_Font_Private( FT_Face     face,
+                          PS_Private  afont_private );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    T1_EncodingType                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration describing the `Encoding' entry in a Type 1         */
+  /*    dictionary.                                                        */
+  /*                                                                       */
+  typedef enum  T1_EncodingType_
+  {
+    T1_ENCODING_TYPE_NONE = 0,
+    T1_ENCODING_TYPE_ARRAY,
+    T1_ENCODING_TYPE_STANDARD,
+    T1_ENCODING_TYPE_ISOLATIN1,
+    T1_ENCODING_TYPE_EXPERT
+
+  } T1_EncodingType;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    PS_Dict_Keys                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration used in calls to @FT_Get_PS_Font_Value to identify  */
+  /*    the Type~1 dictionary entry to retrieve.                           */
+  /*                                                                       */
+  typedef enum  PS_Dict_Keys_
+  {
+    /* conventionally in the font dictionary */
+    PS_DICT_FONT_TYPE,              /* FT_Byte         */
+    PS_DICT_FONT_MATRIX,            /* FT_Fixed        */
+    PS_DICT_FONT_BBOX,              /* FT_Fixed        */
+    PS_DICT_PAINT_TYPE,             /* FT_Byte         */
+    PS_DICT_FONT_NAME,              /* FT_String*      */
+    PS_DICT_UNIQUE_ID,              /* FT_Int          */
+    PS_DICT_NUM_CHAR_STRINGS,       /* FT_Int          */
+    PS_DICT_CHAR_STRING_KEY,        /* FT_String*      */
+    PS_DICT_CHAR_STRING,            /* FT_String*      */
+    PS_DICT_ENCODING_TYPE,          /* T1_EncodingType */
+    PS_DICT_ENCODING_ENTRY,         /* FT_String*      */
+
+    /* conventionally in the font Private dictionary */
+    PS_DICT_NUM_SUBRS,              /* FT_Int     */
+    PS_DICT_SUBR,                   /* FT_String* */
+    PS_DICT_STD_HW,                 /* FT_UShort  */
+    PS_DICT_STD_VW,                 /* FT_UShort  */
+    PS_DICT_NUM_BLUE_VALUES,        /* FT_Byte    */
+    PS_DICT_BLUE_VALUE,             /* FT_Short   */
+    PS_DICT_BLUE_FUZZ,              /* FT_Int     */
+    PS_DICT_NUM_OTHER_BLUES,        /* FT_Byte    */
+    PS_DICT_OTHER_BLUE,             /* FT_Short   */
+    PS_DICT_NUM_FAMILY_BLUES,       /* FT_Byte    */
+    PS_DICT_FAMILY_BLUE,            /* FT_Short   */
+    PS_DICT_NUM_FAMILY_OTHER_BLUES, /* FT_Byte    */
+    PS_DICT_FAMILY_OTHER_BLUE,      /* FT_Short   */
+    PS_DICT_BLUE_SCALE,             /* FT_Fixed   */
+    PS_DICT_BLUE_SHIFT,             /* FT_Int     */
+    PS_DICT_NUM_STEM_SNAP_H,        /* FT_Byte    */
+    PS_DICT_STEM_SNAP_H,            /* FT_Short   */
+    PS_DICT_NUM_STEM_SNAP_V,        /* FT_Byte    */
+    PS_DICT_STEM_SNAP_V,            /* FT_Short   */
+    PS_DICT_FORCE_BOLD,             /* FT_Bool    */
+    PS_DICT_RND_STEM_UP,            /* FT_Bool    */
+    PS_DICT_MIN_FEATURE,            /* FT_Short   */
+    PS_DICT_LEN_IV,                 /* FT_Int     */
+    PS_DICT_PASSWORD,               /* FT_Long    */
+    PS_DICT_LANGUAGE_GROUP,         /* FT_Long    */
+
+    /* conventionally in the font FontInfo dictionary */
+    PS_DICT_VERSION,                /* FT_String* */
+    PS_DICT_NOTICE,                 /* FT_String* */
+    PS_DICT_FULL_NAME,              /* FT_String* */
+    PS_DICT_FAMILY_NAME,            /* FT_String* */
+    PS_DICT_WEIGHT,                 /* FT_String* */
+    PS_DICT_IS_FIXED_PITCH,         /* FT_Bool    */
+    PS_DICT_UNDERLINE_POSITION,     /* FT_Short   */
+    PS_DICT_UNDERLINE_THICKNESS,    /* FT_UShort  */
+    PS_DICT_FS_TYPE,                /* FT_UShort  */
+    PS_DICT_ITALIC_ANGLE,           /* FT_Long    */
+
+    PS_DICT_MAX = PS_DICT_ITALIC_ANGLE
+
+  } PS_Dict_Keys;
+
+
+  /************************************************************************
+   *
+   * @function:
+   *    FT_Get_PS_Font_Value
+   *
+   * @description:
+   *    Retrieve the value for the supplied key from a PostScript font.
+   *
+   * @input:
+   *    face ::
+   *       PostScript face handle.
+   *
+   *    key ::
+   *       An enumeration value representing the dictionary key to retrieve.
+   *
+   *    idx ::
+   *       For array values, this specifies the index to be returned.
+   *
+   *    value ::
+   *       A pointer to memory into which to write the value.
+   *
+   *    valen_len ::
+   *       The size, in bytes, of the memory supplied for the value.
+   *
+   * @output:
+   *    value ::
+   *       The value matching the above key, if it exists.
+   *
+   * @return:
+   *    The amount of memory (in bytes) required to hold the requested
+   *    value (if it exists, -1 otherwise).
+   *
+   * @note:
+   *    The values returned are not pointers into the internal structures of
+   *    the face, but are `fresh' copies, so that the memory containing them
+   *    belongs to the calling application.  This also enforces the
+   *    `read-only' nature of these values, i.e., this function cannot be
+   *    used to manipulate the face.
+   *
+   *    `value' is a void pointer because the values returned can be of
+   *    various types.
+   *
+   *    If either `value' is NULL or `value_len' is too small, just the
+   *    required memory size for the requested entry is returned.
+   *
+   *    The `idx' parameter is used, not only to retrieve elements of, for
+   *    example, the FontMatrix or FontBBox, but also to retrieve name keys
+   *    from the CharStrings dictionary, and the charstrings themselves.  It
+   *    is ignored for atomic values.
+   *
+   *    PS_DICT_BLUE_SCALE returns a value that is scaled up by 1000.  To
+   *    get the value as in the font stream, you need to divide by
+   *    65536000.0 (to remove the FT_Fixed scale, and the x1000 scale).
+   *
+   *    IMPORTANT: Only key/value pairs read by the FreeType interpreter can
+   *    be retrieved.  So, for example, PostScript procedures such as NP,
+   *    ND, and RD are not available.  Arbitrary keys are, obviously, not be
+   *    available either.
+   *
+   *    If the font's format is not PostScript-based, this function returns
+   *    the `FT_Err_Invalid_Argument' error code.
+   *
+   */
+  FT_EXPORT( FT_Long )
+  FT_Get_PS_Font_Value( FT_Face       face,
+                        PS_Dict_Keys  key,
+                        FT_UInt       idx,
+                        void         *value,
+                        FT_Long       value_len );
+
+  /* */
+
+FT_END_HEADER
+
+#endif /* __T1TABLES_H__ */
+
+
+/* END */
diff --git a/include/freetype/ttnameid.h b/include/freetype/ttnameid.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ttnameid.h
@@ -0,0 +1,1237 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ttnameid.h                                                             */
+/*                                                                         */
+/*    TrueType name ID definitions (specification only).                   */
+/*                                                                         */
+/*  Copyright 1996-2004, 2006-2008, 2012 by                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __TTNAMEID_H__
+#define __TTNAMEID_H__
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    truetype_tables                                                    */
+  /*                                                                       */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Possible values for the `platform' identifier code in the name        */
+  /* records of the TTF `name' table.                                      */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /***********************************************************************
+   *
+   * @enum:
+   *   TT_PLATFORM_XXX
+   *
+   * @description:
+   *   A list of valid values for the `platform_id' identifier code in
+   *   @FT_CharMapRec and @FT_SfntName structures.
+   *
+   * @values:
+   *   TT_PLATFORM_APPLE_UNICODE ::
+   *     Used by Apple to indicate a Unicode character map and/or name entry.
+   *     See @TT_APPLE_ID_XXX for corresponding `encoding_id' values.  Note
+   *     that name entries in this format are coded as big-endian UCS-2
+   *     character codes _only_.
+   *
+   *   TT_PLATFORM_MACINTOSH ::
+   *     Used by Apple to indicate a MacOS-specific charmap and/or name entry.
+   *     See @TT_MAC_ID_XXX for corresponding `encoding_id' values.  Note that
+   *     most TrueType fonts contain an Apple roman charmap to be usable on
+   *     MacOS systems (even if they contain a Microsoft charmap as well).
+   *
+   *   TT_PLATFORM_ISO ::
+   *     This value was used to specify ISO/IEC 10646 charmaps.  It is however
+   *     now deprecated.  See @TT_ISO_ID_XXX for a list of corresponding
+   *     `encoding_id' values.
+   *
+   *   TT_PLATFORM_MICROSOFT ::
+   *     Used by Microsoft to indicate Windows-specific charmaps.  See
+   *     @TT_MS_ID_XXX for a list of corresponding `encoding_id' values.
+   *     Note that most fonts contain a Unicode charmap using
+   *     (TT_PLATFORM_MICROSOFT, @TT_MS_ID_UNICODE_CS).
+   *
+   *   TT_PLATFORM_CUSTOM ::
+   *     Used to indicate application-specific charmaps.
+   *
+   *   TT_PLATFORM_ADOBE ::
+   *     This value isn't part of any font format specification, but is used
+   *     by FreeType to report Adobe-specific charmaps in an @FT_CharMapRec
+   *     structure.  See @TT_ADOBE_ID_XXX.
+   */
+
+#define TT_PLATFORM_APPLE_UNICODE  0
+#define TT_PLATFORM_MACINTOSH      1
+#define TT_PLATFORM_ISO            2 /* deprecated */
+#define TT_PLATFORM_MICROSOFT      3
+#define TT_PLATFORM_CUSTOM         4
+#define TT_PLATFORM_ADOBE          7 /* artificial */
+
+
+  /***********************************************************************
+   *
+   * @enum:
+   *   TT_APPLE_ID_XXX
+   *
+   * @description:
+   *   A list of valid values for the `encoding_id' for
+   *   @TT_PLATFORM_APPLE_UNICODE charmaps and name entries.
+   *
+   * @values:
+   *   TT_APPLE_ID_DEFAULT ::
+   *     Unicode version 1.0.
+   *
+   *   TT_APPLE_ID_UNICODE_1_1 ::
+   *     Unicode 1.1; specifies Hangul characters starting at U+34xx.
+   *
+   *   TT_APPLE_ID_ISO_10646 ::
+   *     Deprecated (identical to preceding).
+   *
+   *   TT_APPLE_ID_UNICODE_2_0 ::
+   *     Unicode 2.0 and beyond (UTF-16 BMP only).
+   *
+   *   TT_APPLE_ID_UNICODE_32 ::
+   *     Unicode 3.1 and beyond, using UTF-32.
+   *
+   *   TT_APPLE_ID_VARIANT_SELECTOR ::
+   *     From Adobe, not Apple.  Not a normal cmap.  Specifies variations
+   *     on a real cmap.
+   */
+
+#define TT_APPLE_ID_DEFAULT           0 /* Unicode 1.0 */
+#define TT_APPLE_ID_UNICODE_1_1       1 /* specify Hangul at U+34xx */
+#define TT_APPLE_ID_ISO_10646         2 /* deprecated */
+#define TT_APPLE_ID_UNICODE_2_0       3 /* or later */
+#define TT_APPLE_ID_UNICODE_32        4 /* 2.0 or later, full repertoire */
+#define TT_APPLE_ID_VARIANT_SELECTOR  5 /* variation selector data */
+
+
+  /***********************************************************************
+   *
+   * @enum:
+   *   TT_MAC_ID_XXX
+   *
+   * @description:
+   *   A list of valid values for the `encoding_id' for
+   *   @TT_PLATFORM_MACINTOSH charmaps and name entries.
+   *
+   * @values:
+   *   TT_MAC_ID_ROMAN ::
+   *   TT_MAC_ID_JAPANESE ::
+   *   TT_MAC_ID_TRADITIONAL_CHINESE ::
+   *   TT_MAC_ID_KOREAN ::
+   *   TT_MAC_ID_ARABIC ::
+   *   TT_MAC_ID_HEBREW ::
+   *   TT_MAC_ID_GREEK ::
+   *   TT_MAC_ID_RUSSIAN ::
+   *   TT_MAC_ID_RSYMBOL ::
+   *   TT_MAC_ID_DEVANAGARI ::
+   *   TT_MAC_ID_GURMUKHI ::
+   *   TT_MAC_ID_GUJARATI ::
+   *   TT_MAC_ID_ORIYA ::
+   *   TT_MAC_ID_BENGALI ::
+   *   TT_MAC_ID_TAMIL ::
+   *   TT_MAC_ID_TELUGU ::
+   *   TT_MAC_ID_KANNADA ::
+   *   TT_MAC_ID_MALAYALAM ::
+   *   TT_MAC_ID_SINHALESE ::
+   *   TT_MAC_ID_BURMESE ::
+   *   TT_MAC_ID_KHMER ::
+   *   TT_MAC_ID_THAI ::
+   *   TT_MAC_ID_LAOTIAN ::
+   *   TT_MAC_ID_GEORGIAN ::
+   *   TT_MAC_ID_ARMENIAN ::
+   *   TT_MAC_ID_MALDIVIAN ::
+   *   TT_MAC_ID_SIMPLIFIED_CHINESE ::
+   *   TT_MAC_ID_TIBETAN ::
+   *   TT_MAC_ID_MONGOLIAN ::
+   *   TT_MAC_ID_GEEZ ::
+   *   TT_MAC_ID_SLAVIC ::
+   *   TT_MAC_ID_VIETNAMESE ::
+   *   TT_MAC_ID_SINDHI ::
+   *   TT_MAC_ID_UNINTERP ::
+   */
+
+#define TT_MAC_ID_ROMAN                 0
+#define TT_MAC_ID_JAPANESE              1
+#define TT_MAC_ID_TRADITIONAL_CHINESE   2
+#define TT_MAC_ID_KOREAN                3
+#define TT_MAC_ID_ARABIC                4
+#define TT_MAC_ID_HEBREW                5
+#define TT_MAC_ID_GREEK                 6
+#define TT_MAC_ID_RUSSIAN               7
+#define TT_MAC_ID_RSYMBOL               8
+#define TT_MAC_ID_DEVANAGARI            9
+#define TT_MAC_ID_GURMUKHI             10
+#define TT_MAC_ID_GUJARATI             11
+#define TT_MAC_ID_ORIYA                12
+#define TT_MAC_ID_BENGALI              13
+#define TT_MAC_ID_TAMIL                14
+#define TT_MAC_ID_TELUGU               15
+#define TT_MAC_ID_KANNADA              16
+#define TT_MAC_ID_MALAYALAM            17
+#define TT_MAC_ID_SINHALESE            18
+#define TT_MAC_ID_BURMESE              19
+#define TT_MAC_ID_KHMER                20
+#define TT_MAC_ID_THAI                 21
+#define TT_MAC_ID_LAOTIAN              22
+#define TT_MAC_ID_GEORGIAN             23
+#define TT_MAC_ID_ARMENIAN             24
+#define TT_MAC_ID_MALDIVIAN            25
+#define TT_MAC_ID_SIMPLIFIED_CHINESE   25
+#define TT_MAC_ID_TIBETAN              26
+#define TT_MAC_ID_MONGOLIAN            27
+#define TT_MAC_ID_GEEZ                 28
+#define TT_MAC_ID_SLAVIC               29
+#define TT_MAC_ID_VIETNAMESE           30
+#define TT_MAC_ID_SINDHI               31
+#define TT_MAC_ID_UNINTERP             32
+
+
+  /***********************************************************************
+   *
+   * @enum:
+   *   TT_ISO_ID_XXX
+   *
+   * @description:
+   *   A list of valid values for the `encoding_id' for
+   *   @TT_PLATFORM_ISO charmaps and name entries.
+   *
+   *   Their use is now deprecated.
+   *
+   * @values:
+   *   TT_ISO_ID_7BIT_ASCII ::
+   *     ASCII.
+   *   TT_ISO_ID_10646 ::
+   *     ISO/10646.
+   *   TT_ISO_ID_8859_1 ::
+   *     Also known as Latin-1.
+   */
+
+#define TT_ISO_ID_7BIT_ASCII  0
+#define TT_ISO_ID_10646       1
+#define TT_ISO_ID_8859_1      2
+
+
+  /***********************************************************************
+   *
+   * @enum:
+   *   TT_MS_ID_XXX
+   *
+   * @description:
+   *   A list of valid values for the `encoding_id' for
+   *   @TT_PLATFORM_MICROSOFT charmaps and name entries.
+   *
+   * @values:
+   *   TT_MS_ID_SYMBOL_CS ::
+   *     Corresponds to Microsoft symbol encoding. See
+   *     @FT_ENCODING_MS_SYMBOL.
+   *
+   *   TT_MS_ID_UNICODE_CS ::
+   *     Corresponds to a Microsoft WGL4 charmap, matching Unicode.  See
+   *     @FT_ENCODING_UNICODE.
+   *
+   *   TT_MS_ID_SJIS ::
+   *     Corresponds to SJIS Japanese encoding.  See @FT_ENCODING_SJIS.
+   *
+   *   TT_MS_ID_GB2312 ::
+   *     Corresponds to Simplified Chinese as used in Mainland China.  See
+   *     @FT_ENCODING_GB2312.
+   *
+   *   TT_MS_ID_BIG_5 ::
+   *     Corresponds to Traditional Chinese as used in Taiwan and Hong Kong.
+   *     See @FT_ENCODING_BIG5.
+   *
+   *   TT_MS_ID_WANSUNG ::
+   *     Corresponds to Korean Wansung encoding.  See @FT_ENCODING_WANSUNG.
+   *
+   *   TT_MS_ID_JOHAB ::
+   *     Corresponds to Johab encoding.  See @FT_ENCODING_JOHAB.
+   *
+   *   TT_MS_ID_UCS_4 ::
+   *     Corresponds to UCS-4 or UTF-32 charmaps.  This has been added to
+   *     the OpenType specification version 1.4 (mid-2001.)
+   */
+
+#define TT_MS_ID_SYMBOL_CS    0
+#define TT_MS_ID_UNICODE_CS   1
+#define TT_MS_ID_SJIS         2
+#define TT_MS_ID_GB2312       3
+#define TT_MS_ID_BIG_5        4
+#define TT_MS_ID_WANSUNG      5
+#define TT_MS_ID_JOHAB        6
+#define TT_MS_ID_UCS_4       10
+
+
+  /***********************************************************************
+   *
+   * @enum:
+   *   TT_ADOBE_ID_XXX
+   *
+   * @description:
+   *   A list of valid values for the `encoding_id' for
+   *   @TT_PLATFORM_ADOBE charmaps.  This is a FreeType-specific extension!
+   *
+   * @values:
+   *   TT_ADOBE_ID_STANDARD ::
+   *     Adobe standard encoding.
+   *   TT_ADOBE_ID_EXPERT ::
+   *     Adobe expert encoding.
+   *   TT_ADOBE_ID_CUSTOM ::
+   *     Adobe custom encoding.
+   *   TT_ADOBE_ID_LATIN_1 ::
+   *     Adobe Latin~1 encoding.
+   */
+
+#define TT_ADOBE_ID_STANDARD  0
+#define TT_ADOBE_ID_EXPERT    1
+#define TT_ADOBE_ID_CUSTOM    2
+#define TT_ADOBE_ID_LATIN_1   3
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Possible values of the language identifier field in the name records  */
+  /* of the TTF `name' table if the `platform' identifier code is          */
+  /* TT_PLATFORM_MACINTOSH.  These values are also used as return values   */
+  /* for function @FT_Get_CMap_Language_ID.                                */
+  /*                                                                       */
+  /* The canonical source for the Apple assigned Language ID's is at       */
+  /*                                                                       */
+  /*   https://developer.apple.com/fonts/TTRefMan/RM06/Chap6name.html      */
+  /*                                                                       */
+#define TT_MAC_LANGID_ENGLISH                       0
+#define TT_MAC_LANGID_FRENCH                        1
+#define TT_MAC_LANGID_GERMAN                        2
+#define TT_MAC_LANGID_ITALIAN                       3
+#define TT_MAC_LANGID_DUTCH                         4
+#define TT_MAC_LANGID_SWEDISH                       5
+#define TT_MAC_LANGID_SPANISH                       6
+#define TT_MAC_LANGID_DANISH                        7
+#define TT_MAC_LANGID_PORTUGUESE                    8
+#define TT_MAC_LANGID_NORWEGIAN                     9
+#define TT_MAC_LANGID_HEBREW                       10
+#define TT_MAC_LANGID_JAPANESE                     11
+#define TT_MAC_LANGID_ARABIC                       12
+#define TT_MAC_LANGID_FINNISH                      13
+#define TT_MAC_LANGID_GREEK                        14
+#define TT_MAC_LANGID_ICELANDIC                    15
+#define TT_MAC_LANGID_MALTESE                      16
+#define TT_MAC_LANGID_TURKISH                      17
+#define TT_MAC_LANGID_CROATIAN                     18
+#define TT_MAC_LANGID_CHINESE_TRADITIONAL          19
+#define TT_MAC_LANGID_URDU                         20
+#define TT_MAC_LANGID_HINDI                        21
+#define TT_MAC_LANGID_THAI                         22
+#define TT_MAC_LANGID_KOREAN                       23
+#define TT_MAC_LANGID_LITHUANIAN                   24
+#define TT_MAC_LANGID_POLISH                       25
+#define TT_MAC_LANGID_HUNGARIAN                    26
+#define TT_MAC_LANGID_ESTONIAN                     27
+#define TT_MAC_LANGID_LETTISH                      28
+#define TT_MAC_LANGID_SAAMISK                      29
+#define TT_MAC_LANGID_FAEROESE                     30
+#define TT_MAC_LANGID_FARSI                        31
+#define TT_MAC_LANGID_RUSSIAN                      32
+#define TT_MAC_LANGID_CHINESE_SIMPLIFIED           33
+#define TT_MAC_LANGID_FLEMISH                      34
+#define TT_MAC_LANGID_IRISH                        35
+#define TT_MAC_LANGID_ALBANIAN                     36
+#define TT_MAC_LANGID_ROMANIAN                     37
+#define TT_MAC_LANGID_CZECH                        38
+#define TT_MAC_LANGID_SLOVAK                       39
+#define TT_MAC_LANGID_SLOVENIAN                    40
+#define TT_MAC_LANGID_YIDDISH                      41
+#define TT_MAC_LANGID_SERBIAN                      42
+#define TT_MAC_LANGID_MACEDONIAN                   43
+#define TT_MAC_LANGID_BULGARIAN                    44
+#define TT_MAC_LANGID_UKRAINIAN                    45
+#define TT_MAC_LANGID_BYELORUSSIAN                 46
+#define TT_MAC_LANGID_UZBEK                        47
+#define TT_MAC_LANGID_KAZAKH                       48
+#define TT_MAC_LANGID_AZERBAIJANI                  49
+#define TT_MAC_LANGID_AZERBAIJANI_CYRILLIC_SCRIPT  49
+#define TT_MAC_LANGID_AZERBAIJANI_ARABIC_SCRIPT    50
+#define TT_MAC_LANGID_ARMENIAN                     51
+#define TT_MAC_LANGID_GEORGIAN                     52
+#define TT_MAC_LANGID_MOLDAVIAN                    53
+#define TT_MAC_LANGID_KIRGHIZ                      54
+#define TT_MAC_LANGID_TAJIKI                       55
+#define TT_MAC_LANGID_TURKMEN                      56
+#define TT_MAC_LANGID_MONGOLIAN                    57
+#define TT_MAC_LANGID_MONGOLIAN_MONGOLIAN_SCRIPT   57
+#define TT_MAC_LANGID_MONGOLIAN_CYRILLIC_SCRIPT    58
+#define TT_MAC_LANGID_PASHTO                       59
+#define TT_MAC_LANGID_KURDISH                      60
+#define TT_MAC_LANGID_KASHMIRI                     61
+#define TT_MAC_LANGID_SINDHI                       62
+#define TT_MAC_LANGID_TIBETAN                      63
+#define TT_MAC_LANGID_NEPALI                       64
+#define TT_MAC_LANGID_SANSKRIT                     65
+#define TT_MAC_LANGID_MARATHI                      66
+#define TT_MAC_LANGID_BENGALI                      67
+#define TT_MAC_LANGID_ASSAMESE                     68
+#define TT_MAC_LANGID_GUJARATI                     69
+#define TT_MAC_LANGID_PUNJABI                      70
+#define TT_MAC_LANGID_ORIYA                        71
+#define TT_MAC_LANGID_MALAYALAM                    72
+#define TT_MAC_LANGID_KANNADA                      73
+#define TT_MAC_LANGID_TAMIL                        74
+#define TT_MAC_LANGID_TELUGU                       75
+#define TT_MAC_LANGID_SINHALESE                    76
+#define TT_MAC_LANGID_BURMESE                      77
+#define TT_MAC_LANGID_KHMER                        78
+#define TT_MAC_LANGID_LAO                          79
+#define TT_MAC_LANGID_VIETNAMESE                   80
+#define TT_MAC_LANGID_INDONESIAN                   81
+#define TT_MAC_LANGID_TAGALOG                      82
+#define TT_MAC_LANGID_MALAY_ROMAN_SCRIPT           83
+#define TT_MAC_LANGID_MALAY_ARABIC_SCRIPT          84
+#define TT_MAC_LANGID_AMHARIC                      85
+#define TT_MAC_LANGID_TIGRINYA                     86
+#define TT_MAC_LANGID_GALLA                        87
+#define TT_MAC_LANGID_SOMALI                       88
+#define TT_MAC_LANGID_SWAHILI                      89
+#define TT_MAC_LANGID_RUANDA                       90
+#define TT_MAC_LANGID_RUNDI                        91
+#define TT_MAC_LANGID_CHEWA                        92
+#define TT_MAC_LANGID_MALAGASY                     93
+#define TT_MAC_LANGID_ESPERANTO                    94
+#define TT_MAC_LANGID_WELSH                       128
+#define TT_MAC_LANGID_BASQUE                      129
+#define TT_MAC_LANGID_CATALAN                     130
+#define TT_MAC_LANGID_LATIN                       131
+#define TT_MAC_LANGID_QUECHUA                     132
+#define TT_MAC_LANGID_GUARANI                     133
+#define TT_MAC_LANGID_AYMARA                      134
+#define TT_MAC_LANGID_TATAR                       135
+#define TT_MAC_LANGID_UIGHUR                      136
+#define TT_MAC_LANGID_DZONGKHA                    137
+#define TT_MAC_LANGID_JAVANESE                    138
+#define TT_MAC_LANGID_SUNDANESE                   139
+
+
+#if 0  /* these seem to be errors that have been dropped */
+
+#define TT_MAC_LANGID_SCOTTISH_GAELIC             140
+#define TT_MAC_LANGID_IRISH_GAELIC                141
+
+#endif
+
+
+  /* The following codes are new as of 2000-03-10 */
+#define TT_MAC_LANGID_GALICIAN                    140
+#define TT_MAC_LANGID_AFRIKAANS                   141
+#define TT_MAC_LANGID_BRETON                      142
+#define TT_MAC_LANGID_INUKTITUT                   143
+#define TT_MAC_LANGID_SCOTTISH_GAELIC             144
+#define TT_MAC_LANGID_MANX_GAELIC                 145
+#define TT_MAC_LANGID_IRISH_GAELIC                146
+#define TT_MAC_LANGID_TONGAN                      147
+#define TT_MAC_LANGID_GREEK_POLYTONIC             148
+#define TT_MAC_LANGID_GREELANDIC                  149
+#define TT_MAC_LANGID_AZERBAIJANI_ROMAN_SCRIPT    150
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Possible values of the language identifier field in the name records  */
+  /* of the TTF `name' table if the `platform' identifier code is          */
+  /* TT_PLATFORM_MICROSOFT.                                                */
+  /*                                                                       */
+  /* The canonical source for the MS assigned LCIDs is                     */
+  /*                                                                       */
+  /*   http://www.microsoft.com/globaldev/reference/lcid-all.mspx          */
+  /*                                                                       */
+
+#define TT_MS_LANGID_ARABIC_GENERAL                    0x0001
+#define TT_MS_LANGID_ARABIC_SAUDI_ARABIA               0x0401
+#define TT_MS_LANGID_ARABIC_IRAQ                       0x0801
+#define TT_MS_LANGID_ARABIC_EGYPT                      0x0c01
+#define TT_MS_LANGID_ARABIC_LIBYA                      0x1001
+#define TT_MS_LANGID_ARABIC_ALGERIA                    0x1401
+#define TT_MS_LANGID_ARABIC_MOROCCO                    0x1801
+#define TT_MS_LANGID_ARABIC_TUNISIA                    0x1c01
+#define TT_MS_LANGID_ARABIC_OMAN                       0x2001
+#define TT_MS_LANGID_ARABIC_YEMEN                      0x2401
+#define TT_MS_LANGID_ARABIC_SYRIA                      0x2801
+#define TT_MS_LANGID_ARABIC_JORDAN                     0x2c01
+#define TT_MS_LANGID_ARABIC_LEBANON                    0x3001
+#define TT_MS_LANGID_ARABIC_KUWAIT                     0x3401
+#define TT_MS_LANGID_ARABIC_UAE                        0x3801
+#define TT_MS_LANGID_ARABIC_BAHRAIN                    0x3c01
+#define TT_MS_LANGID_ARABIC_QATAR                      0x4001
+#define TT_MS_LANGID_BULGARIAN_BULGARIA                0x0402
+#define TT_MS_LANGID_CATALAN_SPAIN                     0x0403
+#define TT_MS_LANGID_CHINESE_GENERAL                   0x0004
+#define TT_MS_LANGID_CHINESE_TAIWAN                    0x0404
+#define TT_MS_LANGID_CHINESE_PRC                       0x0804
+#define TT_MS_LANGID_CHINESE_HONG_KONG                 0x0c04
+#define TT_MS_LANGID_CHINESE_SINGAPORE                 0x1004
+
+#if 1  /* this looks like the correct value */
+#define TT_MS_LANGID_CHINESE_MACAU                     0x1404
+#else  /* but beware, Microsoft may change its mind...
+          the most recent Word reference has the following: */
+#define TT_MS_LANGID_CHINESE_MACAU  TT_MS_LANGID_CHINESE_HONG_KONG
+#endif
+
+#if 0  /* used only with .NET `cultures'; commented out */
+#define TT_MS_LANGID_CHINESE_TRADITIONAL               0x7C04
+#endif
+
+#define TT_MS_LANGID_CZECH_CZECH_REPUBLIC              0x0405
+#define TT_MS_LANGID_DANISH_DENMARK                    0x0406
+#define TT_MS_LANGID_GERMAN_GERMANY                    0x0407
+#define TT_MS_LANGID_GERMAN_SWITZERLAND                0x0807
+#define TT_MS_LANGID_GERMAN_AUSTRIA                    0x0c07
+#define TT_MS_LANGID_GERMAN_LUXEMBOURG                 0x1007
+#define TT_MS_LANGID_GERMAN_LIECHTENSTEI               0x1407
+#define TT_MS_LANGID_GREEK_GREECE                      0x0408
+
+  /* don't ask what this one means... It is commented out currently. */
+#if 0
+#define TT_MS_LANGID_GREEK_GREECE2                     0x2008
+#endif
+
+#define TT_MS_LANGID_ENGLISH_GENERAL                   0x0009
+#define TT_MS_LANGID_ENGLISH_UNITED_STATES             0x0409
+#define TT_MS_LANGID_ENGLISH_UNITED_KINGDOM            0x0809
+#define TT_MS_LANGID_ENGLISH_AUSTRALIA                 0x0c09
+#define TT_MS_LANGID_ENGLISH_CANADA                    0x1009
+#define TT_MS_LANGID_ENGLISH_NEW_ZEALAND               0x1409
+#define TT_MS_LANGID_ENGLISH_IRELAND                   0x1809
+#define TT_MS_LANGID_ENGLISH_SOUTH_AFRICA              0x1c09
+#define TT_MS_LANGID_ENGLISH_JAMAICA                   0x2009
+#define TT_MS_LANGID_ENGLISH_CARIBBEAN                 0x2409
+#define TT_MS_LANGID_ENGLISH_BELIZE                    0x2809
+#define TT_MS_LANGID_ENGLISH_TRINIDAD                  0x2c09
+#define TT_MS_LANGID_ENGLISH_ZIMBABWE                  0x3009
+#define TT_MS_LANGID_ENGLISH_PHILIPPINES               0x3409
+#define TT_MS_LANGID_ENGLISH_INDONESIA                 0x3809
+#define TT_MS_LANGID_ENGLISH_HONG_KONG                 0x3c09
+#define TT_MS_LANGID_ENGLISH_INDIA                     0x4009
+#define TT_MS_LANGID_ENGLISH_MALAYSIA                  0x4409
+#define TT_MS_LANGID_ENGLISH_SINGAPORE                 0x4809
+#define TT_MS_LANGID_SPANISH_SPAIN_TRADITIONAL_SORT    0x040a
+#define TT_MS_LANGID_SPANISH_MEXICO                    0x080a
+#define TT_MS_LANGID_SPANISH_SPAIN_INTERNATIONAL_SORT  0x0c0a
+#define TT_MS_LANGID_SPANISH_GUATEMALA                 0x100a
+#define TT_MS_LANGID_SPANISH_COSTA_RICA                0x140a
+#define TT_MS_LANGID_SPANISH_PANAMA                    0x180a
+#define TT_MS_LANGID_SPANISH_DOMINICAN_REPUBLIC        0x1c0a
+#define TT_MS_LANGID_SPANISH_VENEZUELA                 0x200a
+#define TT_MS_LANGID_SPANISH_COLOMBIA                  0x240a
+#define TT_MS_LANGID_SPANISH_PERU                      0x280a
+#define TT_MS_LANGID_SPANISH_ARGENTINA                 0x2c0a
+#define TT_MS_LANGID_SPANISH_ECUADOR                   0x300a
+#define TT_MS_LANGID_SPANISH_CHILE                     0x340a
+#define TT_MS_LANGID_SPANISH_URUGUAY                   0x380a
+#define TT_MS_LANGID_SPANISH_PARAGUAY                  0x3c0a
+#define TT_MS_LANGID_SPANISH_BOLIVIA                   0x400a
+#define TT_MS_LANGID_SPANISH_EL_SALVADOR               0x440a
+#define TT_MS_LANGID_SPANISH_HONDURAS                  0x480a
+#define TT_MS_LANGID_SPANISH_NICARAGUA                 0x4c0a
+#define TT_MS_LANGID_SPANISH_PUERTO_RICO               0x500a
+#define TT_MS_LANGID_SPANISH_UNITED_STATES             0x540a
+  /* The following ID blatantly violate MS specs by using a */
+  /* sublanguage > 0x1F.                                    */
+#define TT_MS_LANGID_SPANISH_LATIN_AMERICA             0xE40aU
+#define TT_MS_LANGID_FINNISH_FINLAND                   0x040b
+#define TT_MS_LANGID_FRENCH_FRANCE                     0x040c
+#define TT_MS_LANGID_FRENCH_BELGIUM                    0x080c
+#define TT_MS_LANGID_FRENCH_CANADA                     0x0c0c
+#define TT_MS_LANGID_FRENCH_SWITZERLAND                0x100c
+#define TT_MS_LANGID_FRENCH_LUXEMBOURG                 0x140c
+#define TT_MS_LANGID_FRENCH_MONACO                     0x180c
+#define TT_MS_LANGID_FRENCH_WEST_INDIES                0x1c0c
+#define TT_MS_LANGID_FRENCH_REUNION                    0x200c
+#define TT_MS_LANGID_FRENCH_CONGO                      0x240c
+  /* which was formerly: */
+#define TT_MS_LANGID_FRENCH_ZAIRE  TT_MS_LANGID_FRENCH_CONGO
+#define TT_MS_LANGID_FRENCH_SENEGAL                    0x280c
+#define TT_MS_LANGID_FRENCH_CAMEROON                   0x2c0c
+#define TT_MS_LANGID_FRENCH_COTE_D_IVOIRE              0x300c
+#define TT_MS_LANGID_FRENCH_MALI                       0x340c
+#define TT_MS_LANGID_FRENCH_MOROCCO                    0x380c
+#define TT_MS_LANGID_FRENCH_HAITI                      0x3c0c
+  /* and another violation of the spec (see 0xE40aU) */
+#define TT_MS_LANGID_FRENCH_NORTH_AFRICA               0xE40cU
+#define TT_MS_LANGID_HEBREW_ISRAEL                     0x040d
+#define TT_MS_LANGID_HUNGARIAN_HUNGARY                 0x040e
+#define TT_MS_LANGID_ICELANDIC_ICELAND                 0x040f
+#define TT_MS_LANGID_ITALIAN_ITALY                     0x0410
+#define TT_MS_LANGID_ITALIAN_SWITZERLAND               0x0810
+#define TT_MS_LANGID_JAPANESE_JAPAN                    0x0411
+#define TT_MS_LANGID_KOREAN_EXTENDED_WANSUNG_KOREA     0x0412
+#define TT_MS_LANGID_KOREAN_JOHAB_KOREA                0x0812
+#define TT_MS_LANGID_DUTCH_NETHERLANDS                 0x0413
+#define TT_MS_LANGID_DUTCH_BELGIUM                     0x0813
+#define TT_MS_LANGID_NORWEGIAN_NORWAY_BOKMAL           0x0414
+#define TT_MS_LANGID_NORWEGIAN_NORWAY_NYNORSK          0x0814
+#define TT_MS_LANGID_POLISH_POLAND                     0x0415
+#define TT_MS_LANGID_PORTUGUESE_BRAZIL                 0x0416
+#define TT_MS_LANGID_PORTUGUESE_PORTUGAL               0x0816
+#define TT_MS_LANGID_RHAETO_ROMANIC_SWITZERLAND        0x0417
+#define TT_MS_LANGID_ROMANIAN_ROMANIA                  0x0418
+#define TT_MS_LANGID_MOLDAVIAN_MOLDAVIA                0x0818
+#define TT_MS_LANGID_RUSSIAN_RUSSIA                    0x0419
+#define TT_MS_LANGID_RUSSIAN_MOLDAVIA                  0x0819
+#define TT_MS_LANGID_CROATIAN_CROATIA                  0x041a
+#define TT_MS_LANGID_SERBIAN_SERBIA_LATIN              0x081a
+#define TT_MS_LANGID_SERBIAN_SERBIA_CYRILLIC           0x0c1a
+
+#if 0  /* this used to be this value, but it looks like we were wrong */
+#define TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA        0x101a
+#else  /* current sources say */
+#define TT_MS_LANGID_CROATIAN_BOSNIA_HERZEGOVINA       0x101a
+#define TT_MS_LANGID_BOSNIAN_BOSNIA_HERZEGOVINA        0x141a
+       /* and XPsp2 Platform SDK added (2004-07-26) */
+       /* Names are shortened to be significant within 40 chars. */
+#define TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_LATIN         0x181a
+#define TT_MS_LANGID_SERBIAN_BOSNIA_HERZ_CYRILLIC      0x181a
+#endif
+
+#define TT_MS_LANGID_SLOVAK_SLOVAKIA                   0x041b
+#define TT_MS_LANGID_ALBANIAN_ALBANIA                  0x041c
+#define TT_MS_LANGID_SWEDISH_SWEDEN                    0x041d
+#define TT_MS_LANGID_SWEDISH_FINLAND                   0x081d
+#define TT_MS_LANGID_THAI_THAILAND                     0x041e
+#define TT_MS_LANGID_TURKISH_TURKEY                    0x041f
+#define TT_MS_LANGID_URDU_PAKISTAN                     0x0420
+#define TT_MS_LANGID_URDU_INDIA                        0x0820
+#define TT_MS_LANGID_INDONESIAN_INDONESIA              0x0421
+#define TT_MS_LANGID_UKRAINIAN_UKRAINE                 0x0422
+#define TT_MS_LANGID_BELARUSIAN_BELARUS                0x0423
+#define TT_MS_LANGID_SLOVENE_SLOVENIA                  0x0424
+#define TT_MS_LANGID_ESTONIAN_ESTONIA                  0x0425
+#define TT_MS_LANGID_LATVIAN_LATVIA                    0x0426
+#define TT_MS_LANGID_LITHUANIAN_LITHUANIA              0x0427
+#define TT_MS_LANGID_CLASSIC_LITHUANIAN_LITHUANIA      0x0827
+#define TT_MS_LANGID_TAJIK_TAJIKISTAN                  0x0428
+#define TT_MS_LANGID_FARSI_IRAN                        0x0429
+#define TT_MS_LANGID_VIETNAMESE_VIET_NAM               0x042a
+#define TT_MS_LANGID_ARMENIAN_ARMENIA                  0x042b
+#define TT_MS_LANGID_AZERI_AZERBAIJAN_LATIN            0x042c
+#define TT_MS_LANGID_AZERI_AZERBAIJAN_CYRILLIC         0x082c
+#define TT_MS_LANGID_BASQUE_SPAIN                      0x042d
+#define TT_MS_LANGID_SORBIAN_GERMANY                   0x042e
+#define TT_MS_LANGID_MACEDONIAN_MACEDONIA              0x042f
+#define TT_MS_LANGID_SUTU_SOUTH_AFRICA                 0x0430
+#define TT_MS_LANGID_TSONGA_SOUTH_AFRICA               0x0431
+#define TT_MS_LANGID_TSWANA_SOUTH_AFRICA               0x0432
+#define TT_MS_LANGID_VENDA_SOUTH_AFRICA                0x0433
+#define TT_MS_LANGID_XHOSA_SOUTH_AFRICA                0x0434
+#define TT_MS_LANGID_ZULU_SOUTH_AFRICA                 0x0435
+#define TT_MS_LANGID_AFRIKAANS_SOUTH_AFRICA            0x0436
+#define TT_MS_LANGID_GEORGIAN_GEORGIA                  0x0437
+#define TT_MS_LANGID_FAEROESE_FAEROE_ISLANDS           0x0438
+#define TT_MS_LANGID_HINDI_INDIA                       0x0439
+#define TT_MS_LANGID_MALTESE_MALTA                     0x043a
+  /* Added by XPsp2 Platform SDK (2004-07-26) */
+#define TT_MS_LANGID_SAMI_NORTHERN_NORWAY              0x043b
+#define TT_MS_LANGID_SAMI_NORTHERN_SWEDEN              0x083b
+#define TT_MS_LANGID_SAMI_NORTHERN_FINLAND             0x0C3b
+#define TT_MS_LANGID_SAMI_LULE_NORWAY                  0x103b
+#define TT_MS_LANGID_SAMI_LULE_SWEDEN                  0x143b
+#define TT_MS_LANGID_SAMI_SOUTHERN_NORWAY              0x183b
+#define TT_MS_LANGID_SAMI_SOUTHERN_SWEDEN              0x1C3b
+#define TT_MS_LANGID_SAMI_SKOLT_FINLAND                0x203b
+#define TT_MS_LANGID_SAMI_INARI_FINLAND                0x243b
+  /* ... and we also keep our old identifier... */
+#define TT_MS_LANGID_SAAMI_LAPONIA                     0x043b
+
+#if 0 /* this seems to be a previous inversion */
+#define TT_MS_LANGID_IRISH_GAELIC_IRELAND              0x043c
+#define TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM    0x083c
+#else
+#define TT_MS_LANGID_SCOTTISH_GAELIC_UNITED_KINGDOM    0x083c
+#define TT_MS_LANGID_IRISH_GAELIC_IRELAND              0x043c
+#endif
+
+#define TT_MS_LANGID_YIDDISH_GERMANY                   0x043d
+#define TT_MS_LANGID_MALAY_MALAYSIA                    0x043e
+#define TT_MS_LANGID_MALAY_BRUNEI_DARUSSALAM           0x083e
+#define TT_MS_LANGID_KAZAK_KAZAKSTAN                   0x043f
+#define TT_MS_LANGID_KIRGHIZ_KIRGHIZSTAN /* Cyrillic*/ 0x0440
+  /* alias declared in Windows 2000 */
+#define TT_MS_LANGID_KIRGHIZ_KIRGHIZ_REPUBLIC \
+          TT_MS_LANGID_KIRGHIZ_KIRGHIZSTAN
+
+#define TT_MS_LANGID_SWAHILI_KENYA                     0x0441
+#define TT_MS_LANGID_TURKMEN_TURKMENISTAN              0x0442
+#define TT_MS_LANGID_UZBEK_UZBEKISTAN_LATIN            0x0443
+#define TT_MS_LANGID_UZBEK_UZBEKISTAN_CYRILLIC         0x0843
+#define TT_MS_LANGID_TATAR_TATARSTAN                   0x0444
+#define TT_MS_LANGID_BENGALI_INDIA                     0x0445
+#define TT_MS_LANGID_BENGALI_BANGLADESH                0x0845
+#define TT_MS_LANGID_PUNJABI_INDIA                     0x0446
+#define TT_MS_LANGID_PUNJABI_ARABIC_PAKISTAN           0x0846
+#define TT_MS_LANGID_GUJARATI_INDIA                    0x0447
+#define TT_MS_LANGID_ORIYA_INDIA                       0x0448
+#define TT_MS_LANGID_TAMIL_INDIA                       0x0449
+#define TT_MS_LANGID_TELUGU_INDIA                      0x044a
+#define TT_MS_LANGID_KANNADA_INDIA                     0x044b
+#define TT_MS_LANGID_MALAYALAM_INDIA                   0x044c
+#define TT_MS_LANGID_ASSAMESE_INDIA                    0x044d
+#define TT_MS_LANGID_MARATHI_INDIA                     0x044e
+#define TT_MS_LANGID_SANSKRIT_INDIA                    0x044f
+#define TT_MS_LANGID_MONGOLIAN_MONGOLIA /* Cyrillic */ 0x0450
+#define TT_MS_LANGID_MONGOLIAN_MONGOLIA_MONGOLIAN      0x0850
+#define TT_MS_LANGID_TIBETAN_CHINA                     0x0451
+  /* Don't use the next constant!  It has            */
+  /*   (1) the wrong spelling (Dzonghka)             */
+  /*   (2) Microsoft doesn't officially define it -- */
+  /*       at least it is not in the List of Local   */
+  /*       ID Values.                                */
+  /*   (3) Dzongkha is not the same language as      */
+  /*       Tibetan, so merging it is wrong anyway.   */
+  /*                                                 */
+  /* TT_MS_LANGID_TIBETAN_BHUTAN is correct, BTW.    */
+#define TT_MS_LANGID_DZONGHKA_BHUTAN                   0x0851
+
+#if 0
+  /* the following used to be defined */
+#define TT_MS_LANGID_TIBETAN_BHUTAN                    0x0451
+  /* ... but it was changed; */
+#else
+  /* So we will continue to #define it, but with the correct value */
+#define TT_MS_LANGID_TIBETAN_BHUTAN   TT_MS_LANGID_DZONGHKA_BHUTAN
+#endif
+
+#define TT_MS_LANGID_WELSH_WALES                       0x0452
+#define TT_MS_LANGID_KHMER_CAMBODIA                    0x0453
+#define TT_MS_LANGID_LAO_LAOS                          0x0454
+#define TT_MS_LANGID_BURMESE_MYANMAR                   0x0455
+#define TT_MS_LANGID_GALICIAN_SPAIN                    0x0456
+#define TT_MS_LANGID_KONKANI_INDIA                     0x0457
+#define TT_MS_LANGID_MANIPURI_INDIA  /* Bengali */     0x0458
+#define TT_MS_LANGID_SINDHI_INDIA /* Arabic */         0x0459
+#define TT_MS_LANGID_SINDHI_PAKISTAN                   0x0859
+  /* Missing a LCID for Sindhi in Devanagari script */
+#define TT_MS_LANGID_SYRIAC_SYRIA                      0x045a
+#define TT_MS_LANGID_SINHALESE_SRI_LANKA               0x045b
+#define TT_MS_LANGID_CHEROKEE_UNITED_STATES            0x045c
+#define TT_MS_LANGID_INUKTITUT_CANADA                  0x045d
+#define TT_MS_LANGID_AMHARIC_ETHIOPIA                  0x045e
+#define TT_MS_LANGID_TAMAZIGHT_MOROCCO /* Arabic */    0x045f
+#define TT_MS_LANGID_TAMAZIGHT_MOROCCO_LATIN           0x085f
+  /* Missing a LCID for Tifinagh script */
+#define TT_MS_LANGID_KASHMIRI_PAKISTAN /* Arabic */    0x0460
+  /* Spelled this way by XPsp2 Platform SDK (2004-07-26) */
+  /* script is yet unclear... might be Arabic, Nagari or Sharada */
+#define TT_MS_LANGID_KASHMIRI_SASIA                    0x0860
+  /* ... and aliased (by MS) for compatibility reasons. */
+#define TT_MS_LANGID_KASHMIRI_INDIA TT_MS_LANGID_KASHMIRI_SASIA
+#define TT_MS_LANGID_NEPALI_NEPAL                      0x0461
+#define TT_MS_LANGID_NEPALI_INDIA                      0x0861
+#define TT_MS_LANGID_FRISIAN_NETHERLANDS               0x0462
+#define TT_MS_LANGID_PASHTO_AFGHANISTAN                0x0463
+#define TT_MS_LANGID_FILIPINO_PHILIPPINES              0x0464
+#define TT_MS_LANGID_DHIVEHI_MALDIVES                  0x0465
+  /* alias declared in Windows 2000 */
+#define TT_MS_LANGID_DIVEHI_MALDIVES  TT_MS_LANGID_DHIVEHI_MALDIVES
+#define TT_MS_LANGID_EDO_NIGERIA                       0x0466
+#define TT_MS_LANGID_FULFULDE_NIGERIA                  0x0467
+#define TT_MS_LANGID_HAUSA_NIGERIA                     0x0468
+#define TT_MS_LANGID_IBIBIO_NIGERIA                    0x0469
+#define TT_MS_LANGID_YORUBA_NIGERIA                    0x046a
+#define TT_MS_LANGID_QUECHUA_BOLIVIA                   0x046b
+#define TT_MS_LANGID_QUECHUA_ECUADOR                   0x086b
+#define TT_MS_LANGID_QUECHUA_PERU                      0x0c6b
+#define TT_MS_LANGID_SEPEDI_SOUTH_AFRICA               0x046c
+  /* Also spelled by XPsp2 Platform SDK (2004-07-26) */
+#define TT_MS_LANGID_SOTHO_SOUTHERN_SOUTH_AFRICA \
+          TT_MS_LANGID_SEPEDI_SOUTH_AFRICA
+  /* language codes 0x046d, 0x046e and 0x046f are (still) unknown. */
+#define TT_MS_LANGID_IGBO_NIGERIA                      0x0470
+#define TT_MS_LANGID_KANURI_NIGERIA                    0x0471
+#define TT_MS_LANGID_OROMO_ETHIOPIA                    0x0472
+#define TT_MS_LANGID_TIGRIGNA_ETHIOPIA                 0x0473
+#define TT_MS_LANGID_TIGRIGNA_ERYTHREA                 0x0873
+  /* also spelled in the `Passport SDK' list as: */
+#define TT_MS_LANGID_TIGRIGNA_ERYTREA  TT_MS_LANGID_TIGRIGNA_ERYTHREA
+#define TT_MS_LANGID_GUARANI_PARAGUAY                  0x0474
+#define TT_MS_LANGID_HAWAIIAN_UNITED_STATES            0x0475
+#define TT_MS_LANGID_LATIN                             0x0476
+#define TT_MS_LANGID_SOMALI_SOMALIA                    0x0477
+  /* Note: Yi does not have a (proper) ISO 639-2 code, since it is mostly */
+  /*       not written (but OTOH the peculiar writing system is worth     */
+  /*       studying).                                                     */
+#define TT_MS_LANGID_YI_CHINA                          0x0478
+#define TT_MS_LANGID_PAPIAMENTU_NETHERLANDS_ANTILLES   0x0479
+  /* language codes from 0x047a to 0x047f are (still) unknown. */
+#define TT_MS_LANGID_UIGHUR_CHINA                      0x0480
+#define TT_MS_LANGID_MAORI_NEW_ZEALAND                 0x0481
+
+#if 0  /* not deemed useful for fonts */
+#define TT_MS_LANGID_HUMAN_INTERFACE_DEVICE            0x04ff
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Possible values of the `name' identifier field in the name records of */
+  /* the TTF `name' table.  These values are platform independent.         */
+  /*                                                                       */
+#define TT_NAME_ID_COPYRIGHT            0
+#define TT_NAME_ID_FONT_FAMILY          1
+#define TT_NAME_ID_FONT_SUBFAMILY       2
+#define TT_NAME_ID_UNIQUE_ID            3
+#define TT_NAME_ID_FULL_NAME            4
+#define TT_NAME_ID_VERSION_STRING       5
+#define TT_NAME_ID_PS_NAME              6
+#define TT_NAME_ID_TRADEMARK            7
+
+  /* the following values are from the OpenType spec */
+#define TT_NAME_ID_MANUFACTURER         8
+#define TT_NAME_ID_DESIGNER             9
+#define TT_NAME_ID_DESCRIPTION          10
+#define TT_NAME_ID_VENDOR_URL           11
+#define TT_NAME_ID_DESIGNER_URL         12
+#define TT_NAME_ID_LICENSE              13
+#define TT_NAME_ID_LICENSE_URL          14
+  /* number 15 is reserved */
+#define TT_NAME_ID_PREFERRED_FAMILY     16
+#define TT_NAME_ID_PREFERRED_SUBFAMILY  17
+#define TT_NAME_ID_MAC_FULL_NAME        18
+
+  /* The following code is new as of 2000-01-21 */
+#define TT_NAME_ID_SAMPLE_TEXT          19
+
+  /* This is new in OpenType 1.3 */
+#define TT_NAME_ID_CID_FINDFONT_NAME    20
+
+  /* This is new in OpenType 1.5 */
+#define TT_NAME_ID_WWS_FAMILY           21
+#define TT_NAME_ID_WWS_SUBFAMILY        22
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Bit mask values for the Unicode Ranges from the TTF `OS2 ' table.     */
+  /*                                                                       */
+  /* Updated 08-Nov-2008.                                                  */
+  /*                                                                       */
+
+  /* Bit  0   Basic Latin */
+#define TT_UCR_BASIC_LATIN                     (1L <<  0) /* U+0020-U+007E */
+  /* Bit  1   C1 Controls and Latin-1 Supplement */
+#define TT_UCR_LATIN1_SUPPLEMENT               (1L <<  1) /* U+0080-U+00FF */
+  /* Bit  2   Latin Extended-A */
+#define TT_UCR_LATIN_EXTENDED_A                (1L <<  2) /* U+0100-U+017F */
+  /* Bit  3   Latin Extended-B */
+#define TT_UCR_LATIN_EXTENDED_B                (1L <<  3) /* U+0180-U+024F */
+  /* Bit  4   IPA Extensions                 */
+  /*          Phonetic Extensions            */
+  /*          Phonetic Extensions Supplement */
+#define TT_UCR_IPA_EXTENSIONS                  (1L <<  4) /* U+0250-U+02AF */
+                                                          /* U+1D00-U+1D7F */
+                                                          /* U+1D80-U+1DBF */
+  /* Bit  5   Spacing Modifier Letters */
+  /*          Modifier Tone Letters    */
+#define TT_UCR_SPACING_MODIFIER                (1L <<  5) /* U+02B0-U+02FF */
+                                                          /* U+A700-U+A71F */
+  /* Bit  6   Combining Diacritical Marks            */
+  /*          Combining Diacritical Marks Supplement */
+#define TT_UCR_COMBINING_DIACRITICS            (1L <<  6) /* U+0300-U+036F */
+                                                          /* U+1DC0-U+1DFF */
+  /* Bit  7   Greek and Coptic */
+#define TT_UCR_GREEK                           (1L <<  7) /* U+0370-U+03FF */
+  /* Bit  8   Coptic */
+#define TT_UCR_COPTIC                          (1L <<  8) /* U+2C80-U+2CFF */
+  /* Bit  9   Cyrillic            */
+  /*          Cyrillic Supplement */
+  /*          Cyrillic Extended-A */
+  /*          Cyrillic Extended-B */
+#define TT_UCR_CYRILLIC                        (1L <<  9) /* U+0400-U+04FF */
+                                                          /* U+0500-U+052F */
+                                                          /* U+2DE0-U+2DFF */
+                                                          /* U+A640-U+A69F */
+  /* Bit 10   Armenian */
+#define TT_UCR_ARMENIAN                        (1L << 10) /* U+0530-U+058F */
+  /* Bit 11   Hebrew */
+#define TT_UCR_HEBREW                          (1L << 11) /* U+0590-U+05FF */
+  /* Bit 12   Vai */
+#define TT_UCR_VAI                             (1L << 12) /* U+A500-U+A63F */
+  /* Bit 13   Arabic            */
+  /*          Arabic Supplement */
+#define TT_UCR_ARABIC                          (1L << 13) /* U+0600-U+06FF */
+                                                          /* U+0750-U+077F */
+  /* Bit 14   NKo */
+#define TT_UCR_NKO                             (1L << 14) /* U+07C0-U+07FF */
+  /* Bit 15   Devanagari */
+#define TT_UCR_DEVANAGARI                      (1L << 15) /* U+0900-U+097F */
+  /* Bit 16   Bengali */
+#define TT_UCR_BENGALI                         (1L << 16) /* U+0980-U+09FF */
+  /* Bit 17   Gurmukhi */
+#define TT_UCR_GURMUKHI                        (1L << 17) /* U+0A00-U+0A7F */
+  /* Bit 18   Gujarati */
+#define TT_UCR_GUJARATI                        (1L << 18) /* U+0A80-U+0AFF */
+  /* Bit 19   Oriya */
+#define TT_UCR_ORIYA                           (1L << 19) /* U+0B00-U+0B7F */
+  /* Bit 20   Tamil */
+#define TT_UCR_TAMIL                           (1L << 20) /* U+0B80-U+0BFF */
+  /* Bit 21   Telugu */
+#define TT_UCR_TELUGU                          (1L << 21) /* U+0C00-U+0C7F */
+  /* Bit 22   Kannada */
+#define TT_UCR_KANNADA                         (1L << 22) /* U+0C80-U+0CFF */
+  /* Bit 23   Malayalam */
+#define TT_UCR_MALAYALAM                       (1L << 23) /* U+0D00-U+0D7F */
+  /* Bit 24   Thai */
+#define TT_UCR_THAI                            (1L << 24) /* U+0E00-U+0E7F */
+  /* Bit 25   Lao */
+#define TT_UCR_LAO                             (1L << 25) /* U+0E80-U+0EFF */
+  /* Bit 26   Georgian            */
+  /*          Georgian Supplement */
+#define TT_UCR_GEORGIAN                        (1L << 26) /* U+10A0-U+10FF */
+                                                          /* U+2D00-U+2D2F */
+  /* Bit 27   Balinese */
+#define TT_UCR_BALINESE                        (1L << 27) /* U+1B00-U+1B7F */
+  /* Bit 28   Hangul Jamo */
+#define TT_UCR_HANGUL_JAMO                     (1L << 28) /* U+1100-U+11FF */
+  /* Bit 29   Latin Extended Additional */
+  /*          Latin Extended-C          */
+  /*          Latin Extended-D          */
+#define TT_UCR_LATIN_EXTENDED_ADDITIONAL       (1L << 29) /* U+1E00-U+1EFF */
+                                                          /* U+2C60-U+2C7F */
+                                                          /* U+A720-U+A7FF */
+  /* Bit 30   Greek Extended */
+#define TT_UCR_GREEK_EXTENDED                  (1L << 30) /* U+1F00-U+1FFF */
+  /* Bit 31   General Punctuation      */
+  /*          Supplemental Punctuation */
+#define TT_UCR_GENERAL_PUNCTUATION             (1L << 31) /* U+2000-U+206F */
+                                                          /* U+2E00-U+2E7F */
+  /* Bit 32   Superscripts And Subscripts */
+#define TT_UCR_SUPERSCRIPTS_SUBSCRIPTS         (1L <<  0) /* U+2070-U+209F */
+  /* Bit 33   Currency Symbols */
+#define TT_UCR_CURRENCY_SYMBOLS                (1L <<  1) /* U+20A0-U+20CF */
+  /* Bit 34   Combining Diacritical Marks For Symbols */
+#define TT_UCR_COMBINING_DIACRITICS_SYMB       (1L <<  2) /* U+20D0-U+20FF */
+  /* Bit 35   Letterlike Symbols */
+#define TT_UCR_LETTERLIKE_SYMBOLS              (1L <<  3) /* U+2100-U+214F */
+  /* Bit 36   Number Forms */
+#define TT_UCR_NUMBER_FORMS                    (1L <<  4) /* U+2150-U+218F */
+  /* Bit 37   Arrows                           */
+  /*          Supplemental Arrows-A            */
+  /*          Supplemental Arrows-B            */
+  /*          Miscellaneous Symbols and Arrows */
+#define TT_UCR_ARROWS                          (1L <<  5) /* U+2190-U+21FF */
+                                                          /* U+27F0-U+27FF */
+                                                          /* U+2900-U+297F */
+                                                          /* U+2B00-U+2BFF */
+  /* Bit 38   Mathematical Operators               */
+  /*          Supplemental Mathematical Operators  */
+  /*          Miscellaneous Mathematical Symbols-A */
+  /*          Miscellaneous Mathematical Symbols-B */
+#define TT_UCR_MATHEMATICAL_OPERATORS          (1L <<  6) /* U+2200-U+22FF */
+                                                          /* U+2A00-U+2AFF */
+                                                          /* U+27C0-U+27EF */
+                                                          /* U+2980-U+29FF */
+  /* Bit 39 Miscellaneous Technical */
+#define TT_UCR_MISCELLANEOUS_TECHNICAL         (1L <<  7) /* U+2300-U+23FF */
+  /* Bit 40   Control Pictures */
+#define TT_UCR_CONTROL_PICTURES                (1L <<  8) /* U+2400-U+243F */
+  /* Bit 41   Optical Character Recognition */
+#define TT_UCR_OCR                             (1L <<  9) /* U+2440-U+245F */
+  /* Bit 42   Enclosed Alphanumerics */
+#define TT_UCR_ENCLOSED_ALPHANUMERICS          (1L << 10) /* U+2460-U+24FF */
+  /* Bit 43   Box Drawing */
+#define TT_UCR_BOX_DRAWING                     (1L << 11) /* U+2500-U+257F */
+  /* Bit 44   Block Elements */
+#define TT_UCR_BLOCK_ELEMENTS                  (1L << 12) /* U+2580-U+259F */
+  /* Bit 45   Geometric Shapes */
+#define TT_UCR_GEOMETRIC_SHAPES                (1L << 13) /* U+25A0-U+25FF */
+  /* Bit 46   Miscellaneous Symbols */
+#define TT_UCR_MISCELLANEOUS_SYMBOLS           (1L << 14) /* U+2600-U+26FF */
+  /* Bit 47   Dingbats */
+#define TT_UCR_DINGBATS                        (1L << 15) /* U+2700-U+27BF */
+  /* Bit 48   CJK Symbols and Punctuation */
+#define TT_UCR_CJK_SYMBOLS                     (1L << 16) /* U+3000-U+303F */
+  /* Bit 49   Hiragana */
+#define TT_UCR_HIRAGANA                        (1L << 17) /* U+3040-U+309F */
+  /* Bit 50   Katakana                     */
+  /*          Katakana Phonetic Extensions */
+#define TT_UCR_KATAKANA                        (1L << 18) /* U+30A0-U+30FF */
+                                                          /* U+31F0-U+31FF */
+  /* Bit 51   Bopomofo          */
+  /*          Bopomofo Extended */
+#define TT_UCR_BOPOMOFO                        (1L << 19) /* U+3100-U+312F */
+                                                          /* U+31A0-U+31BF */
+  /* Bit 52   Hangul Compatibility Jamo */
+#define TT_UCR_HANGUL_COMPATIBILITY_JAMO       (1L << 20) /* U+3130-U+318F */
+  /* Bit 53   Phags-Pa */
+#define TT_UCR_CJK_MISC                        (1L << 21) /* U+A840-U+A87F */
+#define TT_UCR_KANBUN  TT_UCR_CJK_MISC /* deprecated */
+#define TT_UCR_PHAGSPA
+  /* Bit 54   Enclosed CJK Letters and Months */
+#define TT_UCR_ENCLOSED_CJK_LETTERS_MONTHS     (1L << 22) /* U+3200-U+32FF */
+  /* Bit 55   CJK Compatibility */
+#define TT_UCR_CJK_COMPATIBILITY               (1L << 23) /* U+3300-U+33FF */
+  /* Bit 56   Hangul Syllables */
+#define TT_UCR_HANGUL                          (1L << 24) /* U+AC00-U+D7A3 */
+  /* Bit 57   High Surrogates              */
+  /*          High Private Use Surrogates  */
+  /*          Low Surrogates               */
+  /*                                       */
+  /* According to OpenType specs v.1.3+,   */
+  /* setting bit 57 implies that there is  */
+  /* at least one codepoint beyond the     */
+  /* Basic Multilingual Plane that is      */
+  /* supported by this font.  So it really */
+  /* means >= U+10000                      */
+#define TT_UCR_SURROGATES                      (1L << 25) /* U+D800-U+DB7F */
+                                                          /* U+DB80-U+DBFF */
+                                                          /* U+DC00-U+DFFF */
+#define TT_UCR_NON_PLANE_0  TT_UCR_SURROGATES
+  /* Bit 58  Phoenician */
+#define TT_UCR_PHOENICIAN                      (1L << 26) /*U+10900-U+1091F*/
+  /* Bit 59   CJK Unified Ideographs             */
+  /*          CJK Radicals Supplement            */
+  /*          Kangxi Radicals                    */
+  /*          Ideographic Description Characters */
+  /*          CJK Unified Ideographs Extension A */
+  /*          CJK Unified Ideographs Extension B */
+  /*          Kanbun                             */
+#define TT_UCR_CJK_UNIFIED_IDEOGRAPHS          (1L << 27) /* U+4E00-U+9FFF */
+                                                          /* U+2E80-U+2EFF */
+                                                          /* U+2F00-U+2FDF */
+                                                          /* U+2FF0-U+2FFF */
+                                                          /* U+3400-U+4DB5 */
+                                                          /*U+20000-U+2A6DF*/
+                                                          /* U+3190-U+319F */
+  /* Bit 60   Private Use */
+#define TT_UCR_PRIVATE_USE                     (1L << 28) /* U+E000-U+F8FF */
+  /* Bit 61   CJK Strokes                             */
+  /*          CJK Compatibility Ideographs            */
+  /*          CJK Compatibility Ideographs Supplement */
+#define TT_UCR_CJK_COMPATIBILITY_IDEOGRAPHS    (1L << 29) /* U+31C0-U+31EF */
+                                                          /* U+F900-U+FAFF */
+                                                          /*U+2F800-U+2FA1F*/
+  /* Bit 62   Alphabetic Presentation Forms */
+#define TT_UCR_ALPHABETIC_PRESENTATION_FORMS   (1L << 30) /* U+FB00-U+FB4F */
+  /* Bit 63   Arabic Presentation Forms-A */
+#define TT_UCR_ARABIC_PRESENTATIONS_A          (1L << 31) /* U+FB50-U+FDFF */
+  /* Bit 64   Combining Half Marks */
+#define TT_UCR_COMBINING_HALF_MARKS            (1L <<  0) /* U+FE20-U+FE2F */
+  /* Bit 65   Vertical forms          */
+  /*          CJK Compatibility Forms */
+#define TT_UCR_CJK_COMPATIBILITY_FORMS         (1L <<  1) /* U+FE10-U+FE1F */
+                                                          /* U+FE30-U+FE4F */
+  /* Bit 66   Small Form Variants */
+#define TT_UCR_SMALL_FORM_VARIANTS             (1L <<  2) /* U+FE50-U+FE6F */
+  /* Bit 67   Arabic Presentation Forms-B */
+#define TT_UCR_ARABIC_PRESENTATIONS_B          (1L <<  3) /* U+FE70-U+FEFE */
+  /* Bit 68   Halfwidth and Fullwidth Forms */
+#define TT_UCR_HALFWIDTH_FULLWIDTH_FORMS       (1L <<  4) /* U+FF00-U+FFEF */
+  /* Bit 69   Specials */
+#define TT_UCR_SPECIALS                        (1L <<  5) /* U+FFF0-U+FFFD */
+  /* Bit 70   Tibetan */
+#define TT_UCR_TIBETAN                         (1L <<  6) /* U+0F00-U+0FFF */
+  /* Bit 71   Syriac */
+#define TT_UCR_SYRIAC                          (1L <<  7) /* U+0700-U+074F */
+  /* Bit 72   Thaana */
+#define TT_UCR_THAANA                          (1L <<  8) /* U+0780-U+07BF */
+  /* Bit 73   Sinhala */
+#define TT_UCR_SINHALA                         (1L <<  9) /* U+0D80-U+0DFF */
+  /* Bit 74   Myanmar */
+#define TT_UCR_MYANMAR                         (1L << 10) /* U+1000-U+109F */
+  /* Bit 75   Ethiopic            */
+  /*          Ethiopic Supplement */
+  /*          Ethiopic Extended   */
+#define TT_UCR_ETHIOPIC                        (1L << 11) /* U+1200-U+137F */
+                                                          /* U+1380-U+139F */
+                                                          /* U+2D80-U+2DDF */
+  /* Bit 76   Cherokee */
+#define TT_UCR_CHEROKEE                        (1L << 12) /* U+13A0-U+13FF */
+  /* Bit 77   Unified Canadian Aboriginal Syllabics */
+#define TT_UCR_CANADIAN_ABORIGINAL_SYLLABICS   (1L << 13) /* U+1400-U+167F */
+  /* Bit 78   Ogham */
+#define TT_UCR_OGHAM                           (1L << 14) /* U+1680-U+169F */
+  /* Bit 79   Runic */
+#define TT_UCR_RUNIC                           (1L << 15) /* U+16A0-U+16FF */
+  /* Bit 80   Khmer         */
+  /*          Khmer Symbols */
+#define TT_UCR_KHMER                           (1L << 16) /* U+1780-U+17FF */
+                                                          /* U+19E0-U+19FF */
+  /* Bit 81   Mongolian */
+#define TT_UCR_MONGOLIAN                       (1L << 17) /* U+1800-U+18AF */
+  /* Bit 82   Braille Patterns */
+#define TT_UCR_BRAILLE                         (1L << 18) /* U+2800-U+28FF */
+  /* Bit 83   Yi Syllables */
+  /*          Yi Radicals  */
+#define TT_UCR_YI                              (1L << 19) /* U+A000-U+A48F */
+                                                          /* U+A490-U+A4CF */
+  /* Bit 84   Tagalog  */
+  /*          Hanunoo  */
+  /*          Buhid    */
+  /*          Tagbanwa */
+#define TT_UCR_PHILIPPINE                      (1L << 20) /* U+1700-U+171F */
+                                                          /* U+1720-U+173F */
+                                                          /* U+1740-U+175F */
+                                                          /* U+1760-U+177F */
+  /* Bit 85   Old Italic */
+#define TT_UCR_OLD_ITALIC                      (1L << 21) /*U+10300-U+1032F*/
+  /* Bit 86   Gothic */
+#define TT_UCR_GOTHIC                          (1L << 22) /*U+10330-U+1034F*/
+  /* Bit 87   Deseret */
+#define TT_UCR_DESERET                         (1L << 23) /*U+10400-U+1044F*/
+  /* Bit 88   Byzantine Musical Symbols      */
+  /*          Musical Symbols                */
+  /*          Ancient Greek Musical Notation */
+#define TT_UCR_MUSICAL_SYMBOLS                 (1L << 24) /*U+1D000-U+1D0FF*/
+                                                          /*U+1D100-U+1D1FF*/
+                                                          /*U+1D200-U+1D24F*/
+  /* Bit 89   Mathematical Alphanumeric Symbols */
+#define TT_UCR_MATH_ALPHANUMERIC_SYMBOLS       (1L << 25) /*U+1D400-U+1D7FF*/
+  /* Bit 90   Private Use (plane 15) */
+  /*          Private Use (plane 16) */
+#define TT_UCR_PRIVATE_USE_SUPPLEMENTARY       (1L << 26) /*U+F0000-U+FFFFD*/
+                                                        /*U+100000-U+10FFFD*/
+  /* Bit 91   Variation Selectors            */
+  /*          Variation Selectors Supplement */
+#define TT_UCR_VARIATION_SELECTORS             (1L << 27) /* U+FE00-U+FE0F */
+                                                          /*U+E0100-U+E01EF*/
+  /* Bit 92   Tags */
+#define TT_UCR_TAGS                            (1L << 28) /*U+E0000-U+E007F*/
+  /* Bit 93   Limbu */
+#define TT_UCR_LIMBU                           (1L << 29) /* U+1900-U+194F */
+  /* Bit 94   Tai Le */
+#define TT_UCR_TAI_LE                          (1L << 30) /* U+1950-U+197F */
+  /* Bit 95   New Tai Lue */
+#define TT_UCR_NEW_TAI_LUE                     (1L << 31) /* U+1980-U+19DF */
+  /* Bit 96   Buginese */
+#define TT_UCR_BUGINESE                        (1L <<  0) /* U+1A00-U+1A1F */
+  /* Bit 97   Glagolitic */
+#define TT_UCR_GLAGOLITIC                      (1L <<  1) /* U+2C00-U+2C5F */
+  /* Bit 98   Tifinagh */
+#define TT_UCR_TIFINAGH                        (1L <<  2) /* U+2D30-U+2D7F */
+  /* Bit 99   Yijing Hexagram Symbols */
+#define TT_UCR_YIJING                          (1L <<  3) /* U+4DC0-U+4DFF */
+  /* Bit 100  Syloti Nagri */
+#define TT_UCR_SYLOTI_NAGRI                    (1L <<  4) /* U+A800-U+A82F */
+  /* Bit 101  Linear B Syllabary */
+  /*          Linear B Ideograms */
+  /*          Aegean Numbers     */
+#define TT_UCR_LINEAR_B                        (1L <<  5) /*U+10000-U+1007F*/
+                                                          /*U+10080-U+100FF*/
+                                                          /*U+10100-U+1013F*/
+  /* Bit 102  Ancient Greek Numbers */
+#define TT_UCR_ANCIENT_GREEK_NUMBERS           (1L <<  6) /*U+10140-U+1018F*/
+  /* Bit 103  Ugaritic */
+#define TT_UCR_UGARITIC                        (1L <<  7) /*U+10380-U+1039F*/
+  /* Bit 104  Old Persian */
+#define TT_UCR_OLD_PERSIAN                     (1L <<  8) /*U+103A0-U+103DF*/
+  /* Bit 105  Shavian */
+#define TT_UCR_SHAVIAN                         (1L <<  9) /*U+10450-U+1047F*/
+  /* Bit 106  Osmanya */
+#define TT_UCR_OSMANYA                         (1L << 10) /*U+10480-U+104AF*/
+  /* Bit 107  Cypriot Syllabary */
+#define TT_UCR_CYPRIOT_SYLLABARY               (1L << 11) /*U+10800-U+1083F*/
+  /* Bit 108  Kharoshthi */
+#define TT_UCR_KHAROSHTHI                      (1L << 12) /*U+10A00-U+10A5F*/
+  /* Bit 109  Tai Xuan Jing Symbols */
+#define TT_UCR_TAI_XUAN_JING                   (1L << 13) /*U+1D300-U+1D35F*/
+  /* Bit 110  Cuneiform                         */
+  /*          Cuneiform Numbers and Punctuation */
+#define TT_UCR_CUNEIFORM                       (1L << 14) /*U+12000-U+123FF*/
+                                                          /*U+12400-U+1247F*/
+  /* Bit 111  Counting Rod Numerals */
+#define TT_UCR_COUNTING_ROD_NUMERALS           (1L << 15) /*U+1D360-U+1D37F*/
+  /* Bit 112  Sundanese */
+#define TT_UCR_SUNDANESE                       (1L << 16) /* U+1B80-U+1BBF */
+  /* Bit 113  Lepcha */
+#define TT_UCR_LEPCHA                          (1L << 17) /* U+1C00-U+1C4F */
+  /* Bit 114  Ol Chiki */
+#define TT_UCR_OL_CHIKI                        (1L << 18) /* U+1C50-U+1C7F */
+  /* Bit 115  Saurashtra */
+#define TT_UCR_SAURASHTRA                      (1L << 19) /* U+A880-U+A8DF */
+  /* Bit 116  Kayah Li */
+#define TT_UCR_KAYAH_LI                        (1L << 20) /* U+A900-U+A92F */
+  /* Bit 117  Rejang */
+#define TT_UCR_REJANG                          (1L << 21) /* U+A930-U+A95F */
+  /* Bit 118  Cham */
+#define TT_UCR_CHAM                            (1L << 22) /* U+AA00-U+AA5F */
+  /* Bit 119  Ancient Symbols */
+#define TT_UCR_ANCIENT_SYMBOLS                 (1L << 23) /*U+10190-U+101CF*/
+  /* Bit 120  Phaistos Disc */
+#define TT_UCR_PHAISTOS_DISC                   (1L << 24) /*U+101D0-U+101FF*/
+  /* Bit 121  Carian */
+  /*          Lycian */
+  /*          Lydian */
+#define TT_UCR_OLD_ANATOLIAN                   (1L << 25) /*U+102A0-U+102DF*/
+                                                          /*U+10280-U+1029F*/
+                                                          /*U+10920-U+1093F*/
+  /* Bit 122  Domino Tiles  */
+  /*          Mahjong Tiles */
+#define TT_UCR_GAME_TILES                      (1L << 26) /*U+1F030-U+1F09F*/
+                                                          /*U+1F000-U+1F02F*/
+  /* Bit 123-127 Reserved for process-internal usage */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Some compilers have a very limited length of identifiers.             */
+  /*                                                                       */
+#if defined( __TURBOC__ ) && __TURBOC__ < 0x0410 || defined( __PACIFIC__ )
+#define HAVE_LIMIT_ON_IDENTS
+#endif
+
+
+#ifndef HAVE_LIMIT_ON_IDENTS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Here some alias #defines in order to be clearer.                      */
+  /*                                                                       */
+  /* These are not always #defined to stay within the 31~character limit   */
+  /* which some compilers have.                                            */
+  /*                                                                       */
+  /* Credits go to Dave Hoo <dhoo@flash.net> for pointing out that modern  */
+  /* Borland compilers (read: from BC++ 3.1 on) can increase this limit.   */
+  /* If you get a warning with such a compiler, use the -i40 switch.       */
+  /*                                                                       */
+#define TT_UCR_ARABIC_PRESENTATION_FORMS_A      \
+         TT_UCR_ARABIC_PRESENTATIONS_A
+#define TT_UCR_ARABIC_PRESENTATION_FORMS_B      \
+         TT_UCR_ARABIC_PRESENTATIONS_B
+
+#define TT_UCR_COMBINING_DIACRITICAL_MARKS      \
+         TT_UCR_COMBINING_DIACRITICS
+#define TT_UCR_COMBINING_DIACRITICAL_MARKS_SYMB \
+         TT_UCR_COMBINING_DIACRITICS_SYMB
+
+
+#endif /* !HAVE_LIMIT_ON_IDENTS */
+
+
+FT_END_HEADER
+
+#endif /* __TTNAMEID_H__ */
+
+
+/* END */
diff --git a/include/freetype/tttables.h b/include/freetype/tttables.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/tttables.h
@@ -0,0 +1,777 @@
+/***************************************************************************/
+/*                                                                         */
+/*  tttables.h                                                             */
+/*                                                                         */
+/*    Basic SFNT/TrueType tables definitions and interface                 */
+/*    (specification only).                                                */
+/*                                                                         */
+/*  Copyright 1996-2005, 2008-2012 by                                      */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __TTTABLES_H__
+#define __TTTABLES_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Section>                                                             */
+  /*    truetype_tables                                                    */
+  /*                                                                       */
+  /* <Title>                                                               */
+  /*    TrueType Tables                                                    */
+  /*                                                                       */
+  /* <Abstract>                                                            */
+  /*    TrueType specific table types and functions.                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This section contains the definition of TrueType-specific tables   */
+  /*    as well as some routines used to access and process them.          */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Header                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a TrueType font header table.  All       */
+  /*    fields follow the TrueType specification.                          */
+  /*                                                                       */
+  typedef struct  TT_Header_
+  {
+    FT_Fixed   Table_Version;
+    FT_Fixed   Font_Revision;
+
+    FT_Long    CheckSum_Adjust;
+    FT_Long    Magic_Number;
+
+    FT_UShort  Flags;
+    FT_UShort  Units_Per_EM;
+
+    FT_Long    Created [2];
+    FT_Long    Modified[2];
+
+    FT_Short   xMin;
+    FT_Short   yMin;
+    FT_Short   xMax;
+    FT_Short   yMax;
+
+    FT_UShort  Mac_Style;
+    FT_UShort  Lowest_Rec_PPEM;
+
+    FT_Short   Font_Direction;
+    FT_Short   Index_To_Loc_Format;
+    FT_Short   Glyph_Data_Format;
+
+  } TT_Header;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_HoriHeader                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a TrueType horizontal header, the `hhea' */
+  /*    table, as well as the corresponding horizontal metrics table,      */
+  /*    i.e., the `hmtx' table.                                            */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    Version                :: The table version.                       */
+  /*                                                                       */
+  /*    Ascender               :: The font's ascender, i.e., the distance  */
+  /*                              from the baseline to the top-most of all */
+  /*                              glyph points found in the font.          */
+  /*                                                                       */
+  /*                              This value is invalid in many fonts, as  */
+  /*                              it is usually set by the font designer,  */
+  /*                              and often reflects only a portion of the */
+  /*                              glyphs found in the font (maybe ASCII).  */
+  /*                                                                       */
+  /*                              You should use the `sTypoAscender' field */
+  /*                              of the OS/2 table instead if you want    */
+  /*                              the correct one.                         */
+  /*                                                                       */
+  /*    Descender              :: The font's descender, i.e., the distance */
+  /*                              from the baseline to the bottom-most of  */
+  /*                              all glyph points found in the font.  It  */
+  /*                              is negative.                             */
+  /*                                                                       */
+  /*                              This value is invalid in many fonts, as  */
+  /*                              it is usually set by the font designer,  */
+  /*                              and often reflects only a portion of the */
+  /*                              glyphs found in the font (maybe ASCII).  */
+  /*                                                                       */
+  /*                              You should use the `sTypoDescender'      */
+  /*                              field of the OS/2 table instead if you   */
+  /*                              want the correct one.                    */
+  /*                                                                       */
+  /*    Line_Gap               :: The font's line gap, i.e., the distance  */
+  /*                              to add to the ascender and descender to  */
+  /*                              get the BTB, i.e., the                   */
+  /*                              baseline-to-baseline distance for the    */
+  /*                              font.                                    */
+  /*                                                                       */
+  /*    advance_Width_Max      :: This field is the maximum of all advance */
+  /*                              widths found in the font.  It can be     */
+  /*                              used to compute the maximum width of an  */
+  /*                              arbitrary string of text.                */
+  /*                                                                       */
+  /*    min_Left_Side_Bearing  :: The minimum left side bearing of all     */
+  /*                              glyphs within the font.                  */
+  /*                                                                       */
+  /*    min_Right_Side_Bearing :: The minimum right side bearing of all    */
+  /*                              glyphs within the font.                  */
+  /*                                                                       */
+  /*    xMax_Extent            :: The maximum horizontal extent (i.e., the */
+  /*                              `width' of a glyph's bounding box) for   */
+  /*                              all glyphs in the font.                  */
+  /*                                                                       */
+  /*    caret_Slope_Rise       :: The rise coefficient of the cursor's     */
+  /*                              slope of the cursor (slope=rise/run).    */
+  /*                                                                       */
+  /*    caret_Slope_Run        :: The run coefficient of the cursor's      */
+  /*                              slope.                                   */
+  /*                                                                       */
+  /*    Reserved               :: 8~reserved bytes.                        */
+  /*                                                                       */
+  /*    metric_Data_Format     :: Always~0.                                */
+  /*                                                                       */
+  /*    number_Of_HMetrics     :: Number of HMetrics entries in the `hmtx' */
+  /*                              table -- this value can be smaller than  */
+  /*                              the total number of glyphs in the font.  */
+  /*                                                                       */
+  /*    long_metrics           :: A pointer into the `hmtx' table.         */
+  /*                                                                       */
+  /*    short_metrics          :: A pointer into the `hmtx' table.         */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    IMPORTANT: The TT_HoriHeader and TT_VertHeader structures should   */
+  /*               be identical except for the names of their fields which */
+  /*               are different.                                          */
+  /*                                                                       */
+  /*               This ensures that a single function in the `ttload'     */
+  /*               module is able to read both the horizontal and vertical */
+  /*               headers.                                                */
+  /*                                                                       */
+  typedef struct  TT_HoriHeader_
+  {
+    FT_Fixed   Version;
+    FT_Short   Ascender;
+    FT_Short   Descender;
+    FT_Short   Line_Gap;
+
+    FT_UShort  advance_Width_Max;      /* advance width maximum */
+
+    FT_Short   min_Left_Side_Bearing;  /* minimum left-sb       */
+    FT_Short   min_Right_Side_Bearing; /* minimum right-sb      */
+    FT_Short   xMax_Extent;            /* xmax extents          */
+    FT_Short   caret_Slope_Rise;
+    FT_Short   caret_Slope_Run;
+    FT_Short   caret_Offset;
+
+    FT_Short   Reserved[4];
+
+    FT_Short   metric_Data_Format;
+    FT_UShort  number_Of_HMetrics;
+
+    /* The following fields are not defined by the TrueType specification */
+    /* but they are used to connect the metrics header to the relevant    */
+    /* `HMTX' table.                                                      */
+
+    void*      long_metrics;
+    void*      short_metrics;
+
+  } TT_HoriHeader;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_VertHeader                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a TrueType vertical header, the `vhea'   */
+  /*    table, as well as the corresponding vertical metrics table, i.e.,  */
+  /*    the `vmtx' table.                                                  */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    Version                 :: The table version.                      */
+  /*                                                                       */
+  /*    Ascender                :: The font's ascender, i.e., the distance */
+  /*                               from the baseline to the top-most of    */
+  /*                               all glyph points found in the font.     */
+  /*                                                                       */
+  /*                               This value is invalid in many fonts, as */
+  /*                               it is usually set by the font designer, */
+  /*                               and often reflects only a portion of    */
+  /*                               the glyphs found in the font (maybe     */
+  /*                               ASCII).                                 */
+  /*                                                                       */
+  /*                               You should use the `sTypoAscender'      */
+  /*                               field of the OS/2 table instead if you  */
+  /*                               want the correct one.                   */
+  /*                                                                       */
+  /*    Descender               :: The font's descender, i.e., the         */
+  /*                               distance from the baseline to the       */
+  /*                               bottom-most of all glyph points found   */
+  /*                               in the font.  It is negative.           */
+  /*                                                                       */
+  /*                               This value is invalid in many fonts, as */
+  /*                               it is usually set by the font designer, */
+  /*                               and often reflects only a portion of    */
+  /*                               the glyphs found in the font (maybe     */
+  /*                               ASCII).                                 */
+  /*                                                                       */
+  /*                               You should use the `sTypoDescender'     */
+  /*                               field of the OS/2 table instead if you  */
+  /*                               want the correct one.                   */
+  /*                                                                       */
+  /*    Line_Gap                :: The font's line gap, i.e., the distance */
+  /*                               to add to the ascender and descender to */
+  /*                               get the BTB, i.e., the                  */
+  /*                               baseline-to-baseline distance for the   */
+  /*                               font.                                   */
+  /*                                                                       */
+  /*    advance_Height_Max      :: This field is the maximum of all        */
+  /*                               advance heights found in the font.  It  */
+  /*                               can be used to compute the maximum      */
+  /*                               height of an arbitrary string of text.  */
+  /*                                                                       */
+  /*    min_Top_Side_Bearing    :: The minimum top side bearing of all     */
+  /*                               glyphs within the font.                 */
+  /*                                                                       */
+  /*    min_Bottom_Side_Bearing :: The minimum bottom side bearing of all  */
+  /*                               glyphs within the font.                 */
+  /*                                                                       */
+  /*    yMax_Extent             :: The maximum vertical extent (i.e., the  */
+  /*                               `height' of a glyph's bounding box) for */
+  /*                               all glyphs in the font.                 */
+  /*                                                                       */
+  /*    caret_Slope_Rise        :: The rise coefficient of the cursor's    */
+  /*                               slope of the cursor (slope=rise/run).   */
+  /*                                                                       */
+  /*    caret_Slope_Run         :: The run coefficient of the cursor's     */
+  /*                               slope.                                  */
+  /*                                                                       */
+  /*    caret_Offset            :: The cursor's offset for slanted fonts.  */
+  /*                               This value is `reserved' in vmtx        */
+  /*                               version 1.0.                            */
+  /*                                                                       */
+  /*    Reserved                :: 8~reserved bytes.                       */
+  /*                                                                       */
+  /*    metric_Data_Format      :: Always~0.                               */
+  /*                                                                       */
+  /*    number_Of_HMetrics      :: Number of VMetrics entries in the       */
+  /*                               `vmtx' table -- this value can be       */
+  /*                               smaller than the total number of glyphs */
+  /*                               in the font.                            */
+  /*                                                                       */
+  /*    long_metrics           :: A pointer into the `vmtx' table.         */
+  /*                                                                       */
+  /*    short_metrics          :: A pointer into the `vmtx' table.         */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    IMPORTANT: The TT_HoriHeader and TT_VertHeader structures should   */
+  /*               be identical except for the names of their fields which */
+  /*               are different.                                          */
+  /*                                                                       */
+  /*               This ensures that a single function in the `ttload'     */
+  /*               module is able to read both the horizontal and vertical */
+  /*               headers.                                                */
+  /*                                                                       */
+  typedef struct  TT_VertHeader_
+  {
+    FT_Fixed   Version;
+    FT_Short   Ascender;
+    FT_Short   Descender;
+    FT_Short   Line_Gap;
+
+    FT_UShort  advance_Height_Max;      /* advance height maximum */
+
+    FT_Short   min_Top_Side_Bearing;    /* minimum left-sb or top-sb       */
+    FT_Short   min_Bottom_Side_Bearing; /* minimum right-sb or bottom-sb   */
+    FT_Short   yMax_Extent;             /* xmax or ymax extents            */
+    FT_Short   caret_Slope_Rise;
+    FT_Short   caret_Slope_Run;
+    FT_Short   caret_Offset;
+
+    FT_Short   Reserved[4];
+
+    FT_Short   metric_Data_Format;
+    FT_UShort  number_Of_VMetrics;
+
+    /* The following fields are not defined by the TrueType specification */
+    /* but they're used to connect the metrics header to the relevant     */
+    /* `HMTX' or `VMTX' table.                                            */
+
+    void*      long_metrics;
+    void*      short_metrics;
+
+  } TT_VertHeader;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_OS2                                                             */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a TrueType OS/2 table. This is the long  */
+  /*    table version.  All fields comply to the TrueType specification.   */
+  /*                                                                       */
+  /*    Note that we now support old Mac fonts which do not include an     */
+  /*    OS/2 table.  In this case, the `version' field is always set to    */
+  /*    0xFFFF.                                                            */
+  /*                                                                       */
+  typedef struct  TT_OS2_
+  {
+    FT_UShort  version;                /* 0x0001 - more or 0xFFFF */
+    FT_Short   xAvgCharWidth;
+    FT_UShort  usWeightClass;
+    FT_UShort  usWidthClass;
+    FT_Short   fsType;
+    FT_Short   ySubscriptXSize;
+    FT_Short   ySubscriptYSize;
+    FT_Short   ySubscriptXOffset;
+    FT_Short   ySubscriptYOffset;
+    FT_Short   ySuperscriptXSize;
+    FT_Short   ySuperscriptYSize;
+    FT_Short   ySuperscriptXOffset;
+    FT_Short   ySuperscriptYOffset;
+    FT_Short   yStrikeoutSize;
+    FT_Short   yStrikeoutPosition;
+    FT_Short   sFamilyClass;
+
+    FT_Byte    panose[10];
+
+    FT_ULong   ulUnicodeRange1;        /* Bits 0-31   */
+    FT_ULong   ulUnicodeRange2;        /* Bits 32-63  */
+    FT_ULong   ulUnicodeRange3;        /* Bits 64-95  */
+    FT_ULong   ulUnicodeRange4;        /* Bits 96-127 */
+
+    FT_Char    achVendID[4];
+
+    FT_UShort  fsSelection;
+    FT_UShort  usFirstCharIndex;
+    FT_UShort  usLastCharIndex;
+    FT_Short   sTypoAscender;
+    FT_Short   sTypoDescender;
+    FT_Short   sTypoLineGap;
+    FT_UShort  usWinAscent;
+    FT_UShort  usWinDescent;
+
+    /* only version 1 tables: */
+
+    FT_ULong   ulCodePageRange1;       /* Bits 0-31   */
+    FT_ULong   ulCodePageRange2;       /* Bits 32-63  */
+
+    /* only version 2 tables: */
+
+    FT_Short   sxHeight;
+    FT_Short   sCapHeight;
+    FT_UShort  usDefaultChar;
+    FT_UShort  usBreakChar;
+    FT_UShort  usMaxContext;
+
+  } TT_OS2;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_Postscript                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a TrueType PostScript table.  All fields */
+  /*    comply to the TrueType specification.  This structure does not     */
+  /*    reference the PostScript glyph names, which can be nevertheless    */
+  /*    accessed with the `ttpost' module.                                 */
+  /*                                                                       */
+  typedef struct  TT_Postscript_
+  {
+    FT_Fixed  FormatType;
+    FT_Fixed  italicAngle;
+    FT_Short  underlinePosition;
+    FT_Short  underlineThickness;
+    FT_ULong  isFixedPitch;
+    FT_ULong  minMemType42;
+    FT_ULong  maxMemType42;
+    FT_ULong  minMemType1;
+    FT_ULong  maxMemType1;
+
+    /* Glyph names follow in the file, but we don't   */
+    /* load them by default.  See the ttpost.c file.  */
+
+  } TT_Postscript;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_PCLT                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    A structure used to model a TrueType PCLT table.  All fields       */
+  /*    comply to the TrueType specification.                              */
+  /*                                                                       */
+  typedef struct  TT_PCLT_
+  {
+    FT_Fixed   Version;
+    FT_ULong   FontNumber;
+    FT_UShort  Pitch;
+    FT_UShort  xHeight;
+    FT_UShort  Style;
+    FT_UShort  TypeFamily;
+    FT_UShort  CapHeight;
+    FT_UShort  SymbolSet;
+    FT_Char    TypeFace[16];
+    FT_Char    CharacterComplement[8];
+    FT_Char    FileName[6];
+    FT_Char    StrokeWeight;
+    FT_Char    WidthType;
+    FT_Byte    SerifStyle;
+    FT_Byte    Reserved;
+
+  } TT_PCLT;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Struct>                                                              */
+  /*    TT_MaxProfile                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    The maximum profile is a table containing many max values which    */
+  /*    can be used to pre-allocate arrays.  This ensures that no memory   */
+  /*    allocation occurs during a glyph load.                             */
+  /*                                                                       */
+  /* <Fields>                                                              */
+  /*    version               :: The version number.                       */
+  /*                                                                       */
+  /*    numGlyphs             :: The number of glyphs in this TrueType     */
+  /*                             font.                                     */
+  /*                                                                       */
+  /*    maxPoints             :: The maximum number of points in a         */
+  /*                             non-composite TrueType glyph.  See also   */
+  /*                             the structure element                     */
+  /*                             `maxCompositePoints'.                     */
+  /*                                                                       */
+  /*    maxContours           :: The maximum number of contours in a       */
+  /*                             non-composite TrueType glyph.  See also   */
+  /*                             the structure element                     */
+  /*                             `maxCompositeContours'.                   */
+  /*                                                                       */
+  /*    maxCompositePoints    :: The maximum number of points in a         */
+  /*                             composite TrueType glyph.  See also the   */
+  /*                             structure element `maxPoints'.            */
+  /*                                                                       */
+  /*    maxCompositeContours  :: The maximum number of contours in a       */
+  /*                             composite TrueType glyph.  See also the   */
+  /*                             structure element `maxContours'.          */
+  /*                                                                       */
+  /*    maxZones              :: The maximum number of zones used for      */
+  /*                             glyph hinting.                            */
+  /*                                                                       */
+  /*    maxTwilightPoints     :: The maximum number of points in the       */
+  /*                             twilight zone used for glyph hinting.     */
+  /*                                                                       */
+  /*    maxStorage            :: The maximum number of elements in the     */
+  /*                             storage area used for glyph hinting.      */
+  /*                                                                       */
+  /*    maxFunctionDefs       :: The maximum number of function            */
+  /*                             definitions in the TrueType bytecode for  */
+  /*                             this font.                                */
+  /*                                                                       */
+  /*    maxInstructionDefs    :: The maximum number of instruction         */
+  /*                             definitions in the TrueType bytecode for  */
+  /*                             this font.                                */
+  /*                                                                       */
+  /*    maxStackElements      :: The maximum number of stack elements used */
+  /*                             during bytecode interpretation.           */
+  /*                                                                       */
+  /*    maxSizeOfInstructions :: The maximum number of TrueType opcodes    */
+  /*                             used for glyph hinting.                   */
+  /*                                                                       */
+  /*    maxComponentElements  :: The maximum number of simple (i.e., non-  */
+  /*                             composite) glyphs in a composite glyph.   */
+  /*                                                                       */
+  /*    maxComponentDepth     :: The maximum nesting depth of composite    */
+  /*                             glyphs.                                   */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This structure is only used during font loading.                   */
+  /*                                                                       */
+  typedef struct  TT_MaxProfile_
+  {
+    FT_Fixed   version;
+    FT_UShort  numGlyphs;
+    FT_UShort  maxPoints;
+    FT_UShort  maxContours;
+    FT_UShort  maxCompositePoints;
+    FT_UShort  maxCompositeContours;
+    FT_UShort  maxZones;
+    FT_UShort  maxTwilightPoints;
+    FT_UShort  maxStorage;
+    FT_UShort  maxFunctionDefs;
+    FT_UShort  maxInstructionDefs;
+    FT_UShort  maxStackElements;
+    FT_UShort  maxSizeOfInstructions;
+    FT_UShort  maxComponentElements;
+    FT_UShort  maxComponentDepth;
+
+  } TT_MaxProfile;
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Enum>                                                                */
+  /*    FT_Sfnt_Tag                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    An enumeration used to specify the index of an SFNT table.         */
+  /*    Used in the @FT_Get_Sfnt_Table API function.                       */
+  /*                                                                       */
+  typedef enum  FT_Sfnt_Tag_
+  {
+    ft_sfnt_head = 0,    /* TT_Header     */
+    ft_sfnt_maxp = 1,    /* TT_MaxProfile */
+    ft_sfnt_os2  = 2,    /* TT_OS2        */
+    ft_sfnt_hhea = 3,    /* TT_HoriHeader */
+    ft_sfnt_vhea = 4,    /* TT_VertHeader */
+    ft_sfnt_post = 5,    /* TT_Postscript */
+    ft_sfnt_pclt = 6,    /* TT_PCLT       */
+
+    sfnt_max   /* internal end mark */
+
+  } FT_Sfnt_Tag;
+
+  /* */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_Sfnt_Table                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return a pointer to a given SFNT table within a face.              */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the source.                                    */
+  /*                                                                       */
+  /*    tag  :: The index of the SFNT table.                               */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    A type-less pointer to the table.  This will be~0 in case of       */
+  /*    error, or if the corresponding table was not found *OR* loaded     */
+  /*    from the file.                                                     */
+  /*                                                                       */
+  /*    Use a typecast according to `tag' to access the structure          */
+  /*    elements.                                                          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The table is owned by the face object and disappears with it.      */
+  /*                                                                       */
+  /*    This function is only useful to access SFNT tables that are loaded */
+  /*    by the sfnt, truetype, and opentype drivers.  See @FT_Sfnt_Tag for */
+  /*    a list.                                                            */
+  /*                                                                       */
+  /*    Here an example how to access the `vhea' table:                    */
+  /*                                                                       */
+  /*    {                                                                  */
+  /*      TT_VertHeader*  vert_header;                                     */
+  /*                                                                       */
+  /*                                                                       */
+  /*      vert_header =                                                    */
+  /*        (TT_VertHeader*)FT_Get_Sfnt_Table( face, ft_sfnt_vhea );       */
+  /*    }                                                                  */
+  /*                                                                       */
+  FT_EXPORT( void* )
+  FT_Get_Sfnt_Table( FT_Face      face,
+                     FT_Sfnt_Tag  tag );
+
+
+ /**************************************************************************
+  *
+  * @function:
+  *   FT_Load_Sfnt_Table
+  *
+  * @description:
+  *   Load any font table into client memory.
+  *
+  * @input:
+  *   face ::
+  *     A handle to the source face.
+  *
+  *   tag ::
+  *     The four-byte tag of the table to load.  Use the value~0 if you want
+  *     to access the whole font file.  Otherwise, you can use one of the
+  *     definitions found in the @FT_TRUETYPE_TAGS_H file, or forge a new
+  *     one with @FT_MAKE_TAG.
+  *
+  *   offset ::
+  *     The starting offset in the table (or file if tag == 0).
+  *
+  * @output:
+  *   buffer ::
+  *     The target buffer address.  The client must ensure that the memory
+  *     array is big enough to hold the data.
+  *
+  * @inout:
+  *   length ::
+  *     If the `length' parameter is NULL, then try to load the whole table.
+  *     Return an error code if it fails.
+  *
+  *     Else, if `*length' is~0, exit immediately while returning the
+  *     table's (or file) full size in it.
+  *
+  *     Else the number of bytes to read from the table or file, from the
+  *     starting offset.
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   If you need to determine the table's length you should first call this
+  *   function with `*length' set to~0, as in the following example:
+  *
+  *     {
+  *       FT_ULong  length = 0;
+  *
+  *
+  *       error = FT_Load_Sfnt_Table( face, tag, 0, NULL, &length );
+  *       if ( error ) { ... table does not exist ... }
+  *
+  *       buffer = malloc( length );
+  *       if ( buffer == NULL ) { ... not enough memory ... }
+  *
+  *       error = FT_Load_Sfnt_Table( face, tag, 0, buffer, &length );
+  *       if ( error ) { ... could not load table ... }
+  *     }
+  */
+  FT_EXPORT( FT_Error )
+  FT_Load_Sfnt_Table( FT_Face    face,
+                      FT_ULong   tag,
+                      FT_Long    offset,
+                      FT_Byte*   buffer,
+                      FT_ULong*  length );
+
+
+ /**************************************************************************
+  *
+  * @function:
+  *   FT_Sfnt_Table_Info
+  *
+  * @description:
+  *   Return information on an SFNT table.
+  *
+  * @input:
+  *   face ::
+  *     A handle to the source face.
+  *
+  *   table_index ::
+  *     The index of an SFNT table.  The function returns
+  *     FT_Err_Table_Missing for an invalid value.
+  *
+  * @inout:
+  *   tag ::
+  *     The name tag of the SFNT table.  If the value is NULL, `table_index'
+  *     is ignored, and `length' returns the number of SFNT tables in the
+  *     font.
+  *
+  * @output:
+  *   length ::
+  *     The length of the SFNT table (or the number of SFNT tables, depending
+  *     on `tag').
+  *
+  * @return:
+  *   FreeType error code.  0~means success.
+  *
+  * @note:
+  *   While parsing fonts, FreeType handles SFNT tables with length zero as
+  *   missing.
+  *
+  */
+  FT_EXPORT( FT_Error )
+  FT_Sfnt_Table_Info( FT_Face    face,
+                      FT_UInt    table_index,
+                      FT_ULong  *tag,
+                      FT_ULong  *length );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_CMap_Language_ID                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return TrueType/sfnt specific cmap language ID.  Definitions of    */
+  /*    language ID values are in `freetype/ttnameid.h'.                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    charmap ::                                                         */
+  /*      The target charmap.                                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The language ID of `charmap'.  If `charmap' doesn't belong to a    */
+  /*    TrueType/sfnt face, just return~0 as the default value.            */
+  /*                                                                       */
+  /*    For a format~14 cmap (to access Unicode IVS), the return value is  */
+  /*    0xFFFFFFFF.                                                        */
+  /*                                                                       */
+  FT_EXPORT( FT_ULong )
+  FT_Get_CMap_Language_ID( FT_CharMap  charmap );
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    FT_Get_CMap_Format                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Return TrueType/sfnt specific cmap format.                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    charmap ::                                                         */
+  /*      The target charmap.                                              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The format of `charmap'.  If `charmap' doesn't belong to a         */
+  /*    TrueType/sfnt face, return -1.                                     */
+  /*                                                                       */
+  FT_EXPORT( FT_Long )
+  FT_Get_CMap_Format( FT_CharMap  charmap );
+
+  /* */
+
+
+FT_END_HEADER
+
+#endif /* __TTTABLES_H__ */
+
+
+/* END */
diff --git a/include/freetype/tttags.h b/include/freetype/tttags.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/tttags.h
@@ -0,0 +1,107 @@
+/***************************************************************************/
+/*                                                                         */
+/*  tttags.h                                                               */
+/*                                                                         */
+/*    Tags for TrueType and OpenType tables (specification only).          */
+/*                                                                         */
+/*  Copyright 1996-2001, 2004, 2005, 2007, 2008 by                         */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __TTAGS_H__
+#define __TTAGS_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+#define TTAG_avar  FT_MAKE_TAG( 'a', 'v', 'a', 'r' )
+#define TTAG_BASE  FT_MAKE_TAG( 'B', 'A', 'S', 'E' )
+#define TTAG_bdat  FT_MAKE_TAG( 'b', 'd', 'a', 't' )
+#define TTAG_BDF   FT_MAKE_TAG( 'B', 'D', 'F', ' ' )
+#define TTAG_bhed  FT_MAKE_TAG( 'b', 'h', 'e', 'd' )
+#define TTAG_bloc  FT_MAKE_TAG( 'b', 'l', 'o', 'c' )
+#define TTAG_bsln  FT_MAKE_TAG( 'b', 's', 'l', 'n' )
+#define TTAG_CFF   FT_MAKE_TAG( 'C', 'F', 'F', ' ' )
+#define TTAG_CID   FT_MAKE_TAG( 'C', 'I', 'D', ' ' )
+#define TTAG_cmap  FT_MAKE_TAG( 'c', 'm', 'a', 'p' )
+#define TTAG_cvar  FT_MAKE_TAG( 'c', 'v', 'a', 'r' )
+#define TTAG_cvt   FT_MAKE_TAG( 'c', 'v', 't', ' ' )
+#define TTAG_DSIG  FT_MAKE_TAG( 'D', 'S', 'I', 'G' )
+#define TTAG_EBDT  FT_MAKE_TAG( 'E', 'B', 'D', 'T' )
+#define TTAG_EBLC  FT_MAKE_TAG( 'E', 'B', 'L', 'C' )
+#define TTAG_EBSC  FT_MAKE_TAG( 'E', 'B', 'S', 'C' )
+#define TTAG_feat  FT_MAKE_TAG( 'f', 'e', 'a', 't' )
+#define TTAG_FOND  FT_MAKE_TAG( 'F', 'O', 'N', 'D' )
+#define TTAG_fpgm  FT_MAKE_TAG( 'f', 'p', 'g', 'm' )
+#define TTAG_fvar  FT_MAKE_TAG( 'f', 'v', 'a', 'r' )
+#define TTAG_gasp  FT_MAKE_TAG( 'g', 'a', 's', 'p' )
+#define TTAG_GDEF  FT_MAKE_TAG( 'G', 'D', 'E', 'F' )
+#define TTAG_glyf  FT_MAKE_TAG( 'g', 'l', 'y', 'f' )
+#define TTAG_GPOS  FT_MAKE_TAG( 'G', 'P', 'O', 'S' )
+#define TTAG_GSUB  FT_MAKE_TAG( 'G', 'S', 'U', 'B' )
+#define TTAG_gvar  FT_MAKE_TAG( 'g', 'v', 'a', 'r' )
+#define TTAG_hdmx  FT_MAKE_TAG( 'h', 'd', 'm', 'x' )
+#define TTAG_head  FT_MAKE_TAG( 'h', 'e', 'a', 'd' )
+#define TTAG_hhea  FT_MAKE_TAG( 'h', 'h', 'e', 'a' )
+#define TTAG_hmtx  FT_MAKE_TAG( 'h', 'm', 't', 'x' )
+#define TTAG_JSTF  FT_MAKE_TAG( 'J', 'S', 'T', 'F' )
+#define TTAG_just  FT_MAKE_TAG( 'j', 'u', 's', 't' )
+#define TTAG_kern  FT_MAKE_TAG( 'k', 'e', 'r', 'n' )
+#define TTAG_lcar  FT_MAKE_TAG( 'l', 'c', 'a', 'r' )
+#define TTAG_loca  FT_MAKE_TAG( 'l', 'o', 'c', 'a' )
+#define TTAG_LTSH  FT_MAKE_TAG( 'L', 'T', 'S', 'H' )
+#define TTAG_LWFN  FT_MAKE_TAG( 'L', 'W', 'F', 'N' )
+#define TTAG_MATH  FT_MAKE_TAG( 'M', 'A', 'T', 'H' )
+#define TTAG_maxp  FT_MAKE_TAG( 'm', 'a', 'x', 'p' )
+#define TTAG_META  FT_MAKE_TAG( 'M', 'E', 'T', 'A' )
+#define TTAG_MMFX  FT_MAKE_TAG( 'M', 'M', 'F', 'X' )
+#define TTAG_MMSD  FT_MAKE_TAG( 'M', 'M', 'S', 'D' )
+#define TTAG_mort  FT_MAKE_TAG( 'm', 'o', 'r', 't' )
+#define TTAG_morx  FT_MAKE_TAG( 'm', 'o', 'r', 'x' )
+#define TTAG_name  FT_MAKE_TAG( 'n', 'a', 'm', 'e' )
+#define TTAG_opbd  FT_MAKE_TAG( 'o', 'p', 'b', 'd' )
+#define TTAG_OS2   FT_MAKE_TAG( 'O', 'S', '/', '2' )
+#define TTAG_OTTO  FT_MAKE_TAG( 'O', 'T', 'T', 'O' )
+#define TTAG_PCLT  FT_MAKE_TAG( 'P', 'C', 'L', 'T' )
+#define TTAG_POST  FT_MAKE_TAG( 'P', 'O', 'S', 'T' )
+#define TTAG_post  FT_MAKE_TAG( 'p', 'o', 's', 't' )
+#define TTAG_prep  FT_MAKE_TAG( 'p', 'r', 'e', 'p' )
+#define TTAG_prop  FT_MAKE_TAG( 'p', 'r', 'o', 'p' )
+#define TTAG_sfnt  FT_MAKE_TAG( 's', 'f', 'n', 't' )
+#define TTAG_SING  FT_MAKE_TAG( 'S', 'I', 'N', 'G' )
+#define TTAG_trak  FT_MAKE_TAG( 't', 'r', 'a', 'k' )
+#define TTAG_true  FT_MAKE_TAG( 't', 'r', 'u', 'e' )
+#define TTAG_ttc   FT_MAKE_TAG( 't', 't', 'c', ' ' )
+#define TTAG_ttcf  FT_MAKE_TAG( 't', 't', 'c', 'f' )
+#define TTAG_TYP1  FT_MAKE_TAG( 'T', 'Y', 'P', '1' )
+#define TTAG_typ1  FT_MAKE_TAG( 't', 'y', 'p', '1' )
+#define TTAG_VDMX  FT_MAKE_TAG( 'V', 'D', 'M', 'X' )
+#define TTAG_vhea  FT_MAKE_TAG( 'v', 'h', 'e', 'a' )
+#define TTAG_vmtx  FT_MAKE_TAG( 'v', 'm', 't', 'x' )
+
+
+FT_END_HEADER
+
+#endif /* __TTAGS_H__ */
+
+
+/* END */
diff --git a/include/freetype/ttunpat.h b/include/freetype/ttunpat.h
new file mode 100644
--- /dev/null
+++ b/include/freetype/ttunpat.h
@@ -0,0 +1,59 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ttunpat.h                                                              */
+/*                                                                         */
+/*    Definitions for the unpatented TrueType hinting system               */
+/*                                                                         */
+/*  Copyright 2003, 2006 by                                                */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  Written by Graham Asher <graham.asher@btinternet.com>                  */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef __TTUNPAT_H__
+#define __TTUNPAT_H__
+
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef FREETYPE_H
+#error "freetype.h of FreeType 1 has been loaded!"
+#error "Please fix the directory search order for header files"
+#error "so that freetype.h of FreeType 2 is found first."
+#endif
+
+
+FT_BEGIN_HEADER
+
+
+ /***************************************************************************
+  *
+  * @constant:
+  *   FT_PARAM_TAG_UNPATENTED_HINTING
+  *
+  * @description:
+  *   A constant used as the tag of an @FT_Parameter structure to indicate
+  *   that unpatented methods only should be used by the TrueType bytecode
+  *   interpreter for a typeface opened by @FT_Open_Face.
+  *
+  */
+#define FT_PARAM_TAG_UNPATENTED_HINTING  FT_MAKE_TAG( 'u', 'n', 'p', 'a' )
+
+ /* */
+
+FT_END_HEADER
+
+
+#endif /* __TTUNPAT_H__ */
+
+
+/* END */
diff --git a/include/ft2build.h b/include/ft2build.h
new file mode 100644
--- /dev/null
+++ b/include/ft2build.h
@@ -0,0 +1,39 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ft2build.h                                                             */
+/*                                                                         */
+/*    FreeType 2 build and setup macros.                                   */
+/*    (Generic version)                                                    */
+/*                                                                         */
+/*  Copyright 1996-2001, 2006 by                                           */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* This file corresponds to the default `ft2build.h' file for            */
+  /* FreeType 2.  It uses the `freetype' include root.                     */
+  /*                                                                       */
+  /* Note that specific platforms might use a different configuration.     */
+  /* See builds/unix/ft2unix.h for an example.                             */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#ifndef __FT2_BUILD_GENERIC_H__
+#define __FT2_BUILD_GENERIC_H__
+
+#include <freetype/config/ftheader.h>
+
+#endif /* __FT2_BUILD_GENERIC_H__ */
+
+
+/* END */
